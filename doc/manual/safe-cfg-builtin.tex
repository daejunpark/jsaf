
\chapter{Built-in Objects}
\section{Concrete Semantics}

\subsection{Helper Functions}
\[
\begin{array}{ll}
  \chf{getMatcher} & : \matcher \rightarrow (\SF{String} \times \SF{Int} \rightarrow \SF{MatchResult}) \\
\\
  \chf{NewRegExp} & : \SF{Value} \times \SF{Bool} \times \SF{Bool} \times \SF{Bool} \times \matcher \rightarrow \SF{Obj} \\
  & \chf{NewRegExp}(v_{source}, b_g, b_i, b_m, mid)
  = \set{
    \varprop{class}\mapsto ``RegExp",\\
    \varprop{proto}\mapsto
    \set{
      value=\varloc{RegExpProto};\\
      writable=\vfalse;\\
      enumerable=\vfalse;\\
      configurable=\vfalse\\
    },\\
    \varprop{matcher}\mapsto mid,\\
    ``source"\mapsto
    \set{
      value=v_{source};\\
      writable=\vfalse;\\
      enumerable=\vfalse;\\
      configurable=\vfalse\\
    },\\
    ``global"\mapsto
    \set{
      value=b_g;\\
      writable=\vfalse;\\
      enumerable=\vfalse;\\
      configurable=\vfalse\\
    },\\
    ``ignoreCase"\mapsto
    \set{
      value=b_i;\\
      writable=\vfalse;\\
      enumerable=\vfalse;\\
      configurable=\vfalse\\
    },\\
    ``multiline"\mapsto
    \set{
      value=b_m;\\
      writable=\vfalse;\\
      enumerable=\vfalse;\\
      configurable=\vfalse\\
    },\\
    ``lastIndex"\mapsto
    \set{
      value=0;\\
      writable=\vtrue;\\
      enumerable=\vfalse;\\
      configurable=\vfalse\\
    }\\
  }
\end{array}
\]

\subsection{Global}

\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{isNaN}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
 \quad\wherec{
  v =
  \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{true} & \ifc{\hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))=\SF{NaN}} \\
      \SF{false} & \owc \\
    \end{array}
  \right.}
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{isFinite}",args)\rbr(H,A)\hf{} 
 = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
 \quad\wherec{
  v =
  \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{false} & \ifc{\hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")) \in \set{\SF{NaN}, \SF{Inf}, \SF{-Inf}}}\\
      \SF{true} & \owc\\
    \end{array}
  \right.}
\\\\
\end{array}
\]


\subsection{Object}

\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.constructor}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
 \quad\wherec{
   v = \hf{getArgValue}(args, ``0") \land v \in \SF{Loc}}\\
   
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H(\#temp)[@return \mapsto l]], A)\\
 \quad\wherec{
   v = \hf{getArgValue}(args, ``0") \land v \in \SF{String} \cup \SF{Number} \cup \SF{Bool}\\
   \land\ l=\hf{newLocation}() \land o=\hf{toObject}(v) \land H_1=H\left[l\mapsto o\right]}\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
 \quad\wherec{
   v = \hf{getArgValue}(args, ``0") \land v \in \{ \SF{undefined}, \SF{null} \}\\
   \land\ l=\hf{newLocation}() \land o=\hf{NewObject}(\#ObjProto) \land H_1=H\left[l\mapsto o\right]}\\
\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getPrototypeOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getPrototypeOf}",args)\rbr(H,A)
 = (H[\#temp \mapsto H(\#temp)[@return \mapsto v_2]], A)\\
 \quad\wherec{
  v_1 = \hf{getArgValue}(args, ``0") \land v_1 \in\Loc \land v_2 = H(v)(@proto).value}\\
\\  

\end{array}
\]

\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyDescriptor}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyDescriptor}",args)\rbr(H,A)
 = (H[\#temp \mapsto H(\#temp)[@return \mapsto \SF{undefined}]], A)\\
  \quad\wherec{v = \hf{getArgValue}(args, ``0") \land v \in\Loc
  \land s = \hf{toString}(\hf{toPrimitive}(\hf{getArgValue}(args,``1"))) \land s \not\in dom(H(v))}\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyDescriptor}",args)\rbr(H,A)
 = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
  \quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v \in\Loc
  \land s = \hf{toString}(\hf{toPrimitive}(\hf{getArgValue}(args,``1"))) \land s \in dom(H(v))\\
  \land\ l=\hf{newLocation}() \land o=\hf{NewObject}(\#ObjProto)\\
  \land\ o_1 = \left\{
    \begin{array}{ll}
      o\left[
      \begin{array}{l}
        value \mapsto \left\{
        \begin{array}{l}
          value: H(v)(s).value\\
          writable: \SF{true} \\
          enumerable: \SF{true}\\
          configurable: \SF{true} \\
        \end{array}
        \right\}\\
        writable \mapsto \left\{
        \begin{array}{l}
          value: H(v)(s).writable\\
          writable: \SF{true} \\
          enumerable: \SF{true}\\
          configurable: \SF{true} \\
        \end{array}
        \right\}\\
      \end{array}\right] & \ifc{\hf{\inred IsDataDescriptor}(H(v),s)}\\
      o  & \quad\owc
    \end{array}\right.\\
  \land\ o_2 = o_1\left[
    \begin{array}{l}
      enumerable \mapsto \left\{
        \begin{array}{l}
          value: H(v)(s).enumerable, \quad writable: \SF{true} \\
          enumerable: \SF{true}, \quad configurable: \SF{true} \\
        \end{array}
        \right\}\\
      configurable \mapsto \left\{
        \begin{array}{l}
          value: H(v)(s).configurable, \quad writable: \SF{true} \\
          enumerable: \SF{true}, \quad configurable: \SF{true} \\
        \end{array}
        \right\}\\
    \end{array}\right]\\
  \land\ H_1=H\left[l\mapsto o_2\right]}\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyNames}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyNames}",args)\rbr(H,A)
 = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
  \quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v \in\Loc\\
  \land\ l=\hf{newLocation}() \land o=\hf{NewArrayObject}(0) \land\ n = 0\\
  \land\ o_1 = o\left[
    \begin{array}{l}
      \forall s \in dom(H(v)): 
      \hf{toString}(n^{++}) \mapsto \left\{
        \begin{array}{l}
          value: s\\
          writable: \SF{true} \\
          enumerable: \SF{true}\\
          configurable: \SF{true} \\
        \end{array}
        \right\}\\
    \end{array}\right]\\
  \land H_1=H\left[l\mapsto o_1\right]}\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.create}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land (v\not\in\Loc \lor v \in \{\SF{null}\})\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.create}",args)\rbr(H,A)
 = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v \in\Loc \land |args| = 1 \\
  \land\ l=\hf{newLocation}() \land o=\hf{NewObject}(v)
  \land H_1 = H\left[l\mapsto o_1\right]}\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.create}",args)\rbr(H,A)
 = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v_1 = \hf{getArgValue}(args, ``0") \land v \in\Loc
  \land |args| > 1 \land v_2 = \hf{getArgValue}(args, ``1")\\
  \land\ l=\hf{newLocation}() \land o=\hf{NewObject}(v_1)\\
  \land\ o_1 = \left\{\begin{array}{ll}
    o & v_2 = \SF{undefined}\\
    o\left[
    \forall x\in dom(H(v_2)): x \mapsto \left\{
      \begin{array}{l}
        value: H(v_2)(x)(``value")\\
        writable: H(v_2)(x)(``writable") \\
        enumerable: H(v_2)(x)(``enumerable")\\
        configurable: H(v_2)(x)(``configurable")\\
      \end{array}
      \right\}
    \right]  & \owc\\  
    \end{array}\right.\\
  \land\ H_1 = H\left[l\mapsto o_1\right]}\\
\end{array}
\]


\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperty}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperty}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v_1 = \hf{getArgValue}(args, ``0") \land v_1 \in\Loc
  \land\ v_2 = \hf{getArgValue}(args, ``2") \land v_2 \not\in \Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperty}",args)\rbr(H,A)
 = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v_1]], A)\\
\quad\wherec{
  v_1 = \hf{getArgValue}(args, ``0") \land v_1 \in\Loc
  \land\ v_2 = \hf{getArgValue}(args, ``2") \land v_2 \in \Loc\\
  \land\ s = \hf{toString}(\hf{getArgValue}(args, ``1"))\\
  \land\ o = H(v_1)\left[
    s \mapsto \left\{
      \begin{array}{l}
        value: \hf{Proto}(H, v_2, ``value")\\
        writable: \hf{Proto}(H, v_2, ``writable") \\
        enumerable: \hf{Proto}(H, v_2, ``enumerable")\\
        configurable: \hf{Proto}(H, v_2, ``configurable")\\
      \end{array}
      \right\}
    \right]\\ 
  \land\ H_1=H\left[l\mapsto o\right]}\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperties}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperties}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v_1 = \hf{getArgValue}(args, ``0") \land v_1 \in\Loc
  \land\ v_2 = \hf{getArgValue}(args, ``1") \land (H_1, exc) = \hf{ToObject}(H, v_2)\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperties}",args)\rbr(H,A)
 = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v_1]], A)\\
\quad\wherec{
  v_1 = \hf{getArgValue}(args, ``0") \land v_1 \in\Loc
  \land\ v_2 = \hf{getArgValue}(args, ``1") \land (H_1, l_1) = \hf{ToObject}(H, v_2)\\
  \land\ o = H(v_1)\left[
    \forall x\in dom(H(v_2)): x \mapsto \left\{
      \begin{array}{l}
        value: H(v_2)(x)(``value")\\
        writable: H(v_2)(x)(``writable") \\
        enumerable: H(v_2)(x)(``enumerable")\\
        configurable: H(v_2)(x)(``configurable")\\
      \end{array}
      \right\}
    \right]\\ 
  \land\ H_1=H\left[l\mapsto o\right]}\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.seal}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.seal}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc\\
  \land\ H_1 = H\left[H(v) \mapsto \left[
    \begin{array}{l}
      \forall x \in \hf{Dom}(H(v)):x \mapsto H(v)(x)\rwith configurable=\SF{false};, \\
      \varprop{extensible} \mapsto \SF{false};
    \end{array}\right]\right]\\
   }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.freeze}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.seal}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc\\
  \land\ H_1 = H\left[ H(v)\left[
    \begin{array}{l}
      \forall x\in P_1 : x \mapsto H(v)(x)\rwith writable=\SF{false};configurable=\SF{false};, \\
      \forall y\in P_2 : y \mapsto H(v)(y)\rwith configurable=\SF{false};, \\
      \varprop{extensible} \mapsto \SF{false};
    \end{array}\right]\right]\\
  \land\ P_1 = \{ x\ |\ x\ \in dom(H(v)(x)) \land \hf{\inred IsDataDescriptor}(x) \} \\
  \land\ P_2 = \{ x\ |\ x\ \in dom(H(v)(x)) \land \neg\hf{\inred IsDataDescriptor}(x) \}
  }\\
\\\\

\end{array}
\]



\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.preventExtensions}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.preventExtensions}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc\\
  \land\ H_1 = H\left[H(v) \mapsto [\varprop{extensible} \mapsto \SF{false}]\right]\\
   }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isSealed}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isSealed}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto \SF{false}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc
  \land \exists x \in dom(H(v)) : H(v)(x).configurable = \SF{true}
  }\\
   
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isSealed}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto b]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc
  \land \forall x \in dom(H(v)) : H(v)(x).configurable = \SF{false}\\
  \land\ b = \left\{
    \begin{array}{ll}
      \SF{true} & \ifc{H(v)(@extensible) = \SF{false}}\\
      \SF{false} & \owc
    \end{array}\right.
   }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isFrozen}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isFrozen}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto \SF{false}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc\\
  \land\ \exists x \in dom(H(v)) :\left(
    \begin{array}{l}
      (\hf{\inred IsDataDescription}(x) \land (H(v)(x).writable = \SF{true} \lor H(v)(x).configurable = \SF{true}))\\
      \lor (\neg \hf{\inred IsDataDescription} \land H(v)(x).configurable = \SF{true})
    \end{array}\right)
  }\\
   
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isFrozen}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto b]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc\\
  \land\ \forall x \in dom(H(v)) :\left(
    \begin{array}{l}
      (\hf{\inred IsDataDescription}(x) \land H(v)(x).writable = \SF{false} \land H(v)(x).configurable = \SF{false})\\
      \lor (\neg \hf{\inred IsDataDescription} \land H(v)(x).configurable = \SF{false})
    \end{array}\right)\\
  \land\ b = \left\{
    \begin{array}{ll}
      \SF{true} & \ifc{H(v)(@extensible) = \SF{false}}\\
      \SF{false} & \owc
    \end{array}\right.
   }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isExtensible}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isExtensible}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto H(v)(@extensible)]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc}\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.keys}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_{e}]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v\not\in\Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.keys}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l ]], A) \\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land v  \in\Loc\
  \land P = |\{x \mid  x\in dom(H(v)) \land H(v)(x).enumerable = \SF{true} \} |\\
  \land\ n_1 = |P| \land l=\hf{newLocation}() \land o=\hf{NewArrayObject}(n_1) \land\ n_2 = 0\\
  \land\ o_1 = o\left[
    \begin{array}{l}
      \forall x \in P: 
      \hf{toString}(n_2^{++}) \mapsto \left\{
        \begin{array}{l}
          value: x\\
          writable: \SF{true} \\
          enumerable: \SF{true}\\
          configurable: \SF{true} \\
        \end{array}
        \right\}\\
    \end{array}\right]\\
    \land\ H_1 = H\left[l\mapsto o_1\right]
   }\\
\\\\

\end{array}
\]

\subsection{Object.prototype}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  \V _{cp}\lbr \TT{this}\rbr (H,A) = \SF{undefined} \land s =  ``\SF{[object Undefined]}"
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  \V _{cp}\lbr \TT{this}\rbr (H,A) = \SF{null} \land s =  ``\SF{[object Null]}"
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land  v_1 \not\in \{ \SF{undefined}, \SF{null} \}\\
  \land\ (H_1, v_2) = \hf{toObject}(H, v_1) \land s =  ``\SF{[object}" + H(v_2)(@class) + ``\SF{]}"
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, exc) = \hf{toObject}(H, v)\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1) \land H_1(v_2)(``toString") \not\in \Loc\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})]
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1)
  \land  v_3 = H_1(v_2)(``toString") \land v_3 \in \Loc\\
  \neg \hf{IsCallable}(H_1, v_3)
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})]
  }\\
  
\inred \I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto l_e]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1)
  \land  v_3 = H_1(v_2)(``toString") \land v_3 \in \Loc\\
  \hf{IsCallable}(H_1, v_3)
  \inred ?????
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.valueOf}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, exc) = \hf{toObject}(H, v)\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.valueOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v_1]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1)
  \land H(v)(\varprop{class})=``Object"
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.hasOwnProperty}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, exc) = \hf{toObject}(H, v)\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.hasOwnProperty}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto b]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1)
  \land v_3 =  \hf{getArgValue}(args, ``0")\\
  \land\ s = \hf{toString}(\hf{toPrimitive}(v_3)) \land b = \hf{HasOwnProperty}(H_1, v_2, s)
  }\\
\\\\
\end{array}
\]

\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.isPrototypeOf}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto \SF{false}]], A) \\
\quad\wherec{
  v =  \hf{getArgValue}(args, ``0") \land v \not\in \Loc
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.isPrototypeOf}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_1 =  \hf{getArgValue}(args, ``0") \land v_1 \in \Loc
  \land v_2 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, exc) = \hf{toObject}(H, v_2) \\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.isPrototypeOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v_4]], A) \\
\quad\wherec{
  v_1 =  \hf{getArgValue}(args, ``0") \land v_1 \in \Loc
  \land v_2 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_3) = \hf{toObject}(H, v_2) \\
  v_4 = \hf{inherit}(H_1, v_1, v_3)
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.propertyIsEnumerable}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, exc) = \hf{toObject}(H, v) \\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.propertyIsEnumerable}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto \SF{false}]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1)
  \land v_3 =  \hf{getArgValue}(args, ``0")\\
  \land\ s = \hf{toString}(\hf{toPrimitive}(v_3)) \land \neg \hf{HasOwnProperty}(H_1, v_2, s)
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.propertyIsEnumerable}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto b]], A) \\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1, v_2) = \hf{toObject}(H, v_1)
  \land v_3 =  \hf{getArgValue}(args, ``0")\\
  \land\ s = \hf{toString}(\hf{toPrimitive}(v_3)) \land \hf{HasOwnProperty}(H_1, v_2, s)
  \land b = H_1(v_2)(s).enumerable
  }\\
\\\\

\end{array}
\]


\subsection{Function}

\subsection{Function.prototype}
\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.toString}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.toString}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land H(v)(@class) \neq ``Function"\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.toString}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{ 
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land H(v)(@class) = ``Function"
  \land\ s = \hf{\inred fid2String}(H(v)(\varprop{function})
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land \neg \hf{IsCallable}(H,v)\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{fun} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{fun} \in \SF{Loc} \land \hf{IsCallable}(H,v_{fun})\\
  \land\ v_{arg} = \hf{getArgValue}(args, ``1") \land v_{arg} \not\in \set{\SF{null},\SF{undefined}}
  \land v_{arg} \not\in \SF{Loc}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(H,A) = (H_2, A_1)\\
\quad\wherec{
  v_{fun} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{fun} \in \SF{Loc} \land \hf{IsCallable}(H,v_{fun})\\
  \land\ v_{arg} = \hf{getArgValue}(args, ``1") \land v_{arg} \in \set{\SF{null},\SF{undefined}}
  \land\ o_{arg} = \hf{NewArgObject}(0)\\
  \land\ l_{arg} = \hf{newLocation}() \land H_1 = H[l_{arg} \mapsto o_{arg}]
  \land\ l_{scope} = \hf{newLocation}()\\
  \land\ A_1=\hf{PushStack}(H(v_{fun})(\varprop{scope}),l_{scope}) \\
  \land\ o_{scope} = \set{
    arguments \mapsto \set{value : l_{arg},\\ 
      writable : \SF{true},\\ unumarable : \SF{false},\\ configurable : \SF{false}},\\
    \varprop{this} \mapsto \hf{getArgValue}(args, ``0"),\\
    \varprop{up} \mapsto A,\\
    \varprop{return} \mapsto H(\varloc{temp})(\varprop{return})}
  \land H_2 = H_1[l_{new} \mapsto o_{scope}]\\
  \land\ fid_{callee}= H(v_{fun})(\varprop{function})
  \land cp_{\textit{after-call}} = \hf{getAftercallFromCall}_P(cp) \\
  \land\ {\inblue \cfgnext} :=
  {\inblue \cfgnext}\cup\set{( cp,(fid_{callee},\SF{ENTRY})),
    ((fid_{callee},\SF{EXIT}), cp_{\textit{after-call}})}\\
  \land\ {\inblue \excnext}:={\inblue \excnext}
  \cup\set{((fid_{callee},\SF{EXIT-EXC}), cp_{\textit{after-call}})}\\
  \land\ \hf{BelongsTo}:=\hf{BelongsTo}\cup\set{(l_{new},cp)}
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(H,A) = (H_2, A_1)\\
\quad\wherec{
  v_{fun} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{fun} \in \SF{Loc} \land \hf{IsCallable}(H,v_{fun})\\
  \land\ v_{arg} = \hf{getArgValue}(args, ``1") \land v_{arg} \not\in \set{\SF{null},\SF{undefined}}
  \land v_{arg} \in \SF{Loc} \land n_{len} = \hf{Proto}(H,v_{arg},``length")\\
  \land\ o_{arg} = \hf{NewArgObject}(n_{len})\left[ \forall i \in \set{0, ..., n_{len}-1}: 
    ``i" \mapsto \hf{Proto}(H,v_{arg},``i") \right] \land l_{arg} = \hf{newLocation}()\\
  \land\ H_1 = H[l_{arg} \mapsto o_{arg}] \land o_{arg} = \hf{NewArgObject}(0)
  \land\ l_{arg} = \hf{newLocation}() \land H_1 = H[l_{arg} \mapsto o_{arg}]\\
  \land\ l_{scope} = \hf{newLocation}()
  \land\ A_1=\hf{PushStack}(H(v_{fun})(\varprop{scope}),l_{scope}) \\
  \land\ o_{scope} = \set{
    arguments \mapsto \set{value : l_{arg},\\ 
      writable : \SF{true},\\ unumarable : \SF{false},\\ configurable : \SF{false}},\\
    \varprop{this} \mapsto \hf{getArgValue}(args, ``0"),\\
    \varprop{up} \mapsto A,\\
    \varprop{return} \mapsto H(\varloc{temp})(\varprop{return})}
  \land H_2 = H_1[l_{new} \mapsto o_{scope}]\\
  \land\ fid_{callee}= H(v_{fun})(\varprop{function})
  \land cp_{\textit{after-call}} = \hf{getAftercallFromCall}_P(cp) \\
  \land\ {\inblue \cfgnext} :=
  {\inblue \cfgnext}\cup\set{( cp,(fid_{callee},\SF{ENTRY})),
    ((fid_{callee},\SF{EXIT}), cp_{\textit{after-call}})}\\
  \land\ {\inblue \excnext}:={\inblue \excnext}
  \cup\set{((fid_{callee},\SF{EXIT-EXC}), cp_{\textit{after-call}})}\\
  \land\ \hf{BelongsTo}:=\hf{BelongsTo}\cup\set{(l_{new},cp)}
  }\\
\\\\


\end{array}
\]


\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.call}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  \I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.call}",args)\rbr(H,A)

 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land \neg \hf{IsCallable}(H,v)\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.call}",args)\rbr(H,A) = (H_2, A_1) \\
\quad\wherec{
  v_{fun} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{fun} \in \SF{Loc} \land \hf{IsCallable}(H,v_{fun})
  \land n_{len} = \hf{ToUInt32}(\hf{getArgValue}(args, ``length"))\\
  \land\ o_{arg} = \hf{NewArgObject}(n_{len}-1)\left[ \forall i \in \set{1, ..., n_{len}}: 
    ``i" \mapsto \hf{getArgValue}(args, ``i") \right] \\
  \land\ l_{arg} = \hf{newLocation}()\land H_1 = H[l_{arg} \mapsto o_{arg}]\\
  \land\ l_{scope} = \hf{newLocation}()
  \land\ A_1=\hf{PushStack}(H(v_{fun})(\varprop{scope}),l_{scope}) \\
  \land\ o_{scope} = \set{
    arguments \mapsto \set{value : l_{arg},\\ 
      writable : \SF{true},\\ unumarable : \SF{false},\\ configurable : \SF{false}},\\
    \varprop{this} \mapsto \hf{getArgValue}(args, ``0"),\\
    \varprop{up} \mapsto A,\\
    \varprop{return} \mapsto H(\varloc{temp})(\varprop{return})}
  \land H_2 = H_1[l_{new} \mapsto o_{scope}]\\
  \land\ fid_{callee}= H(v_{fun})(\varprop{function})
  \land cp_{\textit{after-call}} = \hf{getAftercallFromCall}_P(cp) \\
  \land\ {\inblue \cfgnext} :=
  {\inblue \cfgnext}\cup\set{( cp,(fid_{callee},\SF{ENTRY})),
    ((fid_{callee},\SF{EXIT}), cp_{\textit{after-call}})}\\
  \land\ {\inblue \excnext}:={\inblue \excnext}
  \cup\set{((fid_{callee},\SF{EXIT-EXC}), cp_{\textit{after-call}})}\\
  \land\ \hf{BelongsTo}:=\hf{BelongsTo}\cup\set{(l_{new},cp)}
} \\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.bind}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.bind}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land \neg \hf{IsCallable}(H,v)\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\end{array}
\]


\subsection{Array}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constuctor}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l]], A) \\
\quad\wherec{
  \hf{getArgValue}(args, ``length") = 0 \land l = \hf{newLocation}()
  \land H_1 = H[l \mapsto \hf{NewArrayObject}(0)]
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constuctor}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{len} = \hf{getArgValue}(args, ``length") \land v_{len} = 1 \land v_{len} \in \SF{Number} 
  \land v_{len} \neq \hf{ToUInt32}(v_{len})\\
  \land\ l_e = \hf{newLocation}() \land H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{RangeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constuctor}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l]], A) \\
\quad\wherec{
  v_{len} = \hf{getArgValue}(args, ``length") \land v_{len} = 1 \land v_{len} \in \SF{Number} 
  \land n_{len32} = \hf{ToUInt32}(v_{len}) \land v_{len} = n_{len32}\\
  \land\ l = \hf{newLocation}()  \land H_1 = H[l \mapsto \hf{NewArrayObject}(n_{len32})]
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constuctor}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l]], A) \\
\quad\wherec{
  v_{len} = \hf{getArgValue}(args, ``length") \land v_{len} = 1 \land v_{len} \not\in \SF{Number}\\
  \land\ l = \hf{newLocation}()  \land H_1 = H[l \mapsto \hf{NewArrayObject}(1)[``0" \mapsto v_{len}]]
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constuctor}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l]], A) \\
\quad\wherec{
  v_{len} = \hf{getArgValue}(args, ``length") \land v_{len} > 1 \land l = \hf{newLocation}()\\
  \land\ H_1 = H[l \mapsto \hf{NewArrayObject}(v_{len})
    [\forall i \in \set{0,..., v_{len} -1}:``i" \mapsto \hf{getArgValue}(args, ``i")]]
  }\\
  
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.isArray}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto \SF{false}]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc} 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.isArray}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto b]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc}
  \land b = \left\{\begin{array}{ll}
      \SF{true} & \ifc{H(v)(@class) = ``Array"}\\
      \SF{false} & \owc
    \end{array}\right.
  }\\
\end{array}
\]


\subsection{Array.prototype}
\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toString}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v)\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toString}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto s_{join}]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v)\\
  \land\ s = \left\{
    \begin{array}{ll}
      ``\SF{[object}" + H(v_2)(@class) + ``\SF{]}"
      & \ifc{\hf{Proto}(H,l,``join") \not\in \SF{Loc} \lor \hf{IsCallable}(H_1,\hf{Proto}(H,l,``join"))}\\
      s_{join} & \owc
    \end{array}
    \right.\\
  \land\ n_{len} = \hf{Proto}(H_1, l, ``length")\\
  \land\ s_i = \left\{\begin{array}{ll}
      ``" & \ifc{\hf{Proto}(H_1, l, ``i") \in \{ \SF{null}, \SF{undefined}\}}\\
      \hf{ToString}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``i"))) & \owc
    \end{array}\right.\\
  \land\ s_{join} = \left\{\begin{array}{ll}
    ``" & \ifc{n_{len} = 0}\\
    s_0 + ``," + s_1 + ``," + ... + ``," + s_{n_{len}-1} & \owc
    \end{array}\right.\\
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.concat}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v)\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
   
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.concat}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto l_{new}]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}()
  \land n = 0\\
  \land\ o = \hf{NewArrayObject}(0)\left[
        \forall i \in \{0,... H(l)(``length") -1\}:\hf{toString}(n^{++}) \mapsto H(l)(``i")\right]\\
  \land\ v_{len} = \hf{getArgValue}(args, ``length") \land v_i = \hf{getArgValue}(args, ``i")\\
  \land\ o_1 = o\left[\forall i \in \{0, v_{len} - 1\}:
    \left\{\begin{array}{ll}
      \begin{array}{l}
        \forall j \in \{0,... H(v_i)(``length") -1\}:\\
        \quad\quad\hf{toString}(n^{++}) \mapsto \hf{Proto}(H,v_i,``j")
      \end{array}
      & \ifc{v_i \in \SF{Loc}\\ \land H(v_i)(@class) = ``Array"}\\
      \hf{toString}(n^{++}) \mapsto v_i & \owc
    \end{array}\right.
  \right]\\
  \land\ l_{new} = \hf{newLocatioin}() \land H_2 = H_1[l_{new} \mapsto o_1]
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.join}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v)\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.join}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v)
  \land v_0 = \hf{getArgValue}(args, ``0")\\
  \land\ s_{sep} = \left\{
    \begin{array}{ll}
      ``," & \ifc{v_0 = \SF{undefined}}\\
      \hf{ToString}(\hf{ToPrimitive}(v_o)) & \owc
    \end{array}
    \right.\\
  \land\ n_{len} = \hf{Proto}(H_1, l, ``length")\\
  \land\ s_i = \left\{\begin{array}{ll}
      ``" & \ifc{\hf{Proto}(H_1, l, ``i") \in \{ \SF{null}, \SF{undefined}\}}\\
      \hf{ToString}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``i"))) & \owc
    \end{array}\right.\\
  \land\ s = \left\{\begin{array}{ll}
    ``" & \ifc{n_{len} = 0}\\
    s_0 + s_{sep} + s_1 + s_{sep} + ... + s_{sep} + s_{n_{len}-1} & \owc
    \end{array}\right.\\
  }\\
\\\\
\end{array}
\]


\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.pop}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.pop}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto v]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})
  \land n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ (H_2, v) = \left\{\begin{array}{ll}
    (\hf{PropStore}(H_1, l, ``length", 0), \SF{undefined}) & \ifc{n_{len} = 0}\\
    \left(\begin{array}{l}
      \hf{Delete}(\hf{PropStore}(H_1, l, ``length", n_{len} -1),l, \hf{ToString}(n_{len}-1)).1,\\
      \hf{Proto}(H_1, l, \hf{ToString}(n_{len}-1))
    \end{array}\right)
     & \owc
    \end{array}\right.
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.push}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.push}",args)\rbr(H,A)
 = (H_3[\varloc{temp}\mapsto H_3(\varloc{temp})[\varprop{return}\mapsto n]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))
  \land n_{arglen} = \hf{getArgValue}(args, ``length")\\
  \land\ H_2 = H_1\left[ l \mapsto H_1(l)\left[\forall i \in \{0,...,n_{arglen}-1\}: 
    \hf{ToString}(n_{len}+i) \mapsto \hf{getArgValue}(args, ``i")\right]\right]\\
  \land\ n=n_{len} + n_{arglen}
  \land H_3 = \hf{PropStore}(H_2, l,``length", n)\\
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.reverse}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.push}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto l]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))
  \land n_{last} = n_{len}-1 \land\ n_{mid} = native.floor(n_{len}/2)\\
  \land\ b_i = \hf{HasProperty}(H_1, l, i) \land o = H(l)\\
  \land\ o_1 = o\left[\forall i \in \{0,...,n_{mid}-1\}: \left\{\begin{array}{ll}
    \begin{array}{l}
      \hf{ToString}(i) \mapsto \hf{Proto}(H_1, l, \hf{ToString}(n_{last} - i)),\\
      \hf{ToString}(n_{last} - i) \mapsto \hf{Proto}(H_1, l,  \hf{ToString}(i))\\
    \end{array}
    & \ifc{b_i \land b_{n_{last} - i} }\\
    \hf{ToString}(i) \mapsto \hf{Proto}(H_1, l, \hf{ToString}(n_{last} - i) 
    & \ifc{\neg b_i \land b_{n_{last} - i} }\\
    \hf{ToString}(n_{last} - i) \mapsto \hf{Proto}(H_1, l,  \hf{ToString}(i)
    & \ifc{b_i \land \neg b_{n_{last} - i} }\\
  \end{array}\right.\right]\\
  \land\ H_2 = H_1[ l \mapsto o_1]\\
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.shift}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.shift}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto v]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ (H_2,v) = \left\{\begin{array}{ll}
    (H_1,\SF{undefined}) &  \ifc{n_{len} = 0}\\
    (H_1[l \mapsto o_1], \hf{Proto}(H_1, l, ``0")& \owc
    \end{array}\right.\\
  \land\ o_1 = H_1(l)\left[\forall i \in \{1,...,n_{len}-1\}: \
      \hf{ToString}(i) \mapsto \hf{Proto}(H_1, l, \hf{ToString}(i-1))\quad\ifc{\hf{HasProperty}(H_1, l, i)}\right]\\
  }\\
\\\\
\end{array}
\]

\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.slice}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.slice}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto l_{new}]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ n_{argstart} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{start} = \left\{\begin{array}{ll}
      0 & \ifc{n_{argstart} < 0 \land n_{len} + n_{argstart} \leq 0}\\
      n_{len} + n_{argstart} & \ifc{n_{argstart} < 0 \land n_{len} + n_{argstart} > 0}\\
      n_{argstart} & \ifc{n_{argstart} \geq 0 \land n_{argstart} < n_{len}}\\
      n_{len}  & \ifc{n_{argstart} \geq 0 \land n_{argstart} \geq n_{len}}\\
    \end{array}\right.\\
  \land\ n_{argend} = \left\{\begin{array}{ll}
      n_{len} & \ifc{\hf{getArgValue}(args, ``1") = \SF{undefined}}\\
      \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1"))) & \owc\\
    \end{array}\right.\\
  \land\ n_{end} = \left\{\begin{array}{ll}
      0 & \ifc{n_{argend} < 0 \land n_{len} + n_{argend} \leq 0}\\
      n_{len} + n_{argend} & \ifc{n_{argend} < 0 \land n_{len} + n_argend > 0}\\
      n_{argend} & \ifc{n_{argend} \geq 0 \land n_{argend} < n_{len}}\\
      n_{len}  & \ifc{n_{argend} \geq 0 \land n_{argend} \geq n_{len}}\\
    \end{array}\right.\\
  \land\ o = \hf{NewArrayObject}(0)\\
  \land\ o_1 = o\left[\forall i \in \{n_{start},...,n_{end}-1\}: \
      \hf{ToString}(i) \mapsto \hf{Proto}(H_1, l, \hf{ToString}(i-1))\quad\ifc{\hf{HasProperty}(H_1, l, i)}\right]\\
  \land\ l_{new} = \hf{newLocation}() \land H_2 = H_1[l_{new} \mapsto o_1]
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.splice}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.splice}",args)\rbr(H,A)
 = (H_3[\varloc{temp}\mapsto H_3(\varloc{temp})[\varprop{return}\mapsto l_{new}]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{arglen} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``length")))
  \land n_{arglen} = 2\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ n_{argstart} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{start} = \left\{\begin{array}{ll}
      0 & \ifc{n_{argstart} < 0 \land n_{len} + n_{argstart} \leq 0}\\
      n_{len} + n_{argstart} & \ifc{n_{argstart} < 0 \land n_{len} + n_{argstart} > 0}\\
      n_{argstart} & \ifc{n_{argstart} \geq 0 \land n_{argstart} < n_{len}}\\
      n_{len}  & \ifc{n_{argstart} \geq 0 \land n_{argstart} \geq n_{len}}\\
    \end{array}\right.\\
  \land\ n_{argdel} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1")))\\
  \land\ n_{del} = min(max(n_{argdel}, 0), n_{len} - n_{start})\\
  \land\ o = \hf{NewArrayObject}(0)\\
  \land\ o_1 = o\left[\forall i \in \{0,...,n_{del}-1\}: \
    \hf{ToString}(i) \mapsto \hf{Proto}(H_1, l, n_{start}+i)
    \quad\ifc{\hf{HasProperty}(H_1, l, i+n_{del})}\right]\\
  \land\ H_2 = H_1\left[l \mapsto H_1(l)\left[\forall i \in \{n_{start},...,n_{start}+n_{del}-1\}: \
    \hf{ToString}(i) \not\mapsto  \comment{{\inblue // delete prop}}\right]\right]\\
  \land\ l_{new} = \hf{newLocation}() \land H_3 = H_2[l_{new} \mapsto o_1]
  }\\
  
\end{array}
\]

\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.splice}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{return}\mapsto l_{new}]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{arglen} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``length")))
  \land n_{arglen} > 2 \land n_{replace} = n_{arglne} - 2\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ n_{argstart} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{start} = \left\{\begin{array}{ll}
      0 & \ifc{n_{argstart} < 0 \land n_{len} + n_{argstart} \leq 0}\\
      n_{len} + n_{argstart} & \ifc{n_{argstart} < 0 \land n_{len} + n_{argstart} > 0}\\
      n_{argstart} & \ifc{n_{argstart} \geq 0 \land n_{argstart} < n_{len}}\\
      n_{len}  & \ifc{n_{argstart} \geq 0 \land n_{argstart} \geq n_{len}}\\
    \end{array}\right.\\
  \land\ n_{argdel} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1")))\\
  \land\ n_{del} = min(max(n_{argdel}, 0), n_{len} - n_{start})\\
  \land\ o = \hf{NewArrayObject}(0)\\
  \land\ o_1 = o\left[\forall i \in \{0,...,n_{del}-1\}:
    \hf{ToString}(i) \mapsto \hf{Proto}(H_1, l, n_{start}+i)
    \quad\ifc{\hf{HasProperty}(H_1, l, i+n_{del})}\right]\\
  \land\ H_2 = H_1\left[l \mapsto H_1(l)\left[
    \begin{array}{l}
      \forall i \in \{n_{start},...,n_{start}+n_{del}-1\}:\hf{ToString}(i) \not\mapsto,
        \comment{{\inblue // delete prop}}\\
      \forall j \in \{0,...,n_{del}-1\}:\hf{ToString}(j) \mapsto
        \hf{getArgValue}(args, n_{start} + j),\\
      \forall k \in \{0,...,n_{len}-n_{start}-n_{del}-1\}:\\
        \quad\hf{ToString}(n_{start} + n_{replace} + k) \mapsto \hf{Proto}(H_1, l,n_{start} + n_{del} + k)
    \end{array}
    \right]\right]\\
  \land\ l_{new} = \hf{newLocation}() \land H_3 = H_2[l_{new} \mapsto o_1]
  }\\
\\\\



\end{array}
\]

\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.unshift}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.unshift}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto n]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})\\
  \land\ n_{arglen} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``length")))\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ n_{argstart} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ H_2 = H_1\left[l \mapsto H_1(l)\left[
    \begin{array}{l}
      \forall i \in \{0,...,n_{len}-1\}:\\
        \quad\quad\hf{ToString}(n_{arglen}+i) \mapsto \hf{Proto}(H_1, l, i)
        \quad\ifc{\hf{HasProperty}(H_1,l,i)}\\
      \forall j \in \{0,...,n_{arglen}-1\}:\hf{ToString}(j) \mapsto \hf{getArgValue}(args,j)
    \end{array}
    \right]\right]\\
  \land\ l_{new} = \hf{newLocation}() \land H_3 = H_2[l_{new} \mapsto o_1] \land n = n_{len} + n_{arglen}
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.indexOf}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.indexOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto n_{pos}]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})
  \land v_{find} = \hf{getArgValue}(args,``0")\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ n_{start} = \left\{\begin{array}{ll}
      \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1")))
      & \ifc{\hf{getArgValue}(args, ``length") > 1}\\
      0 & \owc\\
    \end{array}\right.\\
  \land\ n_{pos} = \left\{\begin{array}{ll}
      -1 & \ifc{n_{start} > n_{len}-1}\\
      -1 & \ifc{\begin{array}{l}
        \neg\exists i \in \{n_{start},...n_{len}-1\}:\\
        \quad(\hf{HasProperty}(H_1,l,i) \land Proto(H,l,i) = v_{find})\end{array}}\\
      min\left(\begin{array}{l}
        \forall i \in \{n_{start},...n_{len}-1\}:\\
        \quad\left(\begin{array}{l}
          \hf{HasProperty}(H_1,l,i)\\
          \land Proto(H,l,i) = v_{find}\end{array}\right)\end{array}\right) & \owc
    \end{array}\right.\\
  }\\
\\\\

\end{array}
\]

\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.lastIndexOf}",args)\rbr(H,A)
 = (H_2[\varloc{temp}\mapsto H_2(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,exc) = \hf{ToObject}(H,v_{this})\\
  \land\ l_e = \hf{newLocation}() \land H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(exc)] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.lastIndexOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto n_{pos}]], A) \\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land (H_1,l) = \hf{ToObject}(H,v_{this})
  \land v_{find} = \hf{getArgValue}(args,``0")\\
  \land\ n_{len} = \hf{ToUInt32}(\hf{ToPrimitive}(\hf{Proto}(H_1, l, ``length")))\\
  \land\ n_{end} = \left\{\begin{array}{ll}
      \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1")))
      & \ifc{\hf{getArgValue}(args, ``length") > 1}\\
      n_{len}-1 & \owc\\
    \end{array}\right.\\
  \land\ n_{pos} = \left\{\begin{array}{ll}
      -1 & \ifc{\begin{array}{l}
        \neg\exists i \in \{0,...n_{end}\}:\\
        \quad(\hf{HasProperty}(H_1,l,i) \land Proto(H,l,i) = v_{find})\end{array}}\\
      max\left(\begin{array}{l}
        \forall i \in \{0,...n_{len}\}:\\
        \quad\left(\begin{array}{l}
          \hf{HasProperty}(H_1,l,i)\\
          \land Proto(H,l,i) = v_{find}\end{array}\right)\end{array}\right) & \owc
    \end{array}\right.\\
  }\\
\\\\

\end{array}
\]
\subsection{String}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.constructor}",args)\rbr(H,A)
 = H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l_{new}]], A) \\
\quad\wherec{
  s = \left\{\begin{array}{ll}
      ``" & \ifc{\hf{getArgValue}(args,``length") < 1}\\
      \hf{toString}(\hf{toPrimitive}(\hf{getArgValue}(args,``0"))) & \owc
    \end{array}\right.\\
  \land\ l_{new} = \hf{newLocation}()\land H_1 = H[l_{new} \mapsto \hf{Newstring}(s)]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.fromCharCode}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  s_{init} = ``" \land s_i = \hf{toString}(native.toChar(\hf{toPrimitive}(\hf{getArgValue}(args,``i"))))
  \quad\comment{{\inblue // java, scala}}\\
  \land\ n = \hf{getArgValue}(args, ``length") \land s = s_{init} + s_0 + s_i + ... + s_n
  }\\
\end{array}
\]

\subsection{String.prototype}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toString}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toString}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land H(v)(@class) \neq ``String"\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toString}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{ 
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land H(v)(@class) = ``String"
  \land\ s = H(v)(\varprop{primitive})
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.valueOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.valueOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land H(v)(@class) \neq ``String"\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.valueOf}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{ 
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc} \land H(v)(@class) = ``String"
  \land\ s = H(v)(\varprop{primitive})
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charAt}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charAt}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s_2]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_1 = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ n_{pos} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0"))) \land n_{size} = s.length\\
  \land\ s_2 = \left\{\begin{array}{ll}
      ``"& \ifc{n_{pos} < 0 \lor n_{pos} \geq n_{size}}\\
      s(n_{pos}) & \owc\\
    \end{array}\right.
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charCodeAt}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charCodeAt}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto n]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_1 = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ n_{pos} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0"))) \land n_{size} = s.length\\
  \land\ n = \left\{\begin{array}{ll}
      \SF{NaN} & \ifc{n_{pos} < 0 \lor n_{pos} \geq n_{size}}\\
     native.toInt(s(n_{pos})) & \owc\quad\comment{{\inblue // java, scala}}\\
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.concat}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.concat}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s_{i} = \hf{ToString}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))
  \land n_{len} = \hf{getArgValue}(args, ``length")\\
  \land\ s = s_{this} + s_0 + s_1 + ... + s_{n_{len}-1}
  }\\
\\\\
\end{array}
\]


\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.indexOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.indexOf}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto n_{pos}]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s_{find} = \hf{ToString}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{argstart} = \left\{\begin{array}{ll}
      0 & \ifc{\hf{getArgValue}(args, ``1") = \SF{undefined}}\\
      \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1"))) & \owc\\
    \end{array}\right.\\
  \land\ n_{start} = min(max(n_{argstart}, 0) s_{this}.length)\\
  \land\ n_{pos} = native.string.indexOf(s_{this}, s_{find}, n_{start}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.lastIndexOf}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.lastIndexOf}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto n_{pos}]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s_{find} = \hf{ToString}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{argend} = \left\{\begin{array}{ll}
      \SF{Inf} & \ifc{\hf{getArgValue}(args, ``1") = \SF{undefined}}\\
      \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1"))) & \owc\\
    \end{array}\right.\\
  \land\ n_{start} = min(max(n_{argstart}, 0) s_{this}.length)\\
  \land\ n_{pos} = native.string.lastIndexOf(s_{this}, s_{find}, n_{start}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\
  
  
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.localeCompare}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.localeCompare}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto n]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s_{that} = \hf{ToString}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n = native.string.compare(s_{this}, s_{that})\quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\


  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.slice}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.slice}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ n_{argstart} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{argend} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1")))\\
  \land\ n_{strlen} = s_{this}.length\\
  \land\ n_{start} = \left\{\begin{array}{ll}
      max(n_{strlen} + n_{argstart}, 0) & \ifc{n_{argstart} < 0} \\
      min(n_{argstart}, n_{strlen}) &  \owc
    \end{array}\right.\\
  \land\ n_{end} = \left\{\begin{array}{ll}
      max(n_{strlen} + n_{argend}, 0) & \ifc{n_{argend} < 0} \\
      min(n_{argend}, n_{strlen}) &  \owc
    \end{array}\right.\\
  \land\ s = native.string.slice(s_{this}, n_{start},n_{end}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\end{array}
\]

\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.substring}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.substring}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ n_{strlen} = s_{this}.length\\
  \land\ n_{argstart} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{argend} = \left\{\begin{array}{ll}
      n_{strlen} & \ifc{\hf{getArgValue}(args, ``1") = \SF{undefined}}\\
      \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1"))) & \owc
    \end{array}\right.\\
  \land\ n_{start} = min(max(n_{argstart},0), n_{strlen})\\
  \land\ n_{end} = min(max(n_{argend},0), n_{strlen})\\
  \land\ s = native.string.slice(s_{this}, min(n_{start},n_{end}), max(n_{start},n_{end})) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLowerCase}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLowerCase}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s = native.string.toLowerCase(s_{this}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleLowerCase}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleLowerCase}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s = native.string.toLowerCase(s_{this}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\


  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toUpperCase}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toUpperCase}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s = native.string.toUpperCase(s_{this}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\


  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleUpperCase}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleUpperCase}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s = native.string.toUpperCase(s_{this}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.trim}",args)\rbr(H,A)
 = (H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{exception}\mapsto l_e]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \set{\SF{undefined}, \SF{null}}\\
  \land\ l_e = \hf{newLocation}() \land\ H_1=H[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.trim}",args)\rbr(H,A)
 = (H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto s]], A) \\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \set{\SF{undefined}, \SF{null}}
  \land s_{this} = \hf{ToString}(\hf{ToPrimitive}(v))\\
  \land\ s = native.string.trim(s_{this}) \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\
\end{array}
\]




\subsection{Boolean}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land l=\hf{NewLocation}()\\
  \land\ o=\hf{NewBoolean}(\hf{toBoolean}(\hf{toPrimitive}(v))) \land H_1=H\left[l\mapsto o\right]}\\


\end{array}
\]


\subsection{Boolean.prototype}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.toString}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@exception \mapsto l_e]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Boolean} \land
  (v \not\in \SF{Loc} \lor (v \in \SF{Loc} \land H(v)(@class) \neq ``\SF{Boolean}"))\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.toString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A)
  \land b = \left\{
    \begin{array}{ll}
      v & \ifc{v \in \SF{Boolean}}\\
      H(v)(@primitive) & \ifc{v \in \SF{Loc} \land H(v)(@class) = ``\SF{Boolean}"}
    \end{array}\right.\\
  \land\ s = \left\{
    \begin{array}{ll}
      ``\SF{true}" & \ifc{b = \SF{true}}\\
      ``\SF{false}" & \ifc{b = \SF{false}}
    \end{array}\right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.valueOf}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@exception \mapsto l_e]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Boolean} \land
  (v \not\in \SF{Loc} \lor (v \in \SF{Loc} \land H(v)(@class) \neq ``\SF{Boolean}"))\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.valueOf}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto b]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A)
  \land b = \left\{
    \begin{array}{ll}
      v & \ifc{v \in \SF{Boolean}}\\
      H(v)(@primitive) & \ifc{v \in \SF{Loc} \land H(v)(@class) = ``\SF{Boolean}"}
    \end{array}\right.
  }\\
\\\\

\end{array}
\]


\subsection{Number}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}() \land o=\hf{NewNumber}(0) \land H_1=H\left[l\mapsto o\right]
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o=\hf{NewNumber}(\hf{toNumber}(\hf{toPrimitive}(v))) \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]


\subsection{Number.prototype}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.valueOf}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@exception \mapsto l_e]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Number} \land
  (v \not\in \SF{Loc} \lor (v \in \SF{Loc} \land H(v)(@class) \neq ``\SF{Number}"))\\
  \land\ l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.valueOf}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto n]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A)
  \land n = \left\{
    \begin{array}{ll}
      v & \ifc{v \in \SF{Number}}\\
      H(v)(@primitive) & \ifc{v \in \SF{Loc} \land H(v)(@class) = ``\SF{Number}"}
    \end{array}\right.
  }\\
\\\\
\end{array}
\]


\subsection{Math}
\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.abs}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1=\SF{NaN}} \\
      \SF{Inf} & \ifc{n_1\in\set{\SF{-Inf, Inf}}} \\
      -n_1 & \ifc{v<0} \\
      n_1 & \ifc{0\leq v_1} \\
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.acos}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1 \in \set{\SF{NaN}, \SF{Inf}, \SF{-inf}, n \mid n<-1 \lor 1<n}} \\
      native.acos(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.asin}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1 \in \set{\SF{NaN}, \SF{Inf}, \SF{-inf}, n \mid n<-1 \lor 1<n}} \\
      native.asin(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.atan}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1=\SF{NaN}}\\
      \frac{\pi}{2} & \ifc{n_1=\SF{Inf}}\\
      -\frac{\pi}{2} & \ifc{n_1=\SF{-Inf}}\\
      native.atan(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.atan2}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_3]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))
  \land n_2 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``1")))\\
  n_3 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1=\SF{NaN} \lor n_2=\SF{NaN}}\\
      0 & \ifc{n_1= n \land n_2=\SF{Inf}}\\
      +0 & \ifc{n_1 > 0 \land n_1 \not\in  \set{\SF{-Inf}, \SF{Inf}} \land n_2=\SF{Inf}}\\
      \pi & \ifc{n_1 > 0 \land n_1 \not\in  \set{\SF{-Inf}, \SF{Inf}} \land n_2=\SF{-Inf}}\\
      -0 & \ifc{n_1 < 0 \land n_1 \not\in \set{\SF{-Inf}, \SF{Inf}} \land n_2=\SF{Inf}}\\
      -\pi & \ifc{n_1 < 0 \land n_1 \not\in \set{\SF{-Inf}, \SF{Inf}} \land n_2=\SF{-Inf}}\\
      \frac{\pi}{2} & \ifc{n_1=\SF{Inf} \land n_2 \not\in \set{\SF{-Inf}, \SF{Inf}}}\\
      -\frac{\pi}{2} & \ifc{n_1=\SF{-Inf} \land n_2 \not\in \set{\SF{-Inf}, \SF{Inf}}}\\
      \frac{\pi}{4} & \ifc{n_1=\SF{Inf} \land n_2=\SF{Inf}}\\
      \frac{3\pi}{4} & \ifc{n_1=\SF{Inf} \land n_2=\SF{-Inf}}\\
      -\frac{\pi}{4} & \ifc{n_1=\SF{-Inf} \land n_2=\SF{Inf}}\\
      -\frac{3\pi}{4} & \ifc{n_1=\SF{-Inf} \land v_2=\SF{-Inf}}\\
      native.atan2(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.ceil}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      n_1 & \ifc{n_1 \in \set{\SF{NaN}, \SF{Inf}, \SF{-Inf}}}\\
      native.ceil(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\


\end{array}
\]
\[
\begin{array}{l}


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.cos}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1 \in \set{\SF{NaN}, \SF{Inf}, \SF{-Inf}}}\\
      native.cos(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.exp}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      n_1 & \ifc{n_1 \in \set{\SF{NaN}, \SF{Inf}}}\\
      0 & \ifc{n_1=\SF{-Inf}}\\
      native.exp(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.floor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      n_1 & \ifc{n_1 \in \set{\SF{NaN, Inf, -Inf}}}\\
      native.floor(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.log}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1 \in \set{\SF{NaN}, \SF{-Inf}, n \mid n<0}}\\
      \SF{Inf} & \ifc{n_1=\SF{Inf}}\\
      \SF{-Inf} & \ifc{n_1=0}\\
      native.log(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.max}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n]], A)\\
\quad\wherec{
  v_{len} = \hf{getArgValue}(args, ``length")
  \land n_i = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``i")))\\
  n =
    \left\{\begin{array}{l@{\quad\quad}l}
	  \SF{-Inf} & \ifc{v_{len} = 0}\\
	  \SF{NaN} & \ifc{\exists i \in \{0,..., v_{len}\}: n_i = \SF{NaN}}\\
      n_{i_1} & \ifc{\exists i_1 \in \{0,..., v_{len}\}: \forall i_2 \in \{0,..., v_{len}\}: n_{i_1} \geq n_{i_2}}
    \end{array}\right.
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.min}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n]], A)\\
\quad\wherec{
  v_{len} = \hf{getArgValue}(args, ``length")
  \land n_i = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``i")))\\
  n =
    \left\{\begin{array}{l@{\quad\quad}l}
	  \SF{-Inf} & \ifc{v_{len} = 0}\\
	  \SF{NaN} & \ifc{\exists i \in \{0,..., v_{len}\}: n_i = \SF{NaN}}\\
      n_{i_1} & \ifc{\exists i_1 \in \{0,..., v_{len}\}: \forall i_2 \in \{0,..., v_{len}\}: n_{i_1} \leq n_{i_2}}
    \end{array}\right.
  }\\
\\\\


\end{array}
\]


\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.pow}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_3]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))
  \land n_2 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``1")))\\
  n_3 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_2 =\SF{NaN}}\\
      \SF{1}   & \ifc{n_2 =0}\\
      \SF{NaN} & \ifc{n_1=\SF{NaN} \land n_2 \neq0}\\
      \SF{Inf} & \ifc{(n_1 > 1 \lor -n_1 > 1) \land n_2 =\SF{Inf}}\\
      0        & \ifc{(n_1 > 1 \lor -n_1 > 1) \land n_2 =\SF{-Inf}}\\
      \SF{NaN} & \ifc{(n_1 == 1 \lor -n_1 == 1) \land v_{y1}\in\set{\SF{Inf, -Inf}}}\\
      0        & \ifc{(n_1 < 1 \lor -n_1 < 1) \land v_{y1}=\SF{Inf}}\\
      \SF{Inf} & \ifc{(n_1 < 1 \lor -n_1 < 1) \land v_{y1}=\SF{-Inf}}\\
      \SF{Inf} & \ifc{n_1=\SF{Inf} \land n_2>0}\\
      0        & \ifc{n_1=\SF{Inf} \land n_2<0}\\
      \SF{-Inf} & \ifc{n_1=\SF{-Inf} \land n_2 > 0 \land n_2 \neq \SF{Inf} \land n_2 \TT{\%} 2 = 1}\\
      \SF{Inf} & \ifc{n_1=\SF{-Inf} \land n_2 > 0 \land n_2 \neq \SF{Inf}  \land  n_2 \TT{\%} 2 = 0}\\
      0        & \ifc{n_1=\SF{-Inf} \land v_{y1}<0}\\
      0        & \ifc{n_1 =0 \land n_2 >0}\\
      \SF{Inf} & \ifc{n_1 =0 \land n_2 <0}\\

      \SF{NaN} & \ifc{v_{x1}<0 \land v_{x1}\neq\SF{-Inf} \land v_{y1}\neq\set{\SF{Inf, -Inf}} \land \neg isInt(v_{y1})}\\
      native.pow(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\



\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.random}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n]], A)\\
\quad\wherec{
  n = native.random() 
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.round}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
       n_1 & \ifc{n_1 \in \set{\SF{NaN, Inf, -Inf}}}\\
      native.round(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.sin}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1 \in \set{\SF{NaN, Inf, -Inf}}}\\
      native.sin(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.sqrt}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      n_1 & \ifc{n_1 \in \set{\SF{NaN, Inf}}}\\
      \SF{NaN} & \ifc{n_1<0 \lor n_1=\SF{-Inf}}\\
      native.sqrt(n_1) & \owc
    \end{array}
  \right.
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.tan}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto n_2]], A)\\
\quad\wherec{
  n_1 = \hf{toNumber}(\hf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  n_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \SF{NaN} & \ifc{n_1 \in \set{\SF{NaN}, \SF{Inf}, \SF{-Inf}}}\\
      native.tan(n_1) & \owc 
    \end{array}
  \right.
  }\\
\\\\

\end{array}
\]
\subsection{Date}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") = 0\\
  \land\ n = native.Calendar.getInstance().getTimeInMillis() \quad\comment{{\inblue // java, scala}}\\
  \land\ o = \hf{NewDateObject}(n) \land l = \hf{newLocation}() \land H_1 = H[l \mapsto o]
  }\\
  
\inred \I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") = 1 \land v = \hf{getArgValue}(args, ``0") \land v \in \SF{String}\\
  \land\ o = \hf{NewDateObject}(v) \land l = \hf{newLocation}() \land H_1 = H[l \mapsto o]
  }\\ 
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") = 1 \land v = \hf{getArgValue}(args, ``0") \land v \not\in \SF{String}\\
  \land\ n = \hf{ToNumber}(\hf{ToPrimitive}(v))
  \land o = \hf{NewDateObject}(\hf{TimeClip}(n)) \land l = \hf{newLocation}() \land H_1 = H[l \mapsto o]
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  n_{arglen} = \hf{getArgValue}(args, ``length") \land n_{arglen} > 1\\
  \land\ n_{1} = \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \land\ n_{year} = \left\{\begin{array}{ll}
    n_{1} + 1900
    & \ifc{n_1 \neq \SF{NaN} \land 0 \leq n_1 \land n_1 \leq 99}\\
    n_{1} & \owc
    \end{array}\right.\\
  \land\ n_{month} =  \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``1")))\\
  \land\ n_{date} = \left\{\begin{array}{ll}
    \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``2"))) & \ifc{n_{arglen} > 2}\\
    1 & \owc
    \end{array}\right.\\
  \land\ n_{hour} = \left\{\begin{array}{ll}
    \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``3"))) & \ifc{n_{arglen} > 3}\\
    0 & \owc
    \end{array}\right.\\
  \land\ n_{min} = \left\{\begin{array}{ll}
    \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``4"))) & \ifc{n_{arglen} > 4}\\
    0 & \owc
    \end{array}\right.\\
  \land\ n_{sec} = \left\{\begin{array}{ll}
    \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``5"))) & \ifc{n_{arglen} > 5}\\
    0 & \owc
    \end{array}\right.\\
  \land\ n_{ms} = \left\{\begin{array}{ll}
    \hf{ToNumber}(\hf{ToPrimitive}(\hf{getArgValue}(args, ``6"))) & \ifc{n_{arglen} > 6}\\
    0 & \owc
    \end{array}\right.\\
  \land\ n = \hf{MakeDate}(\hf{MakeDay}(n_{year}, n_{month}, n_{date}),
    \hf{MakeTime}(n_{hour}, n_{min}, n_{sec},n_{ms}))\\
  \land\ o = \hf{NewDateObject}(v) \land l = \hf{newLocation}() \land H_1 = H[l \mapsto o]
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.now}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto n]], A)\\
\quad\wherec{
  n = native.Calendar.getInstance().getTimeInMillis() \quad\comment{{\inblue // java, scala}}\\
  }\\
\\\\
\end{array}
\]
\subsection{Date.prototype}
\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toDateString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toTimeString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleDateString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleTimeString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.valueOf}",args)\rbr(H,A)
  = (H[\#temp \mapsto 1(\#temp)[@return \mapsto v_2]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTime}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v_2]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getFullYear}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(YEAR) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCFullYear}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(YEAR) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMonth}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(MONTH) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMonth}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(MONTH) & \owc
    \end{array}\right.
  }\\
\\\\
\end{array}
\]


\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDate}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{DAY\_OF\_MONTH}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDate}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{DAY\_OF\_MONTH}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDay}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{DAY\_OF\_WEEK}) -1 & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDay}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{DAY\_OF\_WEEK}) -1& \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getHours}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{HOURS}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCHours}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{HOURS}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMinutes}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{MINUTE}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMinutes}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{MINUTE}) & \owc
    \end{array}\right.
  }\\
\\\\

\end{array}
\]


\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMinutes}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_time).get(\emph{MINUTE}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMinutes}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{MINUTE}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getSeconds}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_time).get(\emph{SECOND}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCSeconds}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{SECOND}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMilliseconds}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_time).get(\emph{MILLISECOND}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMilliseconds}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{MILLISECOND}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTimeZoneOffset}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)\\
  v = \left\{\begin{array}{ll}
    \SF{NaN}  & \ifc{v_{time} = \SF{NaN}}\\
    native.Calendar(v_{time}).get(\emph{ZONE\_OFFSET}) & \owc
    \end{array}\right.
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setTime}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A)
  \land v = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\end{array}
\]


\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMilliseconds}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{MILLISECOND}, v_{arg}).getTimeInMillis() \\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMilliseconds}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{MILLISECOND}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setSeconds}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{SECOND}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCSeconds}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{SECOND}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMinutes}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{MINUTE}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMinutes}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{MINUTE}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setHours}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{HOURS}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCHours}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{HOURS}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\



\end{array}
\]


\[
\begin{array}{l}


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setDate}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{DAY\_OF\_MONTH}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCDate}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{DAY\_OF\_MONTH}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMonth}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{MONTH}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMonth}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{MONTH}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setFullYear}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{YEAR}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCFullYear}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto v]], A)\\
\quad\wherec{
  v_{this} = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_{time} = H(v_{this})(@primitive)
  \land v_{arg} = \hf{ToNumber}(\hf{getArgValue}(args, ``0"))\\
  \land\ v = native.Calendar(v_{time}).set(\emph{YEAR}, v_{arg}).getTimeInMillis()\\
  \land\ H_1 = H[v_{this} \mapsto H(v_{this})[\varprop \mapsto v]]
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toUTCString}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\


\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toISOString}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto s]], A)\\
\quad\wherec{
  v_1 = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v_2 = H(v_1)(@primitive)
  \land s = (native.util.Date(v_2)).toString()
  }\\
\\\\

\end{array}
\]

\subsection{RegExp}
\[
\begin{array}{l}
% 15.10.3.1 RegExp(pattern, flags)
% If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined,
% then return R unchanged.
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp", args)\rbr(H,A)
= (H_1, A)\\
\quad\ifc{
  v_{1} \in \SF{Loc} ~\land~ H(v_{1})(\varprop{class}) = ``RegExp" ~\land~ v_2 = \SF{undefined}
}\\
\quad\wherec{
  v_{1} = \hf{getArgValue}(args, ``0") ~\land~  v_{2} = \hf{getArgValue}(args, ``1") \\
  \land~ H_1 = H[\varloc{temp}\mapsto H(\varloc{temp})[\varprop{return}\mapsto v_{1}]]
}\\

% 15.10.3.1 RegExp(pattern, flags)
% Otherwise call the standard built-in RegExp constructor as if by the expression
% new RegExp(pattern, flags) and return the object constructed by that constructor.
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp", args)\rbr(H,A)
= \I_{cp}\lbr \SF{BuiltinCall}(``RegExp.constructor", args)\rbr(H,A)
\\\\

% 15.10.4.1. new RegExp(pattern, flags)
% * Copy Constructor
% If pattern is an object R whose [[Class]] internal property is "RegExp"
% and flags is undefined, then let P be the pattern used to construct R
% and let F be the flags used to construct R.
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.constructor", args)\rbr(H,A)
= (H_2, A)\\
\quad\ifc{
  v_{1} \in Loc ~\land~ H(v_{1})(\varprop{class}) = ``RegExp" ~\land~ v_{2} = \SF{undefined}
}\\
\quad\wherec{
  v_{1} = \hf{getArgValue}(args, ``0") ~\land~  v_{2} = \hf{getArgValue}(args, ``1")\\
  \land~ v_{source} = H(v_{1})(``source") \\
  \land~ b_{g} = H(v_{1})(``global")\\
  \land~ b_{i} = H(v_{1})(``ignoreCase")\\
  \land~ b_{m} = H(v_{1})(``multiline")\\
  \land~ mid = H(v_{1})(\varprop{matcher})\\
  \land~ o = \chf{NewRegExp}(v_{source}, b_{g}, b_{i}, b_{m}, mid)\\
  \land~ l=\hf{NewLocation}()\\
  \land~ H_1 = H[l\mapsto o]\\
  \land~ H_2 = H_1[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l]]
}\\

% 15.10.4.1. new RegExp(pattern, flags)
% * Copy Constructor exception case
% If pattern is an object R whose [[Class] internal property is "RegExp"
% and flags is not undefined, then throw a TypeError exception.
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.constructor", args)\rbr(H,A)
= (H_1, A)\\
\quad\ifc{
  v_{1} \in Loc ~\land~ H(v_{1})(\varprop{class}) = ``RegExp" ~\land~ v_{2} \neq \SF{undefined}
 }\\
\quad\wherec{
  v_{1} = \hf{getArgValue}(args, ``0") ~\land~  v_{2} = \hf{getArgValue}(args, ``1")\\
  \land~ H_1 = \chf{RaiseException}(H, \exc{TypeError})
}\\

% 15.10.4.1. new RegExp(pattern, flags)
% * Constructor
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.constructor", args)\rbr(H,A)
 = (H_1, A)\\
 \quad\ifc{v_{1} \not\in Loc
  ~\land~ v_{match} \in \matcher\\
}\\
\quad\wherec{
  v_{1} = \hf{getArgValue}(args, ``0") ~\land~  v_{2} = \hf{getArgValue}(args, ``1")\\
% let P be the empty String if pattern is undefined and ToString(pattern) otherwise,
  \land~ v_P = \left\{
    \begin{array}{ll}
      ``" & \ifc{v_{1} = \SF{undefined}} \\
      \chf{toString}(v_{1}) & \owc % Warning, if v_{1} is an object.
    \end{array}
  \right.\\
% and let F be the empty String if flags is undefined and ToString(flags) otherwise.
  \land~ v_F = \left\{
    \begin{array}{ll}
      ``" & \ifc{v_{2} = \SF{undefined}} \\
      \chf{toString}(v_{2}) & \owc
    \end{array}
  \right.\\
% If a SyntaxError exception is not thrown, then:
  \land~ v_{match} = {\inred\chf{RegExpParser}(v_{P}, v_{F})}\\
  \land~ o = \chf{NewRegExp}(v_{source}, b_{g}, b_{i}, b_{m}, v_{match})\\
  \land~ l=\hf{NewLocation}()\\
  \land~ H_1 = H[l\mapsto o]
}\\

% 15.10.4.1. new RegExp(pattern, flags)
% * Constructor exception case
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.constructor", args)\rbr(H,A)
= (H_1, A)\\
\quad\ifc{
   v_{1} \not\in Loc ~\land~ exc \in \SF{Exception}\\
 }\\
\quad\wherec{
  v_{1} = \hf{getArgValue}(args, ``0") ~\land~  v_{2} = \hf{getArgValue}(args, ``1")\\
% let P be the empty String if pattern is undefined and ToString(pattern) otherwise,
  \land~ v_P = \left\{
    \begin{array}{ll}
      ``" & \ifc{v_{1} = \SF{undefined}} \\
      \chf{toString}(v_{1}) & \owc % Warning, if v_{1} is an object.
    \end{array}
  \right.\\
% and let F be the empty String if flags is undefined and ToString(flags) otherwise.
  \land~ v_F = \left\{
    \begin{array}{ll}
      ``" & \ifc{v_{2} = \SF{undefined}} \\
      \chf{toString}(v_{2}) & \owc
    \end{array}
  \right.\\
% If the characters of P do not have the syntactic form Pattern, then throw a SyntaxError exception.
% If F contains any character other than "g", "i", "m", or if it contains the same character more than once,
% then throw a SyntaxError exception.
  \land~ exc = {\inred \chf{RegExpParser}(v_{P}, v_{F})} \\
  \land~ H_1 = \chf{RaiseException}(H, exc) \\
}\\

\end{array}
\]

\subsection{RegExp.prototype}
\[
\begin{array}{l}
% 15.10.6.2 RegExp.prototype.exec(string)
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.prototype.exec", args)\rbr(H,A)
= (H_3, A)\\
\quad\ifc{
  v_{exec} \in \Obj \times \SF{Int}
}\\
\quad\wherec{
   v_{1} = \hf{getArgValue}(args, ``0")\\
   \land~ v_R = \V _{cp}\lbr \TT{this}\rbr (H,A)
   ~\land~ v_S = \chf{toString}(v_1)\\
   \land~ v_{lastIndex} = H(v_R)(``lastIndex") ~\land~ i = \chf{ToInteger}(v_{lastIndex}) \\
   \land~ v_{g} = H(v_R)(``global")\\
   \land~ v_{i} = H(v_R)(``ignoreCase")\\
   \land~ v_{m} = H(v_R)(``multiline")\\
   \land~ mid = H(v_R)(\varprop{matcher})\\
   \land~ v_{exec} = {\inred \chf{exec}(mid, v_S, i, v_{g}, v_{i}, v_{m})}\\
   \land~ l=\hf{NewLocation}()\\
   \land~ H_1 = H[l\mapsto v_{exec}.1]\\
   \land~ H_2 = \left\{
     \begin{array}{ll}
       H_1[v_R\mapsto H_1(v_R)[``lastIndex"\mapsto v_{exec}.2]] & \quad\ifc{v_g = \SF{true}}\\
       H_1 & \quad\owc \\
     \end{array}
   \right.\\
   \land~ H_3 = H_2[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto l]]
}\\
% 15.10.6.2 RegExp.prototype.exec(string)
% * Case for string did not match.
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.prototype.exec", args)\rbr(H,A)
= (H_1, A)\\
\quad\ifc{
  v_{exec} = \SF{null}
}\\
\quad\wherec{
   v_{1} = \hf{getArgValue}(args, ``0")\\
   \land~ v_R = \V _{cp}\lbr \TT{this}\rbr (H,A)
   ~\land~ v_S = \chf{toString}(v_1)\\
   \land~ v_{lastIndex} = H(v_R)(``lastIndex") ~\land~ i = \chf{ToInteger}(v_{lastIndex}) \\
   \land~ v_{g} = H(v_R)(``global")\\
   \land~ v_{i} = H(v_R)(``ignoreCase")\\
   \land~ v_{m} = H(v_R)(``multiline")\\
   \land~ mid = H(v_R)(\varprop{matcher})\\
   \land~ v_{exec} = {\inred\chf{exec}(mid, v_S, i, v_{g}, v_{i}, v_{m})}\\
   \land~ H_1 = H[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto \SF{null}]]
}\\\\

% 15.10.6.3 RegExp.prototype.test(string)
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.prototype.exec", args)\rbr(H,A)
= (H_1, A)\\
\quad\wherec{
  % 1. Let match be the result of evaulating the RegExp.prototype.exec algorithm.
   v_{1} = \hf{getArgValue}(args, ``0")\\
   \land~ v_R = \V _{cp}\lbr \TT{this}\rbr (H,A)
   ~\land~ v_S = \chf{toString}(v_1)\\
   \land~ v_{lastIndex} = H(v_R)(``lastIndex") ~\land~ i = \chf{ToInteger}(v_{lastIndex}) \\
   \land~ v_{g} = H(v_R)(``global")\\
   \land~ v_{i} = H(v_R)(``ignoreCase")\\
   \land~ v_{m} = H(v_R)(``multiline")\\
   \land~ mid = H(v_R)(\varprop{matcher})\\
   \land~ v_{exec} = {\inred\chf{exec}(mid, v_S, i, v_{g}, v_{i}, v_{m})}\\
  % 2. If match is not null, return true; else return false.
   \land~ v_{return} = \left\{
     \begin{array}{ll}
       \SF{true} & \quad\ifc{v_{exec} \neq \SF{null}} \\
       \SF{false} & \quad\owc \\
     \end{array}
   \right.\\
   \land~ H_1 = H[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v_{return}]]
}\\\\

% 15.10.6.4 RegExp.prototype.toString()
\I_{cp}\lbr \SF{BuiltinCall}(``RegExp.prototype.toString", args)\rbr(H,A)
= (H_1, A)\\
\quad\wherec{
  v_R = \V _{cp}\lbr \TT{this}\rbr (H,A)\\
  \land~ v_{src} = H(v_R)(``source")\\
  \land~ v_{g} = H(v_R)(``global")\\
  \land~ v_{i} = H(v_R)(``ignoreCase")\\
  \land~ v_{m} = H(v_R)(``multiline")\\
  \land~ s_1 = \left\{
    \begin{array}{ll}
      ``g" & \quad\ifc{v_g = \SF{true}} \\
      ``" & \quad\owc
    \end{array}
  \right.\\
  \land~ s_2 = \left\{
    \begin{array}{ll}
      ``i" & \quad\ifc{v_i = \SF{true}} \\
      ``" & \quad\owc
    \end{array}
  \right.\\
  \land~ s_3 = \left\{
    \begin{array}{ll}
      ``m" & \quad\ifc{v_m = \SF{true}} \\
      ``" & \quad\owc
    \end{array}
  \right.\\
  \land~ v_{return} = ``/" + v_{src} + ``/" + s_1 + s_2 + s_3 \\
   \land~ H_1 = H[\varloc{temp}\mapsto H_1(\varloc{temp})[\varprop{return}\mapsto v_{return}]]
}

\end{array}
\]


\subsection{Error}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#ErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#ErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]

\subsection{Error.prototype}
\[
\begin{array}{l}

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.prototype.toString}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@exception \mapsto l_e]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \not\in \SF{Loc}
  \land l_e = \hf{newLocation}() \land\ H_2=H_1[l_e\mapsto\hf{NewExceptionObject}(\SF{TypeError})] 
  }\\

\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.prototype.toString}",args)\rbr(H,A)
  = (H[\#temp \mapsto H(\#temp)[@return \mapsto s_3]], A)\\
\quad\wherec{
  v = \V _{cp}\lbr \TT{this}\rbr (H,A) \land v \in \SF{Loc}\\
  s_1 = \left\{\begin{array}{ll}
    H(v)(``name") & \ifc{H(v)(``name") \neq \SF{undefined}}\\
    ``Error" & \owc \\
    \end{array}\right.\\
  s_2 = \left\{\begin{array}{ll}
    \hf{toString}(\hf{toPrimitive}(H(v)(``message"))) & \ifc{H(v)(``message") \neq \SF{undefined}}\\
    ``" & \owc \\
    \end{array}\right.\\
  s_3 = \left\{\begin{array}{ll}
    s_2 & \ifc{s_1 = ``"}\\
    s_1 & \ifc{s_2 = ``"} \\
    s_1 + ``:\ " + s_2& \owc
    \end{array}\right.
  }\\
\\

\end{array}
\]



\subsection{EvalError}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#EvalErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#EvalErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]


\subsection{RangeError}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#RangeErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#RangeErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]



\subsection{ReferenceError}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#ReferenceErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#ReferenceErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]


\subsection{SyntaxError}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#SyntaxErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#SyntaxErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]


\subsection{TypeError}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#TypeErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#TypeErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]


\subsection{URIError}
\[
\begin{array}{l}
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  \hf{getArgValue}(args, ``length") < 1 
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#URIErrorProto,\\
    \varprop{extensible}\mapsto \vtrue
    }
  \land H_1=H\left[l\mapsto o\right]\\
  }\\
  
\I _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(H,A)
  = (H_1[\#temp \mapsto H_1(\#temp)[@return \mapsto l]], A)\\
\quad\wherec{
  v = \hf{getArgValue}(args, ``0") \land \hf{getArgValue}(args, ``length") \geq 1
  \land l=\hf{NewLocation}()\\
  \land\ o = \set{
    \varprop{class}\mapsto ``Error", \quad
    \varprop{proto}\mapsto \#URIErrorProto,\\
    \varprop{extensible}\mapsto \vtrue,  \quad
    message \mapsto \hf{toString}(\hf{toPrimitive}(v)) 
    }\\
  \land H_1=H\left[l\mapsto o\right]
  }\\

\end{array}
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Abstract Semantics}
\subsection{Helper}
\[
\begin{array}{ll}

\ahf{DefineProperty} & : \abs{Heap} \times \abs{Loc} \times \abs{String} \times \abs{Loc} \rightarrow \abs{Heap} \\
& \ahf{ToPropertyDescriptor}(\hat{H}, \hat{l}_1, \hat{s}, \hat{l}_2 ) = \hat{H}_1\\
& \quad \wherec {
  \hat{H}_1 = \hat{H}[\hat{l}_1 \mapsto \hat{H}(\hat{l}_1)
    [\hat{s}\mapsto \langle \hat{v}_{val}, \hat{b}_{w}, \hat{b}_{e}, \hat{b}_{c}  \rangle]]\\
  \comment{{\inred // skip when AccessorDescriptor}}\\
  \land\ \hat{v}_{val} = \ahf{Proto}(\hat{H}, \hat{l}_2, \hat{``value"})\\
  \land\ \hat{b}_{w} = \ahf{toBoolean}(\ahf{Proto}(\hat{H}, \hat{l}_2, \hat{``writable"}))\\
  \land\ \hat{b}_{e} = \ahf{toBoolean}(\ahf{Proto}(\hat{H}, \hat{l}_2, \hat{``enumerable"}))\\    
  \land\ \hat{b}_{c} = \ahf{toBoolean}(\ahf{Proto}(\hat{H}, \hat{l}_2, \hat{``configurable"}))\\
  }\\
\\\\


\ahf{TimeClip} & : \abs{Number} \rightarrow \abs{Number} \\
& \ahf{TimeClip}(\hat{n}) = \left\{
      \begin{array}{ll}
        \top_{Number} & \ifc{\SF{UInt} \sqsubseteq \hat{n} \lor \SF{NUInt} \sqsubseteq \hat{n}}\\
        \SF{NaN} & \ifc{\SF{-inf} = \hat{n} \lor \SF{inf} = \hat{n} \lor \SF{NaN} = \hat{n}}\\
        \SF{NaN} & \ifc{\SF{NUIntSingle}(n) = \hat{n} \land abs(n) > 8.64 \times 10^{15}}\\
        \ahf{toInteger}(\hat{n}) & \ifc{\SF{NUIntSingle}(n) = \hat{n} \land abs(n) \leq 8.64 \times 10^{15}}\\
        \bot_{Number} & \ifc{\hat{n} \sqsubseteq \bot_{Number}}
      \end{array}
    \right.\\
\\
\end{array}
\]

\subsection{Global}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{isNaN}",args)\rbr((\hat{H}_1,\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}), \hat{S})\\
\quad\wherec{
  \hat{n} = \ahf{toNumber}(\ahf{toPrimitive}(\ahf{getArgValue}(``0")))\\
  \land\ \hat{b} =
    \left\{\begin{array}{l@{\quad\quad}l}
      \atrue & \ifc{\hat{\SF{NaN}} = \hat{n}} \\
      \afalse & \ifc{\hat{\SF{NaN}} \neq \hat{n} \land \hat{\SF{NaN}} \not\sqsubseteq \hat{n}} \\
      \top_{bool} & \ifc{\hat{\SF{NaN}} \neq \hat{n} \land \hat{\SF{NaN}} \sqsubseteq \hat{n}} \\
      \bot_{bool} & \owc \\
    \end{array}\right.\\
  \land\ \hat{H}_1 = \ahf{ReturnStore}(\hat{H}, Value(\hat{b}))\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{isFinite}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}), \hat{S})\\
\quad\wherec{
  \hat{n} = \ahf{toNumber}(\ahf{toPrimitive}(\ahf{getArgValue}(``0")))\\
  \land\ \hat{b} =
    \left\{\begin{array}{l@{\quad\quad}l}
      \afalse & \ifc{\hat{\SF{NaN}} = \hat{n} \lor \hat{\SF{inf}} = \hat{n} \lor \hat{\SF{-inf}} = \hat{n}}\\
      \top_{bool} & \ifc{\hat{\SF{NaN}} \sqsubseteq \hat{n}
          \lor \hat{\SF{inf}} \sqsubseteq \hat{n} \lor \hat{\SF{-inf}} \sqsubseteq \hat{n}}\\
      \atrue & \ifc{\hat{\SF{NaN}} \not\sqsubseteq \hat{n}
          \land \hat{\SF{inf}} \not\sqsubseteq \hat{n} \land \hat{\SF{-inf}} \not\sqsubseteq \hat{n}} \\
      \bot_{bool} & \owc \\
    \end{array}\right.\\
  \land\ \hat{H}_1 = \ahf{ReturnStore}(\hat{H}, Value(\hat{b}))\\
  }\\
\\\\  

\end{array}
\]


\subsection{Object}
\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.constructor}",args)_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_8, \hat{C}_8), \hat{S}_1)\\
\quad\wherec{
  \hat{v} = \ahf{getArgValue}(\hat{H}, \hat{C}, ``0")\\
  \land\ (\hat{v}_1, \hat{H}_1, \hat{C}_1 )=
    \left\{\begin{array}{l@{\quad\quad}l}
      (Value(\hat{v}.2), \hat{H}, \hat{C}) & \ifc{\hat{v}.2 \neq \{ \} }\\
      (\bot_{value}, \bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ (\hat{v}_2, \hat{H}_2, \hat{C}_2, \hat{es}_2 )=
    \left\{\begin{array}{l@{\quad\quad}l}
      (\hat{v}_4, \hat{H}_4, \hat{C}_4, \hat{es})
      & \ifc{\hat{v}.1.3 \not\sqsubseteq \bot_{bool}
         \lor \hat{v}.1.4 \not\sqsubseteq \bot_{num} \lor \hat{v}.1.5 \not\sqsubseteq \bot_{string}}\\
      (\bot_{value}, \bot_{heap}, \bot_{context},\{ \}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{v}_{prim} = Value(PValue(\bot_{undef}, \bot_{null}, \hat{v}.1.3, \hat{v}.1.4, \hat{v}.1.5))\\
  \land\ (\hat{v}_4, \hat{H}_4, \hat{C}_4, \hat{es} ) = \ahf{toObject}(\hat{H}, \hat{C}, \hat{v}_{prim}, \hat{a}_{new})\\
  \land\ (\hat{v}_3, \hat{H}_3, \hat{C}_3 )=
    \left\{\begin{array}{l@{\quad\quad}l}
      (Value(\{\hat{l}_{R}\}), \hat{H}_6, \hat{C}_5)
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{null}}\\
      (\bot_{value}, \bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_5, \hat{C}_5) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
      \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{H}_6 = \ahf{allocObject}(\hat{H}_5, \set{\avarloc{ObjProto}_R}, \hat{l}_{R})\\
  \land\ (\hat{v}_7, \hat{H}_7, \hat{C}_7 ) =
    (\hat{v}_1 \sqcup \hat{v}_2 \sqcup \hat{v}_3, \hat{H}_1 \sqcup \hat{H}_2 \sqcup \hat{H}_3,
          \hat{C}_1 \sqcup \hat{C}_2 \sqcup \hat{C}_3 )\\
  \land\ (\hat{H}_8, \hat{C}_8) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_7, \hat{v}_7), \hat{C}_7)
      & \ifc{\hat{v}_7 \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}_2, \hat{C}_2, \hat{es}_2)\\
  }\\
\\\\  

\end{array}
\]
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getPrototypeOf}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")\\
  \land\ \hat{v}_2 = \bigsqcup_{\hat{l} \in \hat{v}_1.2} \hat{H}(\hat{l})(\hat{@proto}).1.1.1\\
  \land\ \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H},\hat{v}_2), \hat{C})
      & \ifc{\hat{v}_2 \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\  



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyDescriptor}",args)_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_7, \hat{C}_7), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{s}_{prop} = \ahf{toString}(\ahf{toPrimitive}(\ahf{getArgValue}(\hat{H}, \hat{C}, ``1")))\\
  \land\ \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{ov} = \bigsqcup_{\hat{l} \in \hat{v}_1.2}\hat{H}(\hat{l})(\hat{s}_{prop}).1.1\\
  \land\ (\hat{v}_2, \hat{H}_2, \hat{C}_2) =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      (Value(PValue(\top_{undef})), \hat{H}, \hat{C}) & \ifc{\top_{undef} \sqsubseteq \hat{ov}.1.1.1}\\
      (\bot_{value}, \bot_{heap}, \bot_{context}) & \owc\\
    \end{array}
    \right.\\
  \land\ (\hat{v}_3, \hat{H}_3, \hat{C}_3) =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      (Value(\{\hat{l}_{R}\}), \hat{H}_5, \hat{C}_4)
        & \ifc{Value(Pvalue(\bot_{undef},\hat{ov}.1.1.2, \hat{ov}.1.1.3,
            \hat{ov}.1.1.4, \hat{ov}.1.1.5), \hat{v}.1.2)}\\
        & \quad\quad\not\sqsubseteq \bot_{value}\\
      (\bot_{value}, \bot_{heap}, \bot_{context}) & \owc\\
    \end{array}
    \right.\\
  \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_4, \hat{C}_4) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{o}_{new} = \ahf{NewObject}(\avarloc{ObjProto}_R)\\
  \land\ \hat{o}_1 = \left\{
    \begin{array}{ll}
      \hat{o}_{new}\left[
      \begin{array}{l}
        \hat{``value"} \mapsto \langle \hat{v}_2.1.1.1, \atrue, \atrue, \atrue \rangle\\
        \hat{``writable"} \mapsto \langle \hat{v}_2.1.1.2, \atrue, \atrue, \atrue \rangle\\
      \end{array}\right] & \ifc{\hf{\inred IsDataDescriptor}(H(v),s)}\\
      \hat{o}_{new}  & \owc \comment{{\inred // skip when AccessorDescriptor}}\\
    \end{array}\right.\\
  \land\ \hat{o}_2 = \hat{o}_1\left[
    \begin{array}{l}
      \hat{``enumerable"} \mapsto \langle \hat{v}_2.1.1.3, \atrue, \atrue, \atrue \rangle\\
      \hat{``configurable"} \mapsto \langle \hat{v}_2.1.1.4, \atrue, \atrue, \atrue \rangle\\
    \end{array}\right]\\
  \land\ \hat{H}_5 = \hat{H}_4[\hat{l}_{R} \mapsto \hat{o}_2]\\
  \land\ \hat{H}_6 = \hat{H}_2 \sqcup \hat{H}_3\\
  \land\ (\hat{H}_7, \hat{C}_7) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_6, \hat{v}_2 \sqcup \hat{v}_3), \hat{C}_2 \sqcup \hat{C}_3)
      & \ifc{\hat{v}_2 \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\  


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyNames}",args)_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C}_3), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")\\
  \land\ \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{o} = \bigsqcup_{\hat{l} \in \hat{v}_1.2 } \hat{H}(\hat{l}) \land n = 0\\
  \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{o}_1 = \ahf{NewArray}(0)\left[
    \begin{array}{l}
      \forall s \in dom(o): n^{++} \mapsto \langle s, \atrue, \atrue, \atrue \rangle
    \end{array}\right] \comment{{\inblue // ignore @default, unsound??}}\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_{R} \mapsto \hat{o}_1]\\
  \land\ (\hat{H}_3, \hat{C}_3) = 
      (\ahf{ReturnStore}(\hat{H}_2, Value(\{\hat{l}_R\})), \hat{C}_1)\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 
\quad\wherec{
  \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{o}_1 = \bigsqcup_{\hat{l} \in \hat{v}.2} \ahf{NewArrayObject}(\SF{UInt})
    [\forall \hat{s}\in dom(\hat{H}_1(\hat{l})): \SF{NumStr} \mapsto \langle \hat{s}, \atrue, \atrue, \atrue \rangle]\\
  \land\ \hat{o}_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \ahf{NewArrayObject}(\SF{UInt})[\SF{NumStr} \mapsto  \langle \SF{NumStr}, \atrue, \atrue, \atrue \rangle]
        & \ifc{ \hat{H}_1(\hat{l})(\emph{``@default\_number"}) \not\sqsubseteq \bot_{PropValue}}\\
      \bot_{Obj} & \owc\\
    \end{array}
    \right.\\
  \land\ \hat{o}_3 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \ahf{NewArrayObject}(\SF{UInt})[\SF{NumStr} \mapsto  \langle \SF{OtherStr}, \atrue, \atrue, \atrue \rangle]
        & \ifc{ \hat{H}_1(\hat{l})(\emph{``@default\_other"}) \not\sqsubseteq \bot_{PropValue}}\\
      \bot_{Obj} & \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_R \mapsto \hat{o}_1 \sqcup \hat{o}_2 \sqcup \hat{o}_3]
  \land\ (\hat{H}_3, \hat{C}_3) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R)), \hat{C})
      & \ifc{\hat{o} \not\sqsubseteq \bot_{Obj}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\

\end{array}
\]

\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.create}",args)_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S}_1)\\
\quad\wherec{
  \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{v}_1 =\ahf{getArgValue}(\hat{H}_1, \hat{C}_1, ``0")
  \land \hat{es}_1 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(\hat{H}_1, \hat{C}_1, \hat{``length"}))\\
  \land\ \hat{v}_2 =\ahf{getArgValue}(\hat{H}_1, \hat{C}_1, ``1")
  \land \hat{es}_2 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_2.1 \not\sqsubseteq \bot_{PValue} \land \hat{n}_{arglen} = \hat{2}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_R \mapsto \ahf{NewObject}(\hat{v}_1.2)]\\
  \land\ \hat{H}_3 = \left\{\begin{array}{ll}
      \bigsqcup_{\hat{l}_2 \in \hat{v}_2.2} \bigsqcup_{s \in \ahf{GetProps}(\hat{H}_2, \hat{l}_2)}
        \ahf{DefineProperty}(\hat{H}_2, \hat{l}_R, \hat{s}, \hat{l}_2)
      & \ifc{\hat{n}_{arglen} = \hat{2}}\\
      \hat{H}_2 & \owc
    \end{array}\right.\\
  \land\ (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_2, Value(\{ \hat{l}_R\}), \hat{C}_1)\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es}_1 \sqcup \hat{es}_2)\\
  }\\
\\\\ 


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperty}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C}_2), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es}_1 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{s}_{name} = \ahf{toString}(\ahf{toPrimitive}(\ahf{getArgValue}(\hat{H}, \hat{C}, ``1")))\\
  \land\ \hat{v}_2 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``2")
  \land \hat{es}_2 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_1 = \bigsqcup_{\hat{l}_1 \in \hat{v}_1.2} \bigsqcup_{\hat{l}_2 \in \hat{v}_2.2}
    \ahf{DefineProperty}(\hat{H}, \hat{l}_1, \hat{s}_{name}, \hat{l}_2)\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, Value(\hat{v}_1.2)), \hat{C})
      & \ifc{Value(\hat{v}_1.2) \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es}_1 \sqcup \hat{es}_2)\\
  }\\
\\\\ 

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperties}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C}_2), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es}_1 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{v}_2 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``1")
  \land \hat{es}_2 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_1 = \bigsqcup_{\hat{l}_1 \in \hat{v}_1.2} \bigsqcup_{\hat{l}_2 \in \hat{v}_2.2}
    \bigsqcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l}_2)}
    \ahf{DefineProperty}(\hat{H}, \hat{l}_1, \hat{s}, \hat{l}_2)\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, Value(\hat{v}_1.2)), \hat{C})
      & \ifc{Value(\hat{v}_1.2) \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es}_1 \sqcup \hat{es}_2)\\
  }\\
\\\\ 



\end{array}
\]
\[
\begin{array}{ll}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.seal}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C}_2), \hat{S}_1)\\
\quad\wherec{
 \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{v}.2}
    \bigsqcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l})} \hat{H}
    \left[\hat{l} \mapsto \hat{H}(\hat{l})
      \left[\begin{array}{l}
        s \mapsto 
        \left\langle\begin{array}{l}
          \hat{H}(\hat{l})(x).1.1.1, \hat{H}(\hat{l})(x).1.1.2,\\
          \hat{H}(\hat{l})(x).1.1.3,\afalse 
        \end{array}\right\rangle\\
      \avarprop{extensible} \mapsto \afalse
      \end{array}\right]\right]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, Value(\hat{v}.2)), \hat{C})
      & \ifc{Value(\hat{v}.2) \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.freeze}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S}_1)\\
\quad\wherec{
 \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{v}.2}
    \bigsqcup_{s \in \hat{P}_{data}} \hat{H}  
    \left[\hat{l} \mapsto \hat{H}(\hat{l})
      \left[\begin{array}{l}
        s \mapsto 
        \left\langle\begin{array}{l}
          \hat{H}(\hat{l})(x).1.1.1, \afalse,\\
          \hat{H}(\hat{l})(x).1.1.3, \afalse 
        \end{array}\right\rangle\\
      \avarprop{extensible} \mapsto \afalse
      \end{array}\right]\right]\\
  \land\ \hat{H}_2 = \bigsqcup_{\hat{l} \in \hat{v}.2}
    \bigsqcup_{s \in \hat{P}_{access}} \hat{H}  
    \left[\hat{l} \mapsto \hat{H}(\hat{l})
      \left[\begin{array}{l}
        s \mapsto 
        \left\langle\begin{array}{l}
          \hat{H}(\hat{l})(x).1.1.1, \afalse,\\
          \hat{H}(\hat{l})(x).1.1.3, \afalse 
        \end{array}\right\rangle\\
      \avarprop{extensible} \mapsto \afalse
      \end{array}\right]\right]\\
  \land\ \hat{P}_{data} =
    \{ x \mid x \in \ahf{GetProps}(\hat{H}(\hat{l})) \land \atrue \sqsubseteq {\inred \ahf{IsDataDescriptor}(x)}\}\\
  \land\ \hat{P}_{access} =
    \{ x \mid x \in \ahf{GetProps}(\hat{H}(\hat{l})) \land \afalse \sqsubseteq {\inred \ahf{IsDataDescriptor}(x)}\}\\  
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2\\
  \land\ (\hat{H}_4, \hat{C}_4) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{v}.2)), \hat{C})
      & \ifc{Value(\hat{v}.2) \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.preventExtensions}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C}_2), \hat{S}_1)\\
\quad\wherec{
 \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{v}.2} \hat{H}
    \left[\hat{l} \mapsto \hat{H}(\hat{l})
      \left[\avarprop{extensible} \mapsto \afalse\right]\right]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, Value(\hat{v}.2)), \hat{C})
      & \ifc{Value(\hat{v}.2) \not\sqsubseteq \bot_{value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 


\end{array}
\]
\[
\begin{array}{l}


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isSealed}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
 \hat{v} = \ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{b}_{f_{\hat{l}}} =\left\{\begin{array}{ll}
    \afalse
    & \ifc{ \exists x \in \ahf{GetProps}(\hat{H}(\hat{l})): \atrue \sqsubseteq \hat{H}(\hat{l})(x).1.1.3}\\
    \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ \hat{b}_{t_{\hat{l}}} =\left\{\begin{array}{ll}
    \top_{bool}
    & \ifc{\forall x \in \ahf{GetProps}(\hat{H}(\hat{l})):
      \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.3 \land \top_{bool} \sqsubseteq \hat{H}(\hat{l})(\avarprop{extensible})}\\
    \atrue
    & \ifc{\forall x \in \ahf{GetProps}(\hat{H}(\hat{l})):
      \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.3 \land \afalse \sqsubseteq \hat{H}(\hat{l})(\avarprop{extensible})}\\
    \afalse
    & \ifc{\forall x \in \ahf{GetProps}(\hat{H}(\hat{l})):
    \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.3 \land \atrue \sqsubseteq \hat{H}(\hat{l})(\avarprop{extensible})}\\
    \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ \hat{b} =  \bigsqcup_{\hat{l} \in \hat{v}.2}(\hat{b}_{f_{\hat{l}}} \sqcup \hat{b}_{t_{\hat{l}}})\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b})), \hat{C})
      & \ifc{\hat{b} \not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isFrozen}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
 \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{b}_{f_{\hat{l}}} =\left\{\begin{array}{ll}
    \afalse
    & \ifc{ \exists x \in \hat{P}_{data}: \atrue \sqsubseteq \hat{H}(\hat{l})(x).1.1.2}\\
    \afalse
    & \ifc{ \exists x \in \hat{P}_{access}: \atrue \sqsubseteq \hat{H}(\hat{l})(x).1.1.4}\\
    \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ \hat{b}_{t_{\hat{l}}} =\left\{\begin{array}{ll}
    \top_{bool}
    & \ifc{\forall x \in \hat{P}_{data}: \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.2 
      \land \forall x \in \hat{P}_{access}: \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.4 
      \land \top_{bool} \sqsubseteq \hat{H}(\hat{l})(\avarprop{extensible})}\\
    \atrue
    & \ifc{\forall x \in \hat{P}_{data}: \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.2 
      \land \forall x \in \hat{P}_{access}: \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.4 
      \land \afalse \sqsubseteq \hat{H}(\hat{l})(\avarprop{extensible})}\\
    \afalse
    & \ifc{\forall x \in \hat{P}_{data}: \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.2 
      \land \forall x \in \hat{P}_{access}: \afalse \sqsubseteq \hat{H}(\hat{l})(x).1.1.4 
      \land \atrue \sqsubseteq \hat{H}(\hat{l})(\avarprop{extensible})}\\
    \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ \hat{P}_{data} =
    \{ x \mid x \in \ahf{GetProps}(\hat{H}(\hat{l}))
    \land \atrue \sqsubseteq {\inred \ahf{IsDataDescriptor}(x)}\}\\
  \land\ \hat{P}_{access} =
    \{ x \mid x \in \ahf{GetProps}(\hat{H}(\hat{l}))
    \land \afalse \sqsubseteq {\inred \ahf{IsDataDescriptor}(x)}\}\\  
  \land\ \hat{b} =  \bigsqcup_{\hat{l} \in \hat{v}.2}(\hat{b}_{f_{\hat{l}}} \sqcup \hat{b}_{t_{\hat{l}}})\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b})), \hat{C})
      & \ifc{\hat{b} \not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.isExtensible}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{b} = \bigsqcup_{\hat{l} \in \hat{v}.2} \hat{H}(\hat{l})(\avarprop{extensible}).1.2\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b})), \hat{C})
      & \ifc{\hat{b} \not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.keys}",args)_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{v} =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")
  \land \hat{es} =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{o}_1 = \bigsqcup_{\hat{l} \in \hat{v}.2} \ahf{NewArrayObject}(\SF{UInt})
    [\forall \hat{s}\in \hat{P}_{enum}: \SF{NumStr} \mapsto \langle \hat{s}, \atrue, \atrue, \atrue \rangle]\\
  \land\ \hat{P}_{enum} = \{ s \mid s \in dom(\hat{H}_1(\hat{l})) \land \atrue \sqsubseteq \hat{H}_1(\hat{l})(s).1.1.3\}\\
  \land\ \hat{o}_2 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \ahf{NewArrayObject}(\SF{UInt})[\SF{NumStr} \mapsto  \langle \SF{NumStr}, \atrue, \atrue, \atrue \rangle]
        & \ifc{ \hat{H}_1(\hat{l})(\emph{``@default\_number"}) \not\sqsubseteq \bot_{PropValue}}\\
      \bot_{Obj} & \owc\\
    \end{array}
    \right.\\
  \land\ \hat{o}_3 = \left\{
    \begin{array}{l@{\quad\quad}l}
      \ahf{NewArrayObject}(\SF{UInt})[\SF{NumStr} \mapsto  \langle \SF{OtherStr}, \atrue, \atrue, \atrue \rangle]
        & \ifc{ \hat{H}_1(\hat{l})(\emph{``@default\_other"}) \not\sqsubseteq \bot_{PropValue}}\\
      \bot_{Obj} & \owc\\
    \end{array}
    \right.\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_R \mapsto \hat{o}_1 \sqcup \hat{o}_2 \sqcup \hat{o}_3]
  \land\ (\hat{H}_3, \hat{C}_3) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R)), \hat{C})
      & \ifc{\hat{o} \not\sqsubseteq \bot_{Obj}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\ 

\end{array}
\]


\subsection{Object.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{s} = \bigsqcup_{\hat{l}\in\hat{C}.2} \left\{\begin{array}{ll}
    \alpha(``[object"+ s +``]" ) & \ifc{\hat{H}(\hat{l})(\avarprop{class}) =\SF{NumStrSingle}(s)}\\
    \alpha(``[object"+ s +``]" ) & \ifc{\hat{H}(\hat{l})(\avarprop{class}) =\SF{OtherStrSingle}(s)}\\
    \bot_{string} & \ifc{\hat{H}(\hat{l})(\avarprop{class}) = \bot_{string}}\\
    \SF{OtherStr} & \owc
    \end{array}\right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s})), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\    
  }\\
\\\\ 



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
\\ = \aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
\\\\ 



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.ValueOf}",args)\rbr((\hat{H},\hat{C}), \hat{S})  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{C}.2)), \hat{C})
      & \ifc{Value(\hat{C}.2) \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\    
  }\\
\\\\
  
  
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.hasOwnProperty}",args)\rbr((\hat{H},\hat{C}), \hat{S})  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{s} = \ahf{toString}(\ahf{toPrimitive}(\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")))\\
  \land\ \hat{b} = \bigsqcup_{\hat{l} \in \hat{C}.2} \ahf{HasOwnProperty}(\hat{H}, \hat{l}, \hat{s})\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b})), \hat{C})
      & \ifc{\hat{b} \not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.isPrototypeOf}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v} = \ahf{getArgValue}(\hat{H}, \hat{C}, ``0")\\
  \land\ \hat{b}_1 = \left\{\begin{array}{ll}
      \afalse & \ifc{\hat{v}.1 \sqsubseteq \bot_{PValue}}\\
      \bot_{bool} & \owc
    \end{array}\right.
  \land \hat{b}_2 = \bigsqcup_{\hat{l} \in \hat{v}.2} \hat{b}_{3_{\hat{l}}} \sqcup \hat{b}_{4_{\hat{l}}}\\
  \land\ \hat{v}_{proto_{\hat{l}}} = \hat{H}(\hat{l})(\avarprop{proto}).1.2\\
  \land\ \hat{b}_{3_{\hat{l}}} = \left\{\begin{array}{ll}
      \afalse & \ifc{\top_{null} \sqsubseteq \hat{v}_{proto_{\hat{l}}}.1.2}\\
      \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ \hat{b}_{4_{\hat{l}}} = (Value(\hat{v}.2) \hat{==} Value(\hat{v}_{proto_{\hat{l}}}.2)).1.3\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b}_1 \sqcup \hat{b}_2)), \hat{C})
      & \ifc{\hat{b}_1 \sqcup \hat{b}_2 \not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\ 
\end{array}
\]

\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.propertyIsEnumerable}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{s} = \ahf{toString}(\ahf{toPrimitive}(\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")))\\
  \land\ \hat{b} = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{b}_{1_{\hat{l}}} \sqcup \hat{b}_{2_{\hat{l}}}\\
  \land\ \hat{b}_{1_{\hat{l}}} = \left\{\begin{array}{ll}
      \afalse & \ifc{\top_{undef} \sqsubseteq \hat{H}(\hat{l})(\hat{s}).1.1.1.1.1}\\
      \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ \hat{b}_{2_{\hat{l}}} = \left\{\begin{array}{ll}
      \hat{H}(\hat{l}).1.1.3 & \ifc{\hat{H}(\hat{l})(\hat{s}).1.1.1.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{bool} & \owc
    \end{array}\right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b})), \hat{C})
      & \ifc{\hat{b}\not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\ 

\end{array}
\]


\subsection{Function.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.toString}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{es}_1 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{C}.2.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{es}_2 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \}
      & \ifc{\exists \hat{l} \in \hat{C}.2.2: \hat{H}(\hat{l})(\avarprop{class})\neq \hat{``Function"}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{L}_{fun} = \{\hat{l} \mid \hat{l} \in \hat{C}.2.2 \land \hat{H}(\hat{l})(\avarprop{class}) =  \hat{``Function"}\}\\
  \land\ \hat{s} = \bigsqcup_{\hat{l} \in \hat{L}_{fun}}
    {\inred \ahf{fid2String}}(\hat{H}(\hat{l})(\hat{\avarprop{function}}))\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
      (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{s}]], \hat{C})\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es}_1 \sqcup \hat{es}_2)\\
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{v}_1 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``0")\\
  \land\ \hat{es}_1 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \} & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{es}_2 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \}
      & \ifc{\afalse \sqsubseteq \bigsqcup_{\hat{l}\in\hat{v}_1.2}:\ahf{IsCallable}(\hat{H}, \hat{l})}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land\ \hat{L}_{f} = \{ \hat{l} \mid \hat{l} \in \hat{v}_1.2 \land \atrue \sqsubseteq \ahf{IsCallable}(\hat{H}, \hat{l})\}\\
  \land\ \hat{v}_2 =\ahf{getArgValue}(\hat{H}, \hat{C}, ``1")\\
  \land\ \hat{es}_3 =
    \left\{
    \begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \}
      & \ifc{\langle\bot_{undef}, \bot_{null}, \hat{v}_2.1.3, \hat{v}_2.1.4, \hat{v}_2.1.5\rangle \not\sqsubseteq \bot_{PValue}}\\
      \{ \}& \owc\\
    \end{array}
    \right.\\
  \land
  }\\
\end{array}
\]


\subsection{Array}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})\\
  = \aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constructor}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
\\\\

      
      
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.constructor}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C}_3), \hat{S}_1)\\
\quad\wherec{
  \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
  \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
    \quad\comment{{\inblue // Recency Abstraction}}\\
  \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(\hat{H}_1, \hat{C}_1, ``length"))\\
  \land\ \hat{o}_1 = \left\{\begin{array}{ll}
      \hat{o}_{arg1_1} \sqcup \hat{o}_{arg1_2}
      & \ifc{\SF{UIntSingle}(1) = \hat{n}_{arglen}}\\
      \hat{o}_{argn}
      & \ifc{\SF{UIntSingle}(n_{arglen}) = \hat{n}_{arglen} \land n > 1}\\
      \hat{o}_{arg1_1} \sqcup \hat{o}_{arg1_2} \sqcup \hat{o}_{uint}
      & \ifc{\SF{UInt} \sqsubseteq \hat{n}_{arglen}}\\
      \bot_{Obj} & \ifc{\hat{n}_{arglen} \sqsubseteq \bot_{number}}\\
    \end{array}\right.\\
  \land\ \hat{v}_i = \hf{getArgValue}(\hat{H}_1, \hat{C}_1, ``i")\\
  \land\ \hat{v}_{0_{notNum}} =
    Value(\langle \hat{v}_0.1.1,\hat{v}_0.1.2,\hat{v}_0.1.3,\bot_{Number},\hat{v}_0.1.5 \rangle, \hat{v}_0.2)\\
  \land\ \hat{o}_{arg1_1} = \left\{\begin{array}{ll}
      \ahf{NewArrayObject}(1)[0 \mapsto \hat{v}_{0_{notNum}}] 
      & \ifc{\hat{v}_{0_{notNum}} \not\sqsubseteq \bot_{Value}}\\
      \bot_{Obj} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{arg1_2} = \left\{\begin{array}{ll}
      \ahf{NewArrayObject}(\hat{v}_0.1.4)& \ifc{\hat{v}_0.1.4 \not\sqsubseteq \bot_{Number}}\\
      \bot_{Obj} & \owc
    \end{array}\right.\\
  \land\ \hat{es} = \left\{\begin{array}{ll}
      \{\SF{RangeError}\}
      & \ifc{\SF{UIntSingle}(1) = \hat{n}_{arglen} \land \hat{v}_0.1.4 \not\sqsubseteq \SF{UInt}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{argn} = \ahf{NewArrayObject}(n_{arglen})
    [\forall i \in \{0, ..., n_{arglen}-1 \}: i \mapsto v_i]\\
  \land\ \hat{o}_{uint} =
    \ahf{NewArrayObject}(n_{arglen})[\avarprop{default\_number} \mapsto \hat{v}_{allarg}]\\
  \land\ \hat{v}_{allarg} = \hf{getArgValue}(\hat{H}_1, \hat{C}_1, \SF{UInt})\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_R \mapsto \hat{o}_1]\\
  \land\ (\hat{H}_3, \hat{C}_3) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R)), \hat{C})
      & \ifc{\hat{o}_1 \not\sqsubseteq \bot_{Obj}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\	
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.isArray}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v} = \hf{getArgValue}(\hat{H}, \hat{C}, ``0")\\
  \land\ \hat{b}_1 = \left\{\begin{array}{ll}
      \afalse & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \bot_{bool}& \owc
    \end{array}\right.\\
  \land\ \hat{b}_2 = \left\{\begin{array}{ll}
      \atrue & \ifc{\exists \hat{l} \in \hat{v}.2 : \hat{``Array"} \sqsubseteq \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5}\\
      \bot_{bool}& \owc
    \end{array}\right.\\
  \land\ \hat{b}_3 = \left\{\begin{array}{ll}
      \afalse & \ifc{\exists\hat{l} \in \hat{v}.2 : \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \not\sqsubseteq \hat{``Array"} }\\
      \bot_{bool}& \owc
    \end{array}\right.\\
  \land\ \hat{b} = \hat{b}_1 \sqcup \hat{b}_2 \sqcup \hat{b}_3\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b})), \hat{C})
      & \ifc{\hat{b} \not\sqsubseteq \bot_{Bool}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\	
\\\\


\end{array}
\]


\subsection{Array.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toString}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C_3}), \hat{S})\\
\quad\wherec{
  \quad\comment{{\inred // [[get]] join, [[call]] }}\\
  \hat{v}_{length} = \bigsqcup_{\hat{l} \in \hat{C}_1.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``length")\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \hat{s}_0 \hat{+} \hat{s}_{sep} \hat{+} ... \hat{+} \hat{s}_{sep} \hat{+} \hat{s}_{n_{len} -1}& \ifc{\hat{v}_{length}.1.4 = \SF{UIntSingle}(n_{len})}\\
      \bot_{string} & \ifc{\hat{v}_{length}.1.4 = \bot_{number}}\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}_i = \left\{\begin{array}{ll}
      \hat{``"} & \ifc{\hat{v}_i \not\sqsubseteq \bot_{Undef} \lor \hat{v}_i \not\sqsubseteq \bot_{Null}}\\
      \ahf{toString}(\ahf{toPrimitive}(Value(\langle\bot_{Undef}, \bot_{Null}, \hat{v}_{arg}.1.3, \hat{v}_{arg}.1.4, \hat{v}_{arg}.1.5\rangle, v_{arg}.2))) & \owc
    \end{array}\right.\\
  \land\ \hat{v}_i =  \bigsqcup_{\hat{l} \in \hat{C}_1.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``i")
  \land\ \hat{v}_{arg} = \hf{getArgValue}(args, ``0")\\
  \land\ \hat{s}_{sep} = \hat{``,"} \\
  \land\ (\hat{H}_1, \hat{C}_1) = 
      (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{s}]], \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toLocaleString}",args))\rbr((\hat{H},\hat{C}), \hat{S})
\\= \aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toString}",args))\rbr((\hat{H},\hat{C}), \hat{S})
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.concat}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C_3}), \hat{S})\\
\quad\wherec{
  \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
  \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
    \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{n}_{len} = \hf{getArgValue}(\hat{H}_1, \hat{C}_1, ``lenght").1.4\\
  \land\ \hat{H}_2 = \left\{\begin{array}{ll}
      \bot_{Heap} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \hat{H}_1[\hat{l}_R \mapsto \hat{o}_1] & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{arglen})}\\
      \hat{H}_1[\hat{l}_R \mapsto \hat{o}_2] & \ifc{\hat{n}_{len} \neq \SF{UIntSingle}}
    \end{array}\right.\\
  \land\ \hat{o}_{this} = \bigsqcup_{\hat{l} \in \hat{C}_1.2} \hat{H}_1(\hat{l})\\
  \land\ \hat{o}_1 = \left\{\begin{array}{ll}
      \hat{o}_3 & \ifc{\hat{o}_{this}(\hat{``length"}) = \SF{UIntSingle}(n_{len})}\\
      \hat{o}_4 & \owc
    \end{array}\right.\\
  \land\ \hat{o}_2 = \hat{o}_{this}[\avarprop{default\_number}
    \mapsto \hat{o}_{this}(\avarprop{default\_number}) \sqcup \Value(\top_{PValue}, \set{})]\\
  \land\ \hat{o}_3 = \hat{o}_{this}[\forall i \in \{0, ..., n_{arglen}-1\}: i + n_{len}
    \mapsto \hat{v}_{arg_i}, length \mapsto \alpha(n_{len} + n_{arglen})]\\
  \land\ \hat{v}_{arg_i} = \hf{getArgValue}(\hat{H}_1, \hat{C}_1, ``i")\\
  \land\ \hat{o}_4 = \hat{o}_{this}[\avarprop{default\_number}
    \mapsto \hat{o}_{this}(\avarprop{default\_number}) 
    \sqcup \bigsqcup_{\hat{i} \in \{0, ..., n_{len}\}} \hat{v}_{arg_i}]\\
  \land\ (\hat{H}_3, \hat{C}_3) = 
      (\hat{H}_2[\avarloc{PureLocal}_R \mapsto \hat{H}_2(\avarloc{PureLocal}_R)[\varprop{return} \mapsto Value(\hat{l}_R)]], \hat{C})\\
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.join}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C_3}), \hat{S})\\
\quad\wherec{
  \hat{v}_{length} = \bigsqcup_{\hat{l} \in \hat{C}_1.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``length")\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \hat{s}_0 \hat{+} \hat{s}_{sep} \hat{+} ... \hat{+} \hat{s}_{sep} \hat{+} \hat{s}_{n_{len} -1}& \ifc{\hat{v}_{length}.1.4 = \SF{UIntSingle}(n_{len})}\\
      \bot_{string} & \ifc{\hat{v}_{length}.1.4 = \bot_{number}}\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}_i = \left\{\begin{array}{ll}
      \hat{``"} & \ifc{\hat{v}_i \not\sqsubseteq \bot_{Undef} \lor \hat{v}_i \not\sqsubseteq \bot_{Null}}\\
      \ahf{toString}(\ahf{toPrimitive}(Value(\langle\bot_{Undef}, \bot_{Null}, \hat{v}_{arg}.1.3, \hat{v}_{arg}.1.4, \hat{v}_{arg}.1.5\rangle, v_{arg}.2))) & \owc
    \end{array}\right.\\
  \land\ \hat{v}_i =  \bigsqcup_{\hat{l} \in \hat{C}_1.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``i")
  \land\ \hat{v}_{arg} = \hf{getArgValue}(args, ``0")\\
  \land\ \hat{s}_{sep} = \ahf{toString}(\ahf{toPrimitive}(Value(\langle\bot_{undef}, \hat{v}_{arg}.1.2, \hat{v}_{arg}.1.3, \hat{v}_{arg}.1.4, \hat{v}_{arg}.1.5\rangle, v_{arg}.2))) \sqcup \hat{s}_{udf}\\
  \land\ \hat{s}_{udf} = \left\{\begin{array}{ll}
      \hat{``,"} & \ifc{v_1.1.1 \sqsubseteq \bot_{Undef}}\\
      \bot_{string} & \owc
    \end{array}\right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
      (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{s}]], \hat{C})\\
  }\\
\\\\

\end{array}
\]
\[
\begin{array}{ll}



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.pop}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_5, \hat{C_5}), \hat{S})\\
\quad\wherec{
  (\hat{v}_{\hat{l}}, \hat{H}_{1_{\hat{l}}}) = \left\{\begin{array}{ll}
      (Value(\top_{undef}),\hat{H}_{2_{\hat{l}}}) & \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UIntSingle}(0)}\\
      (\ahf{Proto}(\hat{H}, \hat{l}, \hat{n_{len}-1}),\hat{H}_{3_{\hat{l}}}) & \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UIntSingle}(n_{len})}\\
      (\bot_{Value}, \bot_{Heap}) & \ifc{\hat{n}_{len_{\hat{l}}} = \bot_{number}}\\
      (\hat{H}(\hat{l})(\avarprop{default\_number}), \hat{H}) & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{len_{\hat{l}}} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  \land\ \hat{H}_{2_{\hat{l}}} = \hat{H}[\hat{l} \mapsto \hat{H}(\hat{l})[\hat{``length"} \mapsto \hat{0}]]\\
  \land\ \hat{H}_{3_{\hat{l}}} = (\ahf{Delete}(\hat{H}, \hat{l}, \hat{n_{len}-1}).1)[\hat{l} \mapsto \hat{H}(\hat{l})[\hat{``length"} \mapsto \hat{n_{len}-1}]]\\
  \land\ (\hat{v}, \hat{H}_4) = \bigsqcup_{\hat{l} \in \hat{C}.2} (\hat{v}_{\hat{l}}, \hat{H}_{1_{\hat{l}}})\\
  \land\ (\hat{H}_5, \hat{C}_5) = 
      (\hat{H}_4[\avarloc{PureLocal}_R \mapsto \hat{H}_4(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.push}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C_3}), \hat{S})\\
\quad\wherec{
  \hat{n}_{len_{\hat{l}}} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  \land\ \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(args, ``length"))\\
  \land\ (\hat{H}_1, \hat{v}_1) =  \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Heap}, \bot_{value} & \ifc{\hat{n}_{arglen} = \bot_{Number}}\\
      \hat{H}_1[\hat{l} \mapsto \hat{o}_1], \hat{n}_{len_{\hat{l}}} + \hat{n}_{arglen}  & \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UIntSingle}(n_{arglen})}\\
      \hat{H}_1[\hat{l} \mapsto \hat{o}_2], \hat{n}_{len_{\hat{l}}}& \owc
    \end{array}\right.\\
  \land\ \hat{o}_1 = \hat{H}(\hat{l})[\forall i \in \{0,..., n_{arglen}-1\}: i + \hat{n}_{len} \mapsto \hf{getArgValue}(args, i), ``length" \mapsto \hat{n}_{len} + \hat{n}_{arglen}]\\
  \land\ \hat{o}_2 = \hat{H}(\hat{l})[\hat{n}_{arglen} 
    \mapsto \hf{getArgValue}(args, \hat{n}_{arglen})]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
      (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{v}_1]], \hat{C})\\
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.reverse}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      \hat{H}[\hat{l} \mapsto \hat{o}_1] & \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UIntSingle}(n_{len_{\hat{l}}})}\\
      \hat{H}[\hat{l} \mapsto \hat{o}_2] &  \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UInt}}\\
    \end{array}\right.\\
  \land\ \hat{n}_{len_{\hat{l}}} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  \land\ \hat{o}_1 = \forall i \in \{0,..., n_{mid_{\hat{l}}}-1\}: \hat{o}_{low1} \sqcup\hat{o}_{low2} \sqcup\hat{o}_{up1} \sqcup\hat{o}_{up2}\\
  \land\ n_{up} = n_{len_{\hat{l}}} - i - 1\\
  \land\ \hat{o}_{low1} = \left\{\begin{array}{ll}
      \hat{H}(\hat{l})[n_{up} \mapsto \ahf{Proto}(\hat{H}, \hat{l}, i)] & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, i)}\\
      \hat{H}(\hat{l}) & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{low2} = \left\{\begin{array}{ll}
      \hat{H}(\hat{l})- n_{up} & \ifc{\afalse \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, i)}\\
      \hat{H}(\hat{l}) & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{up1} = \left\{\begin{array}{ll}
      \hat{H}(\hat{l})[i \mapsto \ahf{Proto}(\hat{H}, \hat{l}, n_{up})] & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l},  n_{up})}\\
      \hat{H}(\hat{l}) & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{up2} = \left\{\begin{array}{ll}
      \hat{H}(\hat{l}) - i & \ifc{\afalse \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l},  n_{up})}\\
      \hat{H}(\hat{l}) & \owc
    \end{array}\right.\\
  \land\ \hat{o}_2 = \forall s \in \ahf{GetUIntProps}(\hat{H}, \hat{l}): \hat{o}_3 -s\\
  \land\ \hat{o}_3 = \hat{H}(\hat{l})
    [\avarprop{default\_number} \mapsto \hat{H}(\hat{l})(\avarprop{default\_number})
    \sqcup \bigsqcup_{s \in \ahf{GetUIntProps}(\hat{H}, \hat{l})} \hat{H}(\hat{l})(s)]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
      (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{C}.2]], \hat{C})\\
  }\\
\\\\
\end{array}
\]


\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.shift}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{v}_1) = \bigsqcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      (\hat{H}[\hat{l} \mapsto \hat{o}_1], \hat{v}_{head}) & \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UIntSingle}(n_{len_{\hat{l}}})}\\
      (\hat{H}[\hat{l} \mapsto \hat{o}_2], \hat{v}_{uint}) &  \ifc{\hat{n}_{len_{\hat{l}}} = \SF{UInt}}\\
    \end{array}\right.\\
  \land\ \hat{n}_{len_{\hat{l}}} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  \land\ \hat{o}_2 = (\forall i \in \{1, ..., n_{len_{\hat{l}}}-1\}: \hat{H}(\hat{l})[i-1 \mapsto \hat{H}(\hat{l})(i)]) - n_{len_{\hat{l}}}\\
  \land\ \hat{v}_{head} = \left\{\begin{array}{ll}
      \ahf{Proto}(\hat{H}, \hat{l}, ``0") & \ifc{n_{len_{\hat{l}}} \neq 0}\\
      Value(\top_{undef}) & \ifc{n_{len_{\hat{l}}} = 0}\\
    \end{array}\right.\\ 
  \land\ \hat{o}_2 = \bigsqcup_{i \in \ahf{GetUIntProps}(\hat{H}, \hat{l})} (\hat{H}(\hat{l})[i-1 \mapsto \hat{H}(\hat{l})(i)] - i)\\
  \land\ \hat{v}_{uint} = Value(\top_{undef}) \sqcup \ahf{Proto}(\hat{H}, \hat{l}, ``0")\\
\land\ (\hat{H}_2, \hat{C}_2) = 
      (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{v}_1]], \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.slice}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
   \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
   \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{o}_{new} = \ahf{NewArrayObject}(0)\\
  \land\ \hat{v}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  \land\ \hat{v}_{start} = \ahf{toInteger}(\hf{getArgValue}(args, ``0"))\\
  \land\ \hat{n}_{k} = \left\{\begin{array}{ll}
      max((\hat{v}_{start}+{v}_{len}), 0) \sqcup  min(\hat{v}_{start},{v}_{len}) & \ifc{ \top_{bool} = \hat{v}_{start} < 0}\\
      max((\hat{v}_{start}+{v}_{len}), 0) & \ifc{ \atrue = \hat{v}_{start} < 0}\\
      min(\hat{v}_{start},{v}_{len}) & \ifc{ \afalse = \hat{v}_{start} < 0}\\
    \end{array}\right.\\ 
  \land\ \hat{v}_{end} =  \left\{\begin{array}{ll}
      \ahf{toInteger}(\hf{getArgValue}(args, ``0")) \sqcup \hat{v}_{len} & \ifc{ \top_{undef} \sqsubseteq \hf{getArgValue}(args, ``1").1.1}\\
      \ahf{toInteger}(\hf{getArgValue}(args, ``0")) & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{final} = \left\{\begin{array}{ll}
      max((\hat{v}_{end}+{v}_{len}), 0) \sqcup  min(\hat{v}_{end},{v}_{len}) & \ifc{ \top_{bool} = \hat{v}_{end} < 0}\\
      max((\hat{v}_{end}+{v}_{len}), 0) & \ifc{ \atrue = \hat{v}_{end} < 0}\\
      min(\hat{v}_{end},{v}_{len}) & \ifc{ \afalse = \hat{v}_{end} < 0}\\
    \end{array}\right.\\
  \land\ \hat{o} = \left\{\begin{array}{ll}
      \hat{o}_{slice} & \ifc{\hat{n}_{k} = \SF{UIntSingle}(n_{k}) \land \hat{n}_{final} = \SF{UIntSingle}(n_{final})}\\
      \hat{o}_{uint} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{slice} = \bigsqcup_{i \in \{n_{k}, ..., n_{final} -1\}]}\hat{o}_{slice1} \sqcup \hat{o}_{slice2}\\
  \land\ \hat{o}_{slice1} = \left\{\begin{array}{ll}
      \hat{o}_{new}[i-n_{k} \mapsto \hat{H}(\hat{l})(i)] & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, i)}\\
      \bot_{obj} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{slice2} = \left\{\begin{array}{ll}
      \hat{o}_{new} & \ifc{\afalse \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, i)}\\
      \bot_{obj} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{uint} = \hat{o}_{new}[\avarprop{default\_number} \mapsto \hat{H}(\hat{l})(\avarprop{default\_number}) \sqcup Value(\top_{undef}) \sqcup \bigsqcup_{i \in \ahf{GetUIntProps}(\hat{H}, \hat{l})} \hat{H}(\hat{l})(i)]\\
  \land\ \hat{H}_1 = \hat{H}[\hat{l}_R \mapsto \bigsqcup_{\hat{l} in \hat{C}.2} \hat{o}]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
      (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{l}_R]], \hat{C})\\
  }\\
\\\\
\end{array}
\]

\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.splice}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
   \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
   \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{o}_{new} = \ahf{NewArrayObject}(0)\\
  \land\ \hat{v}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  \land\ \hat{n}_{argstat} = \hf{getArgValue}(args, ``0")), 0)\\
  \land\ \hat{n}_{start} = \left\{\begin{array}{ll}
      max((\hat{v}_{argstat}+{v}_{len}), 0) \sqcup  min(\hat{v}_{argstat},{v}_{len}) & \ifc{ \top_{bool} = \hat{v}_{argstat} < 0}\\
      max((\hat{v}_{argstat}+{v}_{len}), 0) & \ifc{ \atrue = \hat{v}_{argstat} < 0}\\
      min(\hat{v}_{argstat},{v}_{len}) & \ifc{ \afalse = \hat{v}_{argstat} < 0}\\
    \end{array}\right.\\ 
  \land\ \hat{v}_{count} = min(max(\ahf{toInteger}(\hf{getArgValue}(args, ``1")), 0), \hat{v}_{len} -\hat{n}_{start}) \\
  \land\ \hat{o} = \left\{\begin{array}{ll}
      \hat{o}_{splice}[length \mapsto n_{final} - n_{k}] & \ifc{\hat{n}_{start} = \SF{UIntSingle}(n_{start}) \land \hat{n}_{count} = \SF{UIntSingle}(n_{count})}\\
      \hat{o}_{uint}[length \mapsto \SF{UInt}] & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{this_{\hat{l}}} = \left\{\begin{array}{ll}
      \hat{o}_{this_{del}}[length \mapsto n_{final} - n_{k}] & \ifc{\hat{n}_{start} = \SF{UIntSingle}(n_{start}) \land \hat{n}_{count} = \SF{UIntSingle}(n_{count})}\\
      \hat{o}_{this_{uint}}[length \mapsto \SF{UInt}] & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{slice} = \bigsqcup_{i \in \{n_{k}, ..., n_{final} -1\}]}\hat{o}_{slice1} \sqcup \hat{o}_{slice2}\\
  \land\ \hat{o}_{slice1} = \left\{\begin{array}{ll}
      \hat{o}_{new}[i-n_{k} \mapsto \hat{H}(\hat{l})(i)] & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, i)}\\
      \bot_{obj} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{slice2} = \left\{\begin{array}{ll}
      \hat{o}_{new} & \ifc{\afalse \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, i)}\\
      \bot_{obj} & \owc
    \end{array}\right.\\
  \land\ \hat{o}_{uint} = \hat{o}_{new}[\avarprop{default\_number} \mapsto \hat{H}(\hat{l})(\avarprop{default\_number}) \sqcup Value(\top_{undef}) \sqcup \bigsqcup_{i \in \ahf{GetUIntProps}(\hat{H}, \hat{l})} \hat{H}(\hat{l})(i)]\\
  \land\ \hat{o}_{this_{uint}} = \hat{H}(\hat{l})[\avarprop{default\_number} \mapsto \hat{H}(\hat{l})(\avarprop{default\_number}) \sqcup Value(\top_{undef}) \sqcup \bigsqcup_{i \in \ahf{GetUIntProps}(\hat{H}, \hat{l})} \hat{H}(\hat{l})(i)]\\
  \land\ \hat{H}_1 = \hat{H}[\hat{l}_R \mapsto \hat{o}]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
      (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)[\varprop{return} \mapsto \hat{l}_R]], \hat{C})\\
  }\\
\\\\
\end{array}
\]
\subsection{String}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(\hat{H}, \hat{C}, ``length"))\\
   \land\ \hat{s}_1 = \left\{\begin{array}{ll}
       \hat{``"}
       & \ifc{\SF{UIntSingle}(0) \sqsubseteq \hat{n}_{arglen}}\\
     \bot_{string}& \owc
     \end{array}\right.\\
  \land\ \hat{s}_2 = \left\{\begin{array}{ll}
       \ahf{toString}(\ahf{toPrimitive}(\hf{getArgValue}(\hat{H}, \hat{C}, ``0")))
       & \ifc{\SF{UIntSingle}(n) \sqsubseteq \hat{n}_{arglen} \land n > 0}\\
     \bot_{string}& \owc
     \end{array}\right.\\
  \land\ \hat{s} = \hat{s}_1 \sqcup \hat{s}_2\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s})), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.constructor}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C_3}), \hat{S})\\
\quad\wherec{
   \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
   \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(\hat{H}_1, \hat{C}_1, ``length"))\\
  \land\ \hat{s}_1 = \left\{\begin{array}{ll}
       \hat{``"}
       & \ifc{\SF{UIntSingle}(0) \sqsubseteq \hat{n}_{arglen}}\\
     \bot_{string}& \owc
     \end{array}\right.\\
  \land\ \hat{s}_2 = \left\{\begin{array}{ll}
       \ahf{toString}(\ahf{toPrimitive}(\hf{getArgValue}(\hat{H}_1, \hat{C}_1, ``0")))
       & \ifc{\SF{UIntSingle}(n) \sqsubseteq \hat{n}_{arglen} \land n > 0}\\
     \bot_{string}& \owc
     \end{array}\right.\\
  \land\ \hat{s} = \hat{s}_1 \sqcup \hat{s}_2\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_R \mapsto \ahf{NewString}(\hat{s})]\\
  \land\ (\hat{H}_3, \hat{C}_3) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R)), \hat{C}_1)
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.fromCharCode}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(\hat{H}, \hat{C}, ``length"))\\
  \land\ \hat{s}_1 = \left\{\begin{array}{ll}
       \hat{``"}
       & \ifc{\SF{UIntSingle}(0) \sqsubseteq \hat{n}_{arglen}}\\
     \bot_{string}& \owc
     \end{array}\right.\\
  \land\ \hat{s}_2 = \left\{\begin{array}{ll}
       \top_{String}
       & \ifc{\top_{UIntSingle}(n) \neq \hat{n}_{arglen} \land \hat{n}_{arglen} \not\sqsubseteq \bot_{Number}}\\
       \hat{``"} \hat{+} \hat{s}_0 \hat{+} ... \hat{+} \hat{s}_{n-1}
       & \ifc{\SF{UIntSingle}(n) \sqsubseteq \hat{n}_{arglen} \land n > 0}\\
       \bot_{string} & \owc
     \end{array}\right.\\
  \land\ s_i = \ahf{toChar}(\ahf{toUInt16}(\hf{getArgValue}(\hat{H}, \hat{C}, ``i"))) 
  \land\ \hat{s} = \hat{s}_1 \sqcup \hat{s}_2\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s})), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\  



\end{array}
\]


\subsection{String.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toString}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S}_1)\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \}
      & \ifc{\exists \hat{l} \in \hat{C}.2 : \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5  \neq \hat{``string"}}\\
      \{ \}& \owc\\
    \end{array}\right.\\
  \land\ \hat{L}_{string} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5  = \hat{``string"}\}\\
  \land\ \hat{v} = \bigsqcup_{\hat{l} \in \hat{L}_{string}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, \hat{v})), \hat{C})
      & \ifc{\hat{v} \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.valueOf}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S}_1)\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{l@{\quad\quad}l}
      \{ \SF{TypeError} \}
      & \ifc{\exists \hat{l} \in \hat{C}.2 : \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5  \neq \hat{``string"}}\\
      \{ \}& \owc\\
    \end{array}\right.\\
  \land\ \hat{L}_{string} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5  = \hat{``string"}\}\\
  \land\ \hat{v} = \bigsqcup_{\hat{l} \in \hat{L}_{string}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, \hat{v})), \hat{C})
      & \ifc{\hat{v} \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  }\\
\\\\




\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charAt}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{     
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{n}_{size} = \mid \hat{s}_{this} \mid\\
  \land\ \hat{n}_{pos} = \ahf{toInteger}(\ahf{getArgValue}(\hat{H}, \hat{C}, ``0"))\\
  \land\ \hat{v}_1 =  \left\{\begin{array}{ll}
      \hat{``"} & \ifc{\atrue \sqsubseteq (\hat{n}_{pos} < \hat{0})}\\
      \bot_{Value} & \owc\\
    \end{array}\right.\\
  \land\ \hat{v}_2 =  \left\{\begin{array}{ll}
      \hat{``"}
      & \ifc{\atrue \sqsubseteq (\hat{n}_{size} < \hat{n}_{pos}) 
        \lor \atrue \sqsubseteq (\hat{n}_{size} = \hat{n}_{pos}) }\\
      \bot_{Value} & \owc\\
    \end{array}\right.\\
  \land\ \hat{v}_3 = 
  \land \hat{v} = \hat{v}_1 \sqcup \hat{v}_2 \sqcup \alpha({\inblue native.charAt}(\gamma(\hat{s}_{this}),\gamma(n_{pos})))\quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, \hat{v})), \hat{C})
      & \ifc{\hat{v} \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charCodeAt}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{     
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{n}_{size} = \mid \hat{s}_{this} \mid\\
  \land\ \hat{n}_{pos} = \ahf{toInteger}(\ahf{getArgValue}(\hat{H}, \hat{C}, ``0"))\\
  \land\ \hat{v}_1 =  \left\{\begin{array}{ll}
      \hat{\SF{NaN}} & \ifc{\atrue \sqsubseteq (\hat{n}_{pos} < \hat{0})}\\
      \bot_{Value} & \owc\\
    \end{array}\right.\\
  \land\ \hat{v}_2 =  \left\{\begin{array}{ll}
      \hat{\SF{NaN}}
      & \ifc{\atrue \sqsubseteq (\hat{n}_{size} < \hat{n}_{pos}) 
        \lor \atrue \sqsubseteq (\hat{n}_{size} = \hat{n}_{pos}) }\\
      \bot_{Value} & \owc\\
    \end{array}\right.\\
  \land \hat{v} = \hat{v}_1 \sqcup \hat{v}_2 \sqcup \alpha({\inblue native.charAt}(\gamma(\hat{s}_{this}),\gamma(n_{pos})).toInt)\quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, \hat{v})), \hat{C})
      & \ifc{\hat{v} \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\end{array}
\]
\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.concat}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{n}_{argalen} = \hf{getArgValue}(args, ``length").1.4\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string}& \ifc{\hat{n}_{arglen} = \bot_{number}}\\
      \top_{string}& \ifc{\hat{n}_{arglen} \neq \SF{UIntSingle}}\\
      \hat{s}_{this} \hat{+} \hat{s}_0 \hat{+} ... \hat{+} \hat{s}_{n-1}& \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n)}
    \end{array}\right.\\
    \land\ \hat{s}_i = \ahf{toString}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``i")))\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.indexOf}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{n} = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{n}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{s}_{search} = \ahf{toString}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\  
  \land\ \hat{n}' = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{s}_{search} = \bot_{string}}\\
      \hat{n}'' & \ifc{\hat{s}_{search} = \SF{NumStrSingle}(s_{search}) \lor \hat{s}_{search} = \SF{OtherStrSingle}(s_{search}) }\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{pos} = \ahf{toInteger}(\hf{getArgValue}(args, ``1"))\\
  \land\ \hat{n}'' = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{n}_{pos} = \bot_{number}}\\
      \hat{n}''' & \ifc{\hat{n}_{pos} = \SF{UIntSingle}(n_{pos})}\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ n_{start} = min(max(n_{pos}, 0), s_{this}.length)\\
  \land\ \hat{n}''' = \alpha({\inblue native.string.indexOf}(s_{this}, s_{search}, n_{start}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{n}))), \hat{C})
      & \ifc{\hat{n} \not\sqsubseteq \bot_{Number}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.lastIndexOf}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{n} = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{n}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{s}_{search} = \ahf{toString}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\  
  \land\ \hat{n}' = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{s}_{search} = \bot_{string}}\\
      \hat{n}'' & \ifc{\hat{s}_{search} = \SF{NumStrSingle}(s_{search}) \lor \hat{s}_{search} = \SF{OtherStrSingle}(s_{search}) }\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{pos} = \ahf{toInteger}(\hf{getArgValue}(args, ``1"))\\
  \land\ \hat{n}'' = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{n}_{pos} = \bot_{number}}\\
      \hat{n}''' & \ifc{\hat{n}_{pos} = \SF{UIntSingle}(n_{pos})}\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ n_{start} = min(max(n_{pos}, 0), s_{this}.length)\\
  \land\ \hat{n}''' = \alpha({\inblue native.string.lastIndexOf}(s_{this}, s_{search}, n_{start}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{n}))), \hat{C})
      & \ifc{\hat{n} \not\sqsubseteq \bot_{Number}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\\
  }\\
\\\\

\end{array}
\]
\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.localeCompare}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{n} = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{n}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{s}_{that} = \ahf{toString}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\  
  \land\ \hat{n}' = \left\{\begin{array}{ll}
      \bot_{number} & \ifc{\hat{s}_{that} = \bot_{string}}\\
      \hat{n}'' & \ifc{\hat{s}_{that} = \SF{NumStrSingle}(s_{that}) \lor \hat{s}_{that} = \SF{OtherStrSingle}(s_{that}) }\\
      \top_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{n}'' = \alpha({\inblue native.string.compare}(s_{this}, s_{that}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{n}))), \hat{C})
      & \ifc{\hat{n} \not\sqsubseteq \bot_{Number}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.slice}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{start} = \ahf{toInteger}(\hf{getArgValue}(args, ``0"))\\  
  \land\ \hat{s}' = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{n}_{start} = \bot_{number}}\\
      \hat{s}'' & \ifc{\hat{n}_{start} = \SF{UIntSingle}(n_{start}) \lor \hat{n}_{start} = \SF{NUIntSingle}(n_{start}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{end} = \ahf{toInteger}(\hf{getArgValue}(args, ``1"))\\  
  \land\ \hat{s}'' = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{n}_{end} = \bot_{number}}\\
      \hat{s}''' & \ifc{\hat{n}_{end} = \SF{UIntSingle}(n_{end}) \lor \hat{n}_{end} = \SF{NUIntSingle}(n_{end}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ n_{start}'= \left\{\begin{array}{ll}
      max(n_{start} + s_{this}.length, 0) & \ifc{n_{start} < 0}\\
      min(n_{start}, s_{this}.length) & \owc
    \end{array}\right.\\
  \land\ n_{end}'= \left\{\begin{array}{ll}
      max(n_{end} + s_{this}.length, 0) & \ifc{n_{end} < 0}\\
      min(n_{end}, s_{this}.length) & \owc
    \end{array}\right.\\
  \land\ \hat{s}''' = \alpha({\inblue native.string.slice}(s_{this}, s_{start}', s_{end}'))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.
  }\\
\\\\


\end{array}
\]

\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.substring}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{start} = \ahf{toInteger}(\hf{getArgValue}(args, ``0"))\\  
  \land\ \hat{s}' = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{n}_{start} = \bot_{number}}\\
      \hat{s}'' & \ifc{\hat{n}_{start} = \SF{UIntSingle}(n_{start}) \lor \hat{n}_{start} = \SF{NUIntSingle}(n_{start}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{n}_{end} = \ahf{toInteger}(\hf{getArgValue}(args, ``1"))\\  
  \land\ \hat{s}'' = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{n}_{end} = \bot_{number}}\\
      \hat{s}''' & \ifc{\hat{n}_{end} = \SF{UIntSingle}(n_{end}) \lor \hat{n}_{end} = \SF{NUIntSingle}(n_{end}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ n_{start}'= min(max(n_{start}, 0), s_{this}.length)
  \land n_{end}'= min(max(n_{end}, 0), s_{this}.length)\\
  \land\ \hat{s}''' = \alpha({\inblue native.string.slice}(s_{this}, min(n_{start}', n_{end}'), max(n_{start}', n_{end}')))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLowerCase}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}' = \alpha({\inblue native.string.toLowerCase}(s_{this}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleLowerCase}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}' = \alpha({\inblue native.string.toLowerCase}(s_{this}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\

\end{array}
\]

\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toUpperCase}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}' = \alpha({\inblue native.string.toUpperCase}(s_{this}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleUpperCase}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}' = \alpha({\inblue native.string.toUpperCase}(s_{this}))
    \quad\comment{{\inblue // java, scala}}\\  
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{String.prototype.trim}",args))\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  \hat{L}_{prim} = \{ \hat{l} \mid \hat{l} \in \hat{C}.2 \land ``\avarprop{primitive}" \dot{\in}\hat{H}(\hat{l}) \}\\
  \land\ \hat{v}_{this} = \bigsqcup_{\hat{l} \in \hat{L}_{prim}} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
    \quad\comment{{\inred // [[DefaultValue]]??}}\\
  \land\ \hat{s}_{this} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{this}))\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \bot_{string} & \ifc{\hat{s}_{this} = \bot_{string}}\\
      \hat{s}' & \ifc{\hat{s}_{this} = \SF{NumStrSingle}(s_{this}) \lor \hat{s}_{this} = \SF{OtherStrSingle}(s_{this}) }\\
      \top_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{s}' = \alpha({\inblue native.string.trim}(s_{this}))
    \quad\comment{{\inblue // java, scala}}\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\
\end{array}
\]


\subsection{Boolean}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.constructor}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C}_3), \hat{S})\\
\quad\wherec{
   \hat{b} = \ahf{toBoolean}(\hf{getArgValue}(args, ``0")\\
   \land\ \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
   \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{o}_{new} = \ahf{NewBoolean}(\hat{b})\\
  \land\ \hat{H}_2 = \hat{H}_l[\hat{l}_R \mapsto \hat{o}_{new}]\\
  \land\ (\hat{H}_3, \hat{C}_3) = (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R))), \hat{C}_1)
  }\\
\end{array}
\]


\subsection{Boolean.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.toString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{L}_{this} = \hat{C}.2\\
  \land\ \hat{es} = \left\{\begin{array}{ll}
      \{\hat{\SF{TypeError}}\} 
      & \ifc{\exists \hat{l} \in \hat{L}_{this}:
          \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 \neq \hat{``Boolean"}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{L}_{bool} = 
    \set{ l \mid l \in \hat{L}_{this} \land  \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 = \hat{``Boolean"}}\\
  \land\ \hat{b} = \bigsqcup_{\hat{l} \in \hat{L}_{bool}} \hat{H}(\hat{l})(\varprop{primitive}).1.2.1.3\\
  \land\ \hat{s} = \left\{\begin{array}{ll}
      \hat{``true"} & \ifc{\hat{b} = \atrue}\\
      \hat{``false"} & \ifc{\hat{b} = \afalse}\\
      \hat{\SF{OtherStr}} & \ifc{\hat{b} \sqsubseteq \atrue \land \hat{b} \sqsubseteq \afalse}\\
      \bot_{string} & \owc
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}))), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.valueOf}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{L}_{this} = \hat{C}.2\\
  \land\ \hat{es} = \left\{\begin{array}{ll}
      \{\hat{\SF{TypeError}}\} 
      & \ifc{\exists \hat{l} \in \hat{L}_{this}:
          \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 \neq \hat{``Boolean"}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{L}_{bool} = 
    \set{ l \mid l \in \hat{L}_{this} \land  \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 = \hat{``Boolean"}}\\
  \land\ \hat{b} = \bigsqcup_{\hat{l} \in \hat{L}_{bool}} \hat{H}(\hat{l})(\varprop{primitive}).1.2.1.3\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{b}))), \hat{C})
      & \ifc{\hat{b} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\end{array}
\]


\subsection{Number}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C}_3), \hat{S})\\
\quad\wherec{
  \land\ \hat{n}_{len} = \ahf{toUInt32}(\hf{getArgValue}(args, ``length"))\\
  \land\ \hat{v}_{arg1} = \hf{getArgValue}(args,``0")\\
  \land\ \hat{v}_1 = \left\{\begin{array}{ll}
      Value(\alpha(0)) & \ifc{\SF{UIntSigle}(0) \sqsubseteq \hat{n}_{len}}\\
      \bot_{Value} & \owc
    \end{array}\right.\\
  \land\ \hat{v}_2 = \left\{\begin{array}{ll}
      Value(\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}_{arg1})))
      & \ifc{\SF{UIntSigle}(1) \neq \hat{n}_{len} \land \hat{n}_{len} \not\sqsubseteq \bot_{Number}}\\
      \bot_{Value} & \owc
    \end{array}\right.\\
  \land\ \hat{v} = \hat{v}_1 \sqcup \hat{v}_2\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, v)), \hat{C})
      & \ifc{\hat{v} \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.constructor}",args))_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C}_3), \hat{S})\\
\quad\wherec{
  \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
  \land\ \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
    \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{n}_{len} = (\hf{getArgValue}(args, ``length").1.4\\
  \land\ \hat{v}_1 = \left\{\begin{array}{ll}
      Value(\alpha(0)) & \ifc{\SF{UIntSigle}(0) \sqsubseteq \hat{n}_{len}}\\
      \bot_{Value} & \owc
    \end{array}\right.\\
  \land\ \hat{v}_2 = \left\{\begin{array}{ll}
      \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0"))) & \ifc{\SF{UIntSigle}(1) \sqsubseteq \hat{n}_{len}}\\
      \bot_{Value} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_2 = \left\{\begin{array}{ll}
       \hat{H}_1[\hat{l}_R \mapsto \ahf{NewNumber}(\hat{v}_1 \sqcup \hat{v}_2)] & \ifc{\hat{v}_1 \sqcup \hat{v}_2 \sqsubseteq \bot_{Value}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ (\hat{H}_3, \hat{C}_3) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R)), \hat{C}_1)
      & \ifc{\hat{v}_1 \sqcup \hat{v}_2 \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\end{array}
\]


\subsection{Number.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(args, ``length")\\
  \land\ \hat{v}_{prim} = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}(\hat{l})(\avarprop{primitive}).1.2\\
  \land\ \hat{L}_{num} = 
    \set{ l \mid l \in \hat{L}_{this} \land  \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 = \hat{``Number"}}\\
  \land\ \hat{es}_1 = \left\{\begin{array}{ll}
      \{\hat{\SF{TypeError}}\} 
      & \ifc{\exists \hat{l} \in \hat{L}_{this}:
          \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 \neq \hat{``Number"}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ (\hat{v}, \hat{es}_2) = \left\{\begin{array}{ll}
      (Value(\ahf{toString}(\hat{v}_{prim}.1)), \bot_{Exception})
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(0)}\\
      (Value(\top_{String}), \hat{es}_{arg})
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n_{arglen}) \land n_{arglen} > 0}\\
      (\bot_{Value}, \bot_{Exception}) & \ifc{\hat{n}_{arglen} = \bot_{Number}}\\
      (Value(\top_{String}), \bot_{Exception}) & \owc
    \end{array}\right.\\
  \land\ \hat{es}_{arg} = \left\{\begin{array}{ll}
      \{\hat{\SF{RangeError}}\} 
      & \ifc{n_{arglen} < 1 \lor n_{arglen} > 36}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es}_1 \sqcup \hat{es}_2)\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s})), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toLocaleString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{n}_{arglen} = \ahf{toUInt32}(\hf{getArgValue}(args, ``length")\\
  \land\ \hat{v}_{prim} = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}(\hat{l})(\avarprop{primitive}).1.2
  \land \hat{v} = Value(\ahf{toString}(\hat{v}_{prim}.1))\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, v), \hat{C})
      & \ifc{\hat{v} \not\sqsubseteq \bot_{Value}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\  
  
  
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.valueOf}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{\hat{\SF{TypeError}}\} 
      & \ifc{\exists \hat{l} \in \hat{C}.2:
          \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 \neq \hat{``Number"}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{L}_{num} = 
    \set{ l \mid l \in \hat{C}.2 \land  \hat{H}(\hat{l})(\varprop{class}).1.2.1.5 = \hat{``Number"}}\\
  \land\ \hat{n} = \bigsqcup_{\hat{l} \in \hat{L}_{num}} \hat{H}(\hat{l})(\varprop{primitive}).1.2.1.4\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{ll}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{n})), \hat{C})
      & \ifc{\hat{s} \not\sqsubseteq \bot_{Number}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toFixed}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 = \hf{getArgValue}(args, ``0")\\
  \land\ \hat{es} = \left\{\begin{array}{ll}
      \{\hat{\SF{RangeError}}\} 
      & \ifc{\hat{v}_1 \hat{<} \hat{0} \lor \hat{v}_1 \hat{>} \hat{20}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\top_{String})), \hat{C})
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toExponential}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 = \hf{getArgValue}(args, ``0")\\
  \land\ \hat{es} = \left\{\begin{array}{ll}
      \{\hat{\SF{RangeError}}\} 
      & \ifc{\hat{v}_1 \hat{<} \hat{0} \lor \hat{v}_1 \hat{>} \hat{20}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\top_{String})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toPrecesion}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S}_1)\\
\quad\wherec{
  \hat{v}_1 = \hf{getArgValue}(args, ``0")\\
  \land\ \hat{es} = \left\{\begin{array}{ll}
      \{\hat{\SF{RangeError}}\} 
      & \ifc{\hat{v}_1 \hat{<} \hat{1} \lor \hat{v}_1 \hat{>} \hat{21}}\\
      \set{} & \owc
    \end{array}\right.\\
  \land\ \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\top_{String})), \hat{C})
  }\\
\end{array}
\]


\subsection{Math}

\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.abs}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args,\hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n}  & \ifc{\hat{n} \in \set{\hat{\SF{NaN}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}, \bot_{Number}}}\\
      \hat{\SF{+Inf}} & \ifc{\hat{n} \in \set{\hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \hat{\SF{Inf}}}}\\
      \alpha(abs(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.acos}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args,\hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv} = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in \set{\hat{\SF{NaN}}, \hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \\\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid n_1<-1 \lor 1<n_1}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\top_{Number}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\
      \alpha(acos(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid -1\geq \hat{n} \leq 1}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.asin}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args,\hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in \set{\hat{\SF{NaN}}, \hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \\\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n}) \mid n_1<-1 \lor 1<n_1}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\top_{Number}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\
      \alpha(asin(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n}) \mid -1\geq \hat{n} \leq 1}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.atan}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args,\hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} = \hat{\SF{NaN}}}\\
      \hat{\SF{NUInt}} & \ifc{\hat{n} = \hat{\SF{Inf}}}\\
      \hat{\SF{NUIntSingle}}(\hat{\frac{\pi}{2}}) & \ifc{\hat{n}=\hat{\SF{+Inf}}}\\
      \hat{\SF{NUIntSingle}}(\hat{-\frac{\pi}{2}}) & \ifc{\hat{n}=\hat{\SF{-Inf}}}\\
%%      \top_{Number} & \ifc{\hat{n}.1.4 \in \set{\top_{Number}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\
      \alpha(atan(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\

\end{array}
\]
\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.atan2}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}_x=\hat{\hf{getArgValue}}(args, \hat{``0"})
  \land \hat{n}_x=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v_x}))\\
  \land\ \hat{v}_y=\hat{\hf{getArgValue}}(args, \hat{``1"})
  \land \hat{n}_x=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v_y}))\\
  \land\ \hat{pv}_1   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n_y} = \bot_{Number} \lor \hat{n_x} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n_y} = \hat{\SF{NaN}} \lor \hat{n_x} = \hat{\SF{NaN}}}\\
      \top_{Number} & \ifc{\hat{n_y} = \top_{Number} \lor \hat{n_x} = \top_{Number}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_2   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{\SF{UIntSIngle}}(\hat{0}) & \ifc{\hat{n_y} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})} \\\land \hat{n_x}=\hat{\SF{+Inf}}}\\
      \hat{\SF{UInt}} & \ifc{\hat{n_y} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}} \land \hat{n_x}=\hat{\SF{-Inf}}}\\
      \hat{\SF{NUIntSIngle}}(\hat{\pi}) & \ifc{\hat{n_y} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}\leq\hat{n_1}} \\\land \hat{n_x}=\hat{\SF{-Inf}}}\\
      \hat{\SF{NUIntSIngle}}(\hat{-\pi}) & \ifc{\hat{n_y} \in \set{\hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<\hat{0}} \\\land \hat{n_x}=\hat{\SF{-Inf}}}\\
      \hat{\SF{UInt}} & \ifc{\hat{n_y} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}} \land \hat{n_x}=\hat{\SF{Inf}}}\\
%%      \top_{Number} & \ifc{\hat{n_y} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) } \land \hat{n_x}=\hat{\SF{Inf}}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_3   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{\SF{NUIntSingle}}(\frac{\hat{\pi}}{2}) & \ifc{\hat{n_y}=\hat{\SF{+Inf}} \\\land \hat{n_x} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})}}\\
      \hat{\SF{NUIntSingle}}(-\frac{\hat{\pi}}{2}) & \ifc{\hat{n_y}=\hat{\SF{-Inf}} \\\land \hat{n_x} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})}}\\
%%      \top_{Number} & \ifc{\hat{n_y}=\hat{\SF{Inf}} \\\land \hat{n_x} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})}}\\
     \hat{\SF{NUIntSingle}}(\frac{\hat{\pi}}{4}) & \ifc{\hat{n_y}=\hat{\SF{+Inf}} \land \hat{n_x}=\hat{\SF{+Inf}}}\\
     \hat{\SF{NUIntSingle}}(\frac{\hat{3\pi}}{4}) & \ifc{\hat{n_y}=\hat{\SF{+Inf}} \land \hat{n_x}=\hat{\SF{-Inf}}}\\
     \hat{\SF{NUIntSingle}}(\frac{-\hat{\pi}}{4}) & \ifc{\hat{n_y}=\hat{\SF{-Inf}} \land \hat{n_x}=\hat{\SF{+Inf}}}\\
     \hat{\SF{NUIntSingle}}(\frac{-\hat{3\pi}}{4}) & \ifc{\hat{n_y}=\hat{\SF{-Inf}} \land \hat{n_x}=\hat{\SF{-Inf}}}\\
     \hat{\SF{NUInt}} & \ifc{\hat{n_y}=\hat{\SF{Inf}} \land \hat{n_x} \in \set{\hat{\SF{+Inf}}, \hat{\SF{-Inf}}}}\\
     \hat{\SF{NUInt}} & \ifc{\hat{n_y} \in \set{\hat{\SF{+Inf}}, \hat{\SF{-Inf}}} \land \hat{n_x}=\hat{\SF{Inf}}}\\
     \hat{\SF{NUInt}} & \ifc{\hat{n_y}=\hat{\SF{Inf}} \land \hat{n_x}=\hat{\SF{Inf}}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_4   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
%%      \top_{Number} & \ifc{\hat{v_{x1}} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})} \land \hat{v_{y1}} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\
%%      \top_{Number} & \ifc{\hat{v_{x1}} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}} \land \hat{v_{y1}} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})}}\\
      \alpha(atan2(\hat{n_1}, \hat{n_2})) & \ifc{\hat{n_y} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})} \\\land \hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_2}), \hat{\SF{NUIntSingle}}(\hat{n_2})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ \hat{pv} = \hat{pv}_1 \sqcup \hat{pv}_2 \sqcup \hat{pv}_3 \sqcup \hat{pv}_4\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.ceil}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n} & \ifc{\hat{n} \in \set{\bot_{Number}, \hat{\SF{NaN}}, \hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \hat{\SF{UInt}}, \hat{\SF{UIntSingle}}(\hat{n})}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\hat{\SF{NUInt}}, \top_{Number}}}\\
      \alpha(ceil(\hat{n})) & \ifc{\hat{n} = \hat{\SF{NUIntSingle}}(\hat{n})}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.cos}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(\hat{args, ``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in\set{\hat{\SF{NaN}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \hat{\SF{Inf}}}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}, \top_{Number}}}\\
      \alpha(cos(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\


\end{array}
\]
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.exp}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(\hat{args, ``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n} & \ifc{\hat{n} \in \set{\bot_{Number}, \hat{\SF{NaN}}, \hat{\SF{+Inf}}, \hat{\SF{NUInt}}}}\\
%%      \top{Number} & \ifc{\hat{n} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \top_{Number}}}\\
      \hat{\SF{UIntSignle}}(\hat{0}) & \ifc{\hat{n}=\hat{\SF{-Inf}}}\\
      \alpha(exp(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.floor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n} & \ifc{\hat{n} \in \set{\bot_{Number}, \hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \hat{\SF{NaN}}, \hat{\SF{UInt}}, \hat{\SF{UIntSingle}}(\hat{n})}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\hat{\SF{NUInt}}, \top_{Number}}}\\
      \alpha(floor(\hat{n})) & \ifc{\hat{n} = \hat{\SF{NUIntSingle}}(\hat{n})}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.log}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in \set{\hat{\SF{NaN}}, \hat{\SF{-Inf}}, \hat{\SF{NUIntSingle}}(\hat{n}) \mid n<\hat{0}}}\\
      \hat{\SF{+Inf}} & \ifc{\hat{n} = \hat{\SF{+Inf}}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\hat{\SF{Inf}}, \hat{\SF{NUInt}}, \hat{\SF{UInt}}, \top_{Number}}}\\
      \hat{\SF{-Inf}} & \ifc{\hat{n} =\hat{\SF{UIntSingle}}(\hat{0})}\\
      \alpha(log(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n}}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\


\end{array}
\]
\[
\begin{array}{ll}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.max}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{n}_{arglen} = \hf{getArgValue}(args, \hat{``length"}).1.4\\
  \land\ \hat{n}_{arg_i} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, \hat{``i"})))\\
  \land\ \hat{n}_1 = \left\{\begin{array}{ll}
      \top_{number} & \ifc{\begin{array}{l}
          \quad \hat{\SF{NUIntSingle}} \sqsubseteq n_{arglen} \lor \hat{\SF{inf}} \sqsubseteq n_{arglen}        
          \lor \hat{\SF{-inf}} \sqsubseteq n_{arglen}\\
          \lor\ \hat{\SF{NaN}} \sqsubseteq n_{arglen} \lor \hat{\SF{UInt}} \sqsubseteq n_{arglen}
        \end{array}}\\
      \hat{n}_2 & \ifc{\hat{n}_{arglen} = \hat{\SF{UIntSingle}}}\\
      \bot_{number} &  \ifc{\hat{n}_{arglen} = \bot_{number}}\\
    \end{array}\right.\\
  \land\ \hat{n}_2 = \left\{\begin{array}{ll}
      \hat{\SF{-Inf}} & \ifc{n_{arglen} = \hat{\SF{UIntSingle}}(0)}\\
      \hat{n}_3 \sqcup \bigsqcup \hat{N}& \ifc{n_{arglen} = \hat{\SF{UIntSingle}}(n) \land n > 0}\\
    \end{array}\right.\\
  \land\ \hat{n}_3 = \left\{\begin{array}{ll}
      \hat{\SF{NaN}}
      & \ifc{n_{arglen} = \hat{\SF{UIntSingle}}(n)
        \land n > 0 \land \exists i \in \{1,..., n-1\}: \hat{\SF{NaN}} \sqsubseteq {n}_{arg_i}}\\
      \bot_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{N} = \set{{n}_{arg_i} \mid n_{arglen} = \hat{\SF{UIntSingle}}(n)
    \land i \in \{0,...,n-1\} \land \forall j \in \{0,...,n-1\}: {n}_{arg_i} \hat{\geq} {n}_{arg_j}}\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{n}_1)), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.min}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{n}_{arglen} = \hf{getArgValue}(args, \hat{``length"}).1.4\\
  \land\ \hat{n}_{arg_i} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, \hat{``i"})))\\
  \land\ \hat{n}_1 = \left\{\begin{array}{ll}
      \top_{number} & \ifc{\begin{array}{l}
          \quad \hat{\SF{NUIntSingle}} \sqsubseteq n_{arglen} \lor \hat{\SF{inf}} \sqsubseteq n_{arglen}        
          \lor \hat{\SF{-inf}} \sqsubseteq n_{arglen}\\
          \lor\ \hat{\SF{NaN}} \sqsubseteq n_{arglen} \lor \hat{\SF{UInt}} \sqsubseteq n_{arglen}
        \end{array}}\\
      \hat{n}_2 & \ifc{\hat{n}_{arglen} = \hat{\SF{UIntSingle}}}\\
      \bot_{number} &  \ifc{\hat{n}_{arglen} = \bot_{number}}\\
    \end{array}\right.\\
  \land\ \hat{n}_2 = \left\{\begin{array}{ll}
      \hat{\SF{Inf}} & \ifc{n_{arglen} = \hat{\SF{UIntSingle}}(0)}\\
      \hat{n}_3 \sqcup \bigsqcup \hat{N}& \ifc{n_{arglen} = \hat{\SF{UIntSingle}}(n) \land n > 0}\\
    \end{array}\right.\\
  \land\ \hat{n}_3 = \left\{\begin{array}{ll}
      \hat{\SF{NaN}}
      & \ifc{n_{arglen} = \hat{\SF{UIntSingle}}(n)
        \land n > 0 \land \exists i \in \{1,..., n-1\}: \hat{\SF{NaN}} \sqsubseteq {n}_{arg_i}}\\
      \bot_{number} & \owc
    \end{array}\right.\\
  \land\ \hat{N} = \set{{n}_{arg_i} \mid n_{arglen} = \hat{\SF{UIntSingle}}(n)
    \land i \in \{0,...,n-1\} \land \forall j \in \{0,...,n-1\}: {n}_{arg_i} \hat{\leq} {n}_{arg_j}}\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{n}_1)), \hat{C})
  }\\
\\\\

\end{array}
\]
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.pow}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}_x=\hat{\hf{getArgValue}}(args, \hat{``0"})
  \land \hat{n}_x=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v_x}))\\
  \land\ \hat{v}_y=\hat{\hf{getArgValue}}(args, \hat{``1"})
  \land \hat{n}_y=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v_y}))\\
  \land\ \hat{pv}_1   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n_y} = \bot_{Number} \lor \hat{n_x} = \bot_{Number}}\\
      \hat{\SF{UIntSingle}}(\hat{1}) & \ifc{\hat{n_y} = \hat{\SF{UIntSingle}}(\hat{0})}\\
      \hat{\SF{NaN}} & \ifc{\hat{n_y} = \hat{\SF{NaN}}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n_x} = \hat{\SF{NaN}} \land \hat{n_y}\neq \hat{\SF{UIntSingle}}(\hat{0})}\\
      \top_{Number} & \ifc{\hat{n_x} = \top_{Number} \lor \hat{n_y} = \top_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n_x} \in \set{\hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<0} \\\land \hat{n_y} \in \set{\hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \neg isInt(\hat{n_1})}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_2   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{\SF{UIntSingle}}(\hat{0}) & \ifc{\hat{n_x}=\hat{\SF{UIntSingle}}(\hat{0}) \\\land \hat{n_y} \in \set{\hat{\SF{+Inf}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n_1}}}\\
      \hat{\SF{+Inf}} & \ifc{\hat{n_x}=\hat{\SF{UIntSingle}}(\hat{0}) \\\land \hat{n_y} \in \set{\hat{\SF{-Inf}},  \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<\hat{0}}}\\
%%      \top_{Number} & \ifc{\hat{n_x}=\hat{\SF{UIntSingle}}(\hat{0}) \\\land \hat{n_y} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_3   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{\SF{+Inf}} & \ifc{\hat{n_x}=\hat{\SF{+Inf}} \\\land \hat{n_y} \in \set{\hat{\SF{+Inf}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n_1}}}\\
      \hat{\SF{UIntSingle}}(\hat{0}) & \ifc{\hat{n_x}=\hat{\SF{+Inf}} \land \hat{n_y} \in \set{\hat{\SF{-Inf}},  \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<\hat{0}}}\\
%%      \top_{Number} & \ifc{\hat{n_x}=\hat{\SF{+Inf}} \\\land \hat{n_y} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\\\

      \hat{\SF{-Inf}} & \ifc{\hat{n_x}=\hat{\SF{-Inf}} \\\land \hat{n_y} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n_1} \land isOdd(\hat{n_1})}}\\
      \hat{\SF{+Inf}} & \ifc{\hat{n_x}=\hat{\SF{-Inf}} \\\land \hat{n_y} \in \set{\hat{\SF{+Inf}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n_1} \land \neg isOdd(\hat{n_1})}}\\
      \hat{\SF{UIntSingle}}(\hat{0}) & \ifc{\hat{n_x}=\hat{\SF{-Inf}} \land \hat{n_y} \in \set{\hat{\SF{-Inf}},  \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<\hat{0}}}\\
%%      \top_{Number} & \ifc{\hat{n_x}=\hat{\SF{+Inf}} \land \hat{n_y} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\\\

      \hat{\SF{UIntSingle}}(\hat{0}) & \ifc{\hat{n_x}=\hat{\SF{Inf}} \land \hat{n_y} \in \set{\hat{\SF{-Inf}},  \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<\hat{0}}}\\
      \hat{\SF{+Inf}} & \ifc{\hat{n_x}=\hat{\SF{Inf}} \\\land \hat{n_y} \in \set{\hat{\SF{+Inf}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n_1} \land \neg isOdd(\hat{n_1})}}\\
%%      \top_{Number} & \ifc{\hat{n_x}=\hat{\SF{Inf}} \\\land \hat{n_y} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}, \hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{0}<\hat{n_1} \land isOdd(\hat{n_1})}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_4   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{\SF{+Inf}} & \ifc{\hat{v_{xa}}.1.4 \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<-1 \lor 1<\hat{n_1}} \\\land \hat{n_y} = \hat{\SF{+Inf}}}\\
      \hat{\SF{UIntSingle}}(\hat{0}) & \ifc{\hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid -1<\hat{n_1}<1} \\\land \hat{n_y} = \hat{\SF{+Inf}}}\\
      \hat{\SF{UIntSingle}}(\hat{0}) & \ifc{\hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1}<-1 \lor 1<\hat{n_1}} \\\land \hat{n_y} = \hat{\SF{-Inf}}}\\
      \hat{\SF{+Inf}} & \ifc{\hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid -1<\hat{n_1}<1} \\\land \hat{n_y} = \hat{\SF{-Inf}}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n_x}=\hat{\SF{UIntSingle}}(\hat{1}) \land \hat{n_y} \in \set{\hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}}}\\
%%      \top_{Number} & \ifc{\hat{n_x} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}} \land \hat{n_y} \in \set{\hat{\SF{Inf}},  \hat{\SF{+Inf}}, \hat{\SF{-Inf}}}}\\
%%      \top_{Number} & \ifc{\hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1}) \mid \hat{n_1} \neq 1} \land \hat{n_y}=\hat{\SF{Inf}}}\\
    \end{array}
  \right.\\
  \land\ \hat{pv}_5   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
%%      \top_{Number} & \ifc{\hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})} \land \hat{n_y} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}}}\\
%%      \top_{Number} & \ifc{\hat{n_x} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}} \land \hat{n_y} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})}}\\
      \alpha(pow(\hat{n_1}, \hat{n_2})) & \ifc{\hat{n_x} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n_1})} \\\land \hat{n_y} \in \set{\hat{\SF{UIntSingle}}(\hat{n_2}), \hat{\SF{NUIntSingle}}(\hat{n_2})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ \hat{pv} = \hat{pv}_1 \sqcup \hat{pv}_2 \sqcup \hat{pv}_3 \sqcup \hat{pv}_4 \sqcup \hat{pv}_5\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\


\end{array}
\]
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.random}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\top_{Number})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.round}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n} & \ifc{\hat{n} \in \set{\hat{\SF{NaN}}, \hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}, \bot_{Number}}}\\
      \alpha(round(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n_1}), \hat{\SF{NUIntSingle}}(\hat{n})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.sin}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \bot_{Number} & \ifc{\hat{n} = \bot_{Number}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in \set{\hat{\SF{NaN}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}, \hat{\SF{Inf}}}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\hat{\SF{UInt}}, \hat{\SF{NUInt}}, \top_{Number}}}\\
      \alpha(sin(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.sqrt}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n} & \ifc{\hat{n} \in \set{\bot_{Number}, \hat{\SF{NaN}}, \hat{\SF{+Inf}}}}\\
%%      \top_{Number} & \ifc{\hat{n} \in \set{\hat{\SF{Inf}}, \hat{\SF{UInt}}, \hat{\SF{NUInt}}, \top_{Number}}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in \set{\hat{\SF{-Inf}}, \hat{\SF{NUIntSingle}}(\hat{n}) \mid \hat{n}<0}}\\
      \alpha(sqrt(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n}) \mid 0\leq\hat{n}}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\



\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Math.tan}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{v}=\hat{\hf{getArgValue}}(args, \hat{``0"}) \land \hat{n}=\ahf{toNumber}(\ahf{toPrimitive}(\hat{v}))\\
  \land\ \hat{pv}   = 
  \left\{
    \begin{array}{l@{\quad\quad\quad}l}
      \hat{n} & \ifc{\hat{n} \in \set{\bot_{Number}, \hat{\SF{NaN}}}}\\
      \hat{\SF{NaN}} & \ifc{\hat{n} \in \set{\hat{\SF{Inf}}, \hat{\SF{+Inf}}, \hat{\SF{-Inf}}}}\\
      \alpha(sqrt(\hat{n})) & \ifc{\hat{n} \in \set{\hat{\SF{UIntSingle}}(\hat{n}), \hat{\SF{NUIntSingle}}(\hat{n})}}\\
      \top_{Number} & \owc\\
    \end{array}
  \right.\\
  \land\ (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}, Value(\hat{pv})), \hat{C})
  }\\
\\\\


\end{array}
\]

\subsection{Date}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\end{array}
\]

\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args_{})_{\hat{a}_{new}}\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_3, \hat{C_3}), \hat{S})\\
\quad\wherec{
  \inblue\hat{l}_{R} = (\hat{a}_{new}, Recent)
  \land \inblue (\hat{H}_1, \hat{C}_1) = \ahf{Oldify}(\hat{H}, \hat{C}, \hat{a}_{new})
     \quad\comment{{\inblue // Recency Abstraction}}\\
  \land\ \hat{n}_{arglen} = \ahf{toUInt32}(\ahf{getArgValue}(\hat{H}_1, \hat{C}_1, ``length"))\\
  \land\ \hat{pv}_1 = \ahf{toPrimitive}(\ahf{getArgValue}(\hat{H}_1, \hat{C}_1, ``0"))\\
  \land\ \hat{n}_{prim_1} = \left\{\begin{array}{ll}
      \hat{n}_{prim_3} \sqcup \hat{n}_{prim_4}& \ifc{\SF{UIntSingle}(1) \sqsubseteq \hat{n}_{arglen}}\\
      \bot_{Number} & \owc\
    \end{array}\right.\\
  \land\ \hat{n}_{prim_2} = \left\{\begin{array}{ll}
      \top_{Number} & \ifc{\SF{UIntSingle}(n) \sqsubseteq \hat{n}_{arglen} \land n \neq 1}\\
      \bot_{Number} & \owc\
    \end{array}\right.\\
  \land\ \hat{n}_{prim_3} = \left\{\begin{array}{ll}
      \top_{Number} & \ifc{\hat{pv}_1.5 \not\sqsubseteq \bot_{String}}
        \quad\comment{{\inblue // parse}}\\
      \bot_{Number} & \owc\
    \end{array}\right.\\
  \land\ \hat{pv}_{nonstr} = PValue(\hat{v}_1.1,\hat{v}_1.2,\hat{v}_1.3,\hat{v}_1.4,\bot_{String})\\
  \land\ \hat{n}_{prim_4} = \left\{\begin{array}{ll}
      \ahf{toNumber}(\hat{v}_{nonstr}) & \ifc{\hat{pv}_{nonstr} \not\sqsubseteq \bot_{PValue}}\\
      \bot_{Number} & \owc\
    \end{array}\right.\\
  \land\ \hat{n}_{prim} = \hat{n}_{prim_1} \sqcup \hat{n}_{prim_2}\\
  \land\ \hat{H}_2 = \hat{H}_1[\hat{l}_R \mapsto \ahf{NewDate}(\hat{n}_{prim})]\\
  \land\ (\hat{H}_3, \hat{C}_3) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_2, Value(\hat{l}_R)), \hat{C}_1)
      & \ifc{\hat{n}_{prim} \not\sqsubseteq \bot_{Number}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.parse}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{Number}), \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.now}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{Number}), \hat{C})\\
  }\\
\\\\




\end{array}
\]

\subsection{Date.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toDateString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toTimeString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleDateString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleTimeString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.valueOf}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}(\hat{l})(\avarprop{primitive})\\
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTime}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}(\hat{l})(\avarprop{primitive})\\
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getFullYear}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{ 
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCFullYear}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{YEAR})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\
\end{array}
\]


\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMonth}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMonth}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{MONTH})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDate}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDate}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{DAY\_OF\_MONTH})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDay}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDay}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{DAY\_OF\_WEEK})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\end{array}
\]
\[
\begin{array}{l}


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getHours}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCHours}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{HOURS})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMinutes}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMinutes}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{MINUTE})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getSeconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCSeconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{SECOND})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\


\end{array}
\]
\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMilliseconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMilliseconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \hat{H}(\hat{l})(\avarprop{primitive}).1.4\\
  \hat{v} = \bigsqcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{time} \sqsubseteq  \bot_{number}}\\
      \hat{v}_{get} &
      \ifc{\hat{n}_{time} = \SF{UIntSingle}(n_{time}) \lor\hat{n}_{time} = \SF{NUIntSingle}(n_{time}) }\\
      Value(\top_{Number}) & \owc
    \end{array}\right.\\
  \hat{v}_{get} = \alpha({\inblue native.Calendar(n_{time}).get(\emph{MILLISECOND})})
    \quad\comment{{\inblue // java, scala}}\\  
  (\hat{H}_1, \hat{C}_1) = 
    (\hat{H}[\avarloc{PureLocal}_R \mapsto \hat{H}(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{v}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTimezoneOffset}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H}_1, Value(\top_{Number})), \hat{C})
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setTime}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{time} = \ahf{TimeClip}(\ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0"))))\\
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMilliseconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMilliseconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{MILLISECOND}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\
\end{array}
\]



\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setSeconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCSeconds}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{SECOND}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMinutes}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMinutes}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{MINUTE}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setHours}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\

\end{array}
\]

\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCHours}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{HOURS}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setDate}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCDate}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{DAY\_OF\_MONTH}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMonth}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMonth}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{MONTH}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\
\end{array}
\]
\[
\begin{array}{l}

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setFullYear}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \top_{Number}]]\\
  \land\ (\hat{H}_2, \hat{C}_2) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}_1, \top_{Number}), \hat{C})
      & \ifc{\hat{H}_1 \not\sqsubseteq \bot_{Heap}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCFullYear}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_2, \hat{C_2}), \hat{S})\\
\quad\wherec{
  \hat{n}_{1} = \ahf{toNumber}(\ahf{toPrimitive}(\hf{getArgValue}(args, ``0")))\\
  \hat{n}_{time} = \left\{\begin{array}{ll}
      \bot_{Value} & \ifc{\hat{n}_{1} \sqsubseteq  \bot_{number}}\\
      \ahf{TimeClip}(\hat{n}_{native})
      & \ifc{\hat{n}_{1} = \SF{UIntSingle}(n_{1}) \lor \hat{n}_{1} = \SF{NUIntSingle}(n_{1}) }\\
      \top_{Number} & \owc
    \end{array}\right.\\
  \hat{n}_{naitve} = \alpha({\inblue native.Calendar(n_{time}).set(\emph{YEAR}, n_{1}).getTimeInMills()})
    \quad\comment{{\inblue // java, scala}}\\  
  \hat{H}_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \hat{H}[\hat{l}
    \mapsto \hat{H}(\hat{l})[\avarprop{primitive} \mapsto \hat{n}_{time}]]\\
  (\hat{H}_2, \hat{C}_2) = 
    (\hat{H}_1[\avarloc{PureLocal}_R \mapsto \hat{H}_1(\avarloc{PureLocal}_R)
      [\varprop{return} \mapsto \hat{n}_{time}]], \hat{C})\\
  }\\
\\\\

\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toUTCString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\


\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toISOString}",args_{})\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C_1}), \hat{S})\\
\quad\wherec{
  (\hat{H}_1, \hat{C}_1) = (\ahf{ReturnStore}(\hat{H},\top_{String}), \hat{C})\\
  }\\
\\\\
\end{array}
\]



\subsection{Error}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}C_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{Err}_O\\
  \land\ \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\
\end{array}
\]

\subsection{Error.prototype}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{Error.prototype.toString}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_1, \hat{C}_1), \hat{S})\\
\quad\wherec{
  \hat{L}_{this} = \hat{C}.2
  \land \hat{v}_{name} = \bigsqcup_{l \in {L}_{this}} \ahf{Proto}(\hat{H}, \hat{l}, \hat{``name"})
  \land \hat{v}_{msg} = \bigsqcup_{l \in {L}_{this}}  \ahf{Proto}(\hat{H}, \hat{l}, \hat{``message"})\\
  \land\ \hat{s}_1 = \left\{\begin{array}{ll}
      \hat{``Error"} & \ifc{v_{name}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{string} & \owc\\
    \end{array}\right.\\
  \land\ \hat{s}_2 = \ahf{toString}(\abs{PValue}(\bot_{undef},\hat{v}_{name}.1.2,
    \hat{v}_{name}.1.3,\hat{v}_{name}.1.4,\hat{v}_{name}.1.5))\\
  \land\ \hat{s}_{name} = \hat{s}_1 \sqcup \hat{s}_2\\
  \land\ \hat{s}_3 = \left\{\begin{array}{ll}
      \hat{``"} & \ifc{v_{msg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{string} & \owc\\
    \end{array}\right.\\
  \land\ \hat{s}_4 = \ahf{toString}(\abs{PValue}(\bot_{undef},\hat{v}_{msg}.1.2,
    \hat{v}_{msg}.1.3,\hat{v}_{msg}.1.4,\hat{v}_{msg}.1.5))\\
  \land\ \hat{s}_{msg} = \hat{s}_3 \sqcup \hat{s}_4\\
  \land\ \hat{s}_5 = \left\{\begin{array}{ll}
      \hat{s}_{msg} & \ifc{\hat{``"} \sqsubseteq \hat{s}_{name}}\\
      \bot_{string} & \owc\\
    \end{array}\right.
  \land \hat{s}_6 = \left\{\begin{array}{ll}
      \hat{s}_{name} & \ifc{\hat{``"} \sqsubseteq \hat{s}_{msg}}\\
      \bot_{string} & \owc\\
    \end{array}\right.
  \land\ \hat{s}_7 = \hat{s}_{name} + \hat{``:\ "} + \hat{s}_{msg}\\
  \land\ \hat{s}_{ret} = \hat{s}_5 \sqcup \hat{s}_6 \sqcup \hat{s}_7\\
  \land\ (\hat{H}_1, \hat{C}_1) = 
    \left\{\begin{array}{l@{\quad\quad}l}
      (\ahf{ReturnStore}(\hat{H}, Value(\hat{s}_{ret})), \hat{C})
      & \ifc{\hat{s}_{ret} \not\sqsubseteq \bot_{String}}\\
      (\bot_{heap}, \bot_{context}) & \owc \\
    \end{array}\right.\\
  }\\
\\

\end{array}
\]


\subsection{EvalError}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{EvalError.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land\ \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{EvalErr}_O\\
  \land \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\

\end{array}
\]



\subsection{RangeError}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{RangeError.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land\ \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{RangeErr}_O\\
  \land \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\

\end{array}
\]


\subsection{ReferenceError}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{ReferenceError.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{RefErr}_O\\
  \land\ \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\
\end{array}
\]


\subsection{SyntaxError}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{SyntaxError.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land\ \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{SyntaxErr}_O\\
  \land \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\

\end{array}
\]


\subsection{TypeError}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{TypeError.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{TypeErr}_O\\
  \land\ \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\

\end{array}
\]


\subsection{URIError}
\[
\begin{array}{l}
\aI _{cp}\lbr \SF{BuiltintCall}(``\SF{URIError.constructor}",args)\rbr((\hat{H},\hat{C}), \hat{S})
  = ((\hat{H}_4, \hat{C}_4), \hat{S})\\
\quad\wherec{
  \hat{v}_{arg} = \hf{getArgValue}(args, ``0")
  \land \hat{s}= \ahf{toString}(\ahf{toPrimitive}(\hat{v}_{arg}))
  \land \hat{l}_e = \avarloc{URIErr}_O\\
  \land\ \hat{H}_1 = \left\{\begin{array}{ll}
      \hat{H}[\hat{l}_e \mapsto \hat{H}(\hat{l}_e)[message \mapsto \hat{s}]]
      & \ifc{\hat{v}_{arg}.1.1 \sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.
  \land \hat{H}_2 = \left\{\begin{array}{ll}
      \hat{H}
      & \ifc{\hat{v}_{arg}.1.1 \not\sqsubseteq \bot_{undef}}\\
      \bot_{Heap} & \owc
    \end{array}\right.\\
  \land\ \hat{H}_3 = \hat{H}_1 \sqcup \hat{H}_2
  \land (\hat{H}_4, \hat{C}_4) = (\ahf{ReturnStore}(\hat{H}_3, Value(\hat{l}_e)), \hat{C})\\
  }\\

\end{array}
\]

\section{Access Analysis}
\subsection{Global}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Global.parseInt}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
  
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Global.endcodeURIComponent}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{es} = \{ \SF{URIError} \}\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{URIError.isNaN}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{URIError.isFinite}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Global.parseInt}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, "0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, "1")\\
  LP_3 = getArgValue_{\it use}(\hat{H}, \hat{C}, "length")\\
  }\\
\\
  
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Global.endcodeURIComponent}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{es} = \{ \SF{URIError} \}\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{URIError.isNaN}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, "0")\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{URIError.isFinite}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, "0")\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]


\subsection{Object}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  (LP_1, \hat{es}) = \left\{\begin{array}{ll}
      (\ahf{toObject}_{\it def}(\hat{H},\hat{C}, \hat{v}_{new}, \hat{a}_1), \hat{es}_1')
      & \ifc{\hat{v}.1.3 \not\sqsubseteq \bot_{Bool} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{Number} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{String}}\\
      (\set{}, \set{}) & \owc
    \end{array}\right.\\
  \hat{v}_{new} = Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}.1.3, \hat{v}.1.4, \hat{v}.1.5), \hat{v}.2)\\
  \hat{es}' = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \left\{\begin{array}{ll}
      LP_2' \cup \bigcup_{s \in \ahf{NewObject}_{\it def}} \set{\langle \hat{l}_R, s \rangle}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2' = \ahf{Oldify}_{\it def}((\hat{H},\hat{C}, \hat{v}_{new}, \hat{a}_1)\\
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  (LP_1, \hat{es}) = \left\{\begin{array}{ll}
      (\bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \hat{P}_1\cup \hat{P}_2 \cup \hat{P}_3} \set{\langle \hat{l}, s \rangle}, \hat{es}')
      & \ifc{\hat{v}.1.3 \not\sqsubseteq \bot_{Bool} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{Number} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{String}}\\
      (\set{}, \set{}) & \owc
    \end{array}\right.\\
  \hat{v}_{new} = Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}.1.3, \hat{v}.1.4, \hat{v}.1.5), \hat{v}.2)\\
  \hat{P}_1 = \left\{\begin{array}{ll}
      \ahf{NewBool}_{\it def}
      & \ifc{\hat{v}_{new}.1.3 \not\sqsubseteq \bot_{Bool}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{P}_2 = \left\{\begin{array}{ll}
      \ahf{NewNumber}_{\it def}
      & \ifc{\hat{v}_{new}.1.4 \not\sqsubseteq \bot_{Number}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{P}_3 = \left\{\begin{array}{ll}
      \ahf{NewString}_{\it def}(\hat{v}_{new}.1.5)
      & \ifc{\hat{v}_{new}.1.5 \not\sqsubseteq \bot_{String}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{es}' = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \left\{\begin{array}{ll}
      \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewObject}_{\it def}} \set{\langle \hat{l}, s \rangle}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.getPrototypeOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyDescriptor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1)\\
  LP_2 = \set{\langle\hat{l}_R,``value"\rangle,\langle\hat{l}_R,``writable"\rangle,\langle\hat{l}_R,``enumerable"\rangle,\langle\hat{l}_R,``configurable"\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyNames}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1)\\
  LP_2 = \bigcup_{\hat{l} \in \hat{v}.2} \bigcup_{i \in \{0, ..., |\ahf{GetProps}(\hat{H},\hat{l})|-1\}}
    \set{\langle \hat{l}, i\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.create}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1)\\
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  \hat{v}_{2} = getArgValue(\hat{H},\hat{C}, ``1")\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{n}_{len} = \hat{2} \land \hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{s \in \ahf{NewObject}_{\it def}} \set{\langle \hat{l}_R, s\rangle}\\
  LP_3 = \left\{\begin{array}{ll}
      \bigcup_{\hat{l} \in \hat{v}_2.2} \ahf{DefineProperties}_{\it def}(\hat{H}, \hat{l}_R, \hat{l})
      & \ifc{\hat{n}_{len} = \hat{2}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_4 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperty}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{s}_{name} = \ahf{toString}(\ahf{toPrimitive}(getArgValue(\hat{H},\hat{C}, ``1")))\\
  \hat{v}_{2} = getArgValue(\hat{H},\hat{C}, ``2")\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{n}_{len} = \hat{2} \land \hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l}_1 \in \hat{v}_1.2}\bigcup_{\hat{l}_2 \in \hat{v}_2.2} 
    \ahf{DefineProperty}_{\it def}(\hat{H}, \hat{l}_1, \hat{s}_{name}, \hat{l}_2)
  LP_2 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.definePropeties}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{v}_{2} = getArgValue(\hat{H},\hat{C}, ``1")\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{n}_{len} = \hat{2} \land \hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l}_1 \in \hat{v}_1.2}\bigcup_{\hat{l}_2 \in \hat{v}_2.2} 
    \ahf{DefineProperties}_{\it def}(\hat{H}, \hat{l}_1, \hat{l}_2)
  LP_2 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.seal}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.freeze}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l}_1 \in \hat{v}.2} \set{\langle \hat{l},\varprop{extensible}\rangle} \cup
    \bigcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l})}  \set{\langle \hat{l}, s\rangle}\\
  LP_2 = \ahf{RaiseException}_{\it def}(\hat{es})\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.preventExtensions}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l}_1 \in \hat{v}.2} \set{\langle \hat{l},\varprop{extensible}\rangle}\\
  LP_2 = \ahf{RaiseException}_{\it def}(\hat{es})\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.isSealed}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.isFrozen}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.isExtensible}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\ 
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.keys}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1)\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{\hat{l} \in \hat{v}.2}\bigcup_{s \in \ahf{NewArrayObject}_{\it def}}
    \set{\langle \hat{l}_R, s\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es})\\ 
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  (LP_2, \hat{es}) = \left\{\begin{array}{ll}
      (\ahf{toObject}_{\it use}(\hat{H},\hat{C}, \hat{v}_{new}, \hat{a}_1), \hat{es}_1')
      & \ifc{\hat{v}.1.3 \not\sqsubseteq \bot_{Bool} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{Number} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{String}}\\
      (\set{}, \set{}) & \owc
    \end{array}\right.\\
  \hat{v}_{new} = Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}.1.3, \hat{v}.1.4, \hat{v}.1.5), \hat{v}.2)\\
  \hat{es}' = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \left\{\begin{array}{ll}
      \ahf{Oldify}_{\it use}(\hat{H},\hat{C}, \hat{v}_{new}, \hat{a}_1)\\
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_4 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  (LP_2, \hat{es}) = \left\{\begin{array}{ll}
      (\bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \hat{P}_1\cup \hat{P}_2 \cup \hat{P}_3} \set{\langle \hat{l}, s \rangle}, \hat{es}')
      & \ifc{\hat{v}.1.3 \not\sqsubseteq \bot_{Bool} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{Number} \lor \hat{v}.1.3 \not\sqsubseteq \bot_{String}}\\
      (\set{}, \set{}) & \owc
    \end{array}\right.\\
  \hat{v}_{new} = Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}.1.3, \hat{v}.1.4, \hat{v}.1.5), \hat{v}.2)\\
  \hat{P}_1 = \left\{\begin{array}{ll}
      \ahf{NewBool}_{\it def}
      & \ifc{\hat{v}_{new}.1.3 \not\sqsubseteq \bot_{Bool}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{P}_2 = \left\{\begin{array}{ll}
      \ahf{NewNumber}_{\it def}
      & \ifc{\hat{v}_{new}.1.4 \not\sqsubseteq \bot_{Number}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{P}_3 = \left\{\begin{array}{ll}
      \ahf{NewString}_{\it def}(\hat{v}_{new}.1.5)
      & \ifc{\hat{v}_{new}.1.5 \not\sqsubseteq \bot_{String}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{es}' = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \left\{\begin{array}{ll}
      \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewObject}_{\it def}} \set{\langle \hat{l}, s \rangle}
      & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef} \lor \hat{v}.1.2 \not\sqsubseteq \bot_{Null}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.getPrototypeOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 =  getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 =  \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{proto} \rangle}\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyDescriptor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{s} = \ahf{toString}(\ahf{toPrimitive}(getArgValue(\hat{H}, \hat{C}, ``1")))\\
  LP_1 =  getArgValue_{\it use}(\hat{H}, \hat{C}, ``0") \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_2 =  \bigcup_{\hat{l} \in \hat{C}.2} \ahf{absPair}(\hat{H}, \hat{l}, \hat{s})\\
  LP_3 = \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_1)\\
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.getOwnPropertyNames}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_1)\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \bigcup_{\hat{l} \in \hat{v}.2} \bigcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l})}  \set{\langle \hat{l}, s\rangle, \langle \hat{l}, \emph{``@default\_number"}\rangle, \langle \hat{l}, \emph{``@default\_other"}\rangle}\\ 
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es})\\ 
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\




\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.create}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_1)\\
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_{2} = getArgValue(\hat{H},\hat{C}, ``1")\\
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``1"))\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0") \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")
    \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{n}_{len} = \hat{2} \land \hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \left\{\begin{array}{ll}
      \bigcup_{\hat{l} \in \hat{v}_2.2} \ahf{DefineProperties}_{\it use}(\hat{H}, \hat{l}_R, \hat{l})
      & \ifc{\hat{n}_{len} = \hat{2}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.defineProperty}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{s}_{name} = \ahf{toString}(\ahf{toPrimitive}(getArgValue(\hat{H},\hat{C}, ``1")))\\
  \hat{v}_{2} = getArgValue(\hat{H},\hat{C}, ``2")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0") \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")
    \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, ``2")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{n}_{len} = \hat{2} \land \hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l}_1 \in \hat{v}_1.2}\bigcup_{\hat{l}_2 \in \hat{v}_2.2} 
    \ahf{DefineProperty}_{\it use}(\hat{H}, \hat{l}_1, \hat{s}_{name}, \hat{l}_2)
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es}_1 \sqcup \hat{es}_2)\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\end{array}
\]
\[
\begin{array}{l}


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.definePropeties}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_{2} = getArgValue(\hat{H},\hat{C}, ``1")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0") \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{n}_{len} = \hat{2} \land \hat{v}_2.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l}_1 \in \hat{v}_1.2}\bigcup_{\hat{l}_2 \in \hat{v}_2.2} 
    \ahf{DefineProperties}_{\it use}(\hat{H}, \hat{l}_1, \hat{l}_2)
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es}_1 \sqcup \hat{es}_2)\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\




\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.seal}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.freeze}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup  LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{\hat{l}_1 \in \hat{v}.2} \bigcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l})}  \set{\langle \hat{l}, s\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it use}(\hat{es})\\ 
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.preventExtensions}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es})\\ 
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.isSealed}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.isFrozen}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{\hat{l}_1 \in \hat{v}.2} \set{\langle \hat{l},\varprop{extensible}\rangle} \cup
    \bigcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l})}  \set{\langle \hat{l}, s\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it use}(\hat{es})\\ 
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.isExtensible}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{\hat{l}_1 \in \hat{v}.2} \set{\langle \hat{l},\varprop{extensible}\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it use}(\hat{es})\\ 
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.keys}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_1)\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\hat{v}_1.1 \not\sqsubseteq \bot_{PValue}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \bigcup_{\hat{l} \in \hat{v}.2} \bigcup_{s \in \ahf{GetProps}(\hat{H}, \hat{l})}  \set{\langle \hat{l}, s\rangle, \langle \hat{l}, \emph{``@default\_number"}\rangle, \langle \hat{l}, \emph{``@default\_other"}\rangle}\\ 
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es})\\ 
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\subsection{Object.prototype}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.hasOwnProperty}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.isPrototypeOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.propertyIsEnumerable}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{class} \rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.hasOwnProperty}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H},\hat{C}, ``0")\\
  \hat{s} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}))\\
  LP_1 = getArgValue_{\it use}(\hat{H},\hat{C}, ``0")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{HasOwnProperty}_{\it use}(\hat{H}, \hat{l}, \hat{s})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.isPrototypeOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H},\hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H},\hat{C}, ``0")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2}  \set{\langle \hat{l}, \varprop{proto} \rangle}\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Object.prototype.propertyIsEnumerable}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{s} = \ahf{toString}(\ahf{toPrimitive}(getArgValue(\hat{H},\hat{C}, ``0")))\\
  LP_1 = getArgValue_{\it use}(\hat{H},\hat{C}, ``0")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{absPair}(\hat{H}, \hat{l}, \hat{s})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\subsection{Function}
\[
\begin{array}{l}


\end{array}
\]


\subsection{Function.prototype}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Function.prototype}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Function"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5 \cup LP_6\\
\quad\wherec{
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1) \cup \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_2) \cup \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_3)\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \afalse \sqsubseteq \ahf{IsCallable}(\hat{H}, \hat{l})}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{v}_{arg} = getArgValue(\hat{H}, \hat{C}, ``1")\\
  \hat{v}_{arg1} = Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}_{arg}.1.3, \hat{v}_{arg}.1.4, \hat{v}_{arg}.1.5), \hat{v}_{arg}.2)\\
  (\hat{v}_{arg2}, \hat{es}_2) = \left\{\begin{array}{ll}
      (Value(\bot_{PValue}, \hat{v}_{arg1}.2), \{ \SF{TypeError} \})
      & \ifc{\hat{v}_{arg1}.1 \not\sqsubseteq \bot_{PValue}}\\
      (\hat{v}_{arg1}, \set{}) & \owc
    \end{array}\right.\\
  LP_2 =  \left\{\begin{array}{ll}
      LP_2'
      & \ifc{\hat{v}_{arg2} \not\sqsubseteq \bot_{Value}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2' =  \bigcup_{\hat{l} \in \hat{v}_{arg2}.2} \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n-1\}} \set{\langle \hat{l}_{R_3}, i\rangle}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
       \ahf{absPair}(\hat{H}, \hat{l}_{R_3}, \SF{NumStr}) & \owc\\
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  
  \hat{v}_{this} = getArgValue(\hat{H}, \hat{l}, ``0")\\
  \hat{L}_{arg} = \ahf{getThis}(\hat{H}, \hat{v}_{this})\\
  \hat{v}_{this2} =  Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}_{this}.1.3, \hat{v}_{this}.1.4, \hat{v}_{this}.1.5), \hat{L}_{arg})\\
  LP_3 = \ahf{toObject}_{\it def}(\hat{H}, \hat{C}, \hat{v}_{this2}, \hat{a}_4)\\
  LP_4 = \set{\langle \hat{l}_{R_3},``callee"\rangle}\\
  LP_5 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_6 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.call}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5 \cup LP_6\\
\quad\wherec{
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1) \cup \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_2)\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \afalse \sqsubseteq \ahf{IsCallable}(\hat{H}, \hat{l})}\\
      \set{} & \owc
    \end{array}\right.\\  
  \hat{n}_{len} = getArgValue(\hat{H}, \hat{l}, ``length") \hat{-} \hat{1}\\
  LP_2 = \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n-1\}} \set{\langle \hat{l}_{R_1}, i\rangle}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \lor \hat{n}_{len} = \SF{NUIntSingle}(n) }\\
      \set{} & \owc
    \end{array}\right.\\
    
  \hat{v}_{this} = getArgValue(\hat{H}, \hat{l}, ``0")\\
  \hat{L}_{arg} = \ahf{getThis}(\hat{H}, \hat{v}_{this})\\
  \hat{v}_{this2} =  Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}_{this}.1.3, \hat{v}_{this}.1.4, \hat{v}_{this}.1.5), \hat{L}_{arg})\\
  LP_3 = \ahf{toObject}_{\it def}(\hat{H}, \hat{C}, \hat{v}_{this2}, \hat{a}_4)\\
  LP_4 = \set{\langle \hat{l}_{R_3},``callee"\rangle}\\
  LP_5 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_6 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Function.prototype}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Function"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{class} \rangle}\\
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.apply}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5 \cup LP_6 \cup LP_7\\
\quad\wherec{
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_1) \cup \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_2) \cup \ahf{Oldify}_{\it use}(\hat{H}, \hat{C}, \hat{a}_3)\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \afalse \sqsubseteq \ahf{IsCallable}(\hat{H}, \hat{l})}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{L}_{fun} = \set{\hat{l} \mid \hat{l} \in \hat{C}.2 \land \atrue \sqsubseteq \ahf{IsCallable}(\hat{H}, \hat{l})}\\
  \hat{v}_{arg} = getArgValue(\hat{H}, \hat{C}, ``1")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0") \cup getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")\\
  \hat{v}_{arg1} = Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}_{arg}.1.3, \hat{v}_{arg}.1.4, \hat{v}_{arg}.1.5), \hat{v}_{arg}.2)\\
  (\hat{v}_{arg2}, \hat{es}_2) = \left\{\begin{array}{ll}
      (Value(\bot_{PValue}, \hat{v}_{arg1}.2), \{ \SF{TypeError} \})
      & \ifc{\hat{v}_{arg1}.1 \not\sqsubseteq \bot_{PValue}}\\
      (\hat{v}_{arg1}, \set{}) & \owc
    \end{array}\right.\\
  LP_3 =  \left\{\begin{array}{ll}
      LP_3'
      & \ifc{\hat{v}_{arg2} \not\sqsubseteq \bot_{Value}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3' =  \bigcup_{\hat{l} \in \hat{v}_{arg2}.2} \hat{LP}_{len} \cup \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n-1\}} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{i})
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr})& \owc\\
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  \hat{LP}_{len} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  
  \hat{v}_{this} = getArgValue(\hat{H}, \hat{l}, ``0")\\
  \hat{L}_{arg} = \ahf{getThis}(\hat{H}, \hat{v}_{this})\\
  \hat{v}_{this2} =  Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}_{this}.1.3, \hat{v}_{this}.1.4, \hat{v}_{this}.1.5), \hat{L}_{arg})\\
  LP_4 = \ahf{toObject}_{\it use}(\hat{H}, \hat{C}, \hat{v}_{this2}, \hat{a}_4)\\
  LP_5 = \bigcup_{\hat{l} \in \hat{L}_{fun}} \set{\langle\hat{l} \varprop{function}\rangle, \langle\hat{l} \varprop{scope}\rangle}\\
  LP_6 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_7 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Function.prototype.call}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5 \cup LP_6 \cup LP_7\\
\quad\wherec{
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_1) \cup \ahf{Oldify}_{\it def}(\hat{H}, \hat{C}, \hat{a}_2)\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \afalse \sqsubseteq \ahf{IsCallable}(\hat{H}, \hat{l})}\\
      \set{} & \owc
    \end{array}\right.\\  
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length") \cup getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{n}_{len} = getArgValue(\hat{H}, \hat{l}, ``length") \hat{-} \hat{1}\\
  LP_3 = \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n-1\}} getArgValue_{\it use}(\hat{H}, \hat{C}, i+1)
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \lor \hat{n}_{len} = \SF{NUIntSingle}(n) }\\
      \set{} & \owc
    \end{array}\right.\\
    
  \hat{v}_{this} = getArgValue(\hat{H}, \hat{l}, ``0")\\
  \hat{L}_{arg} = \ahf{getThis}(\hat{H}, \hat{v}_{this})\\
  \hat{v}_{this2} =  Value(PValue(\bot_{Undef}, \bot_{Null}, \hat{v}_{this}.1.3, \hat{v}_{this}.1.4, \hat{v}_{this}.1.5), \hat{L}_{arg})\\
  LP_4 = \ahf{toObject}_{\it use}(\hat{H}, \hat{C}, \hat{v}_{this2}, \hat{a}_4)\\
  LP_5 = \bigcup_{\hat{l} \in \hat{L}_{fun}} \set{\langle\hat{l} \varprop{function}\rangle, \langle\hat{l} \varprop{scope}\rangle}\\
  LP_6 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_7 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{Array}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{v} = getArgValue(\hat{H},\hat{C}, ``0")\\
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  \hat{es} = \left\{\begin{array}{ll}
      \hat{es}' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 1}\\
      \set{} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n != 1}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \hat{es}' & \owc
    \end{array}\right.\\  
  \hat{es}' = \left\{\begin{array}{ll}
      \set{}
      & \ifc{\hat{v}.1.4 = \SF{UInt} \lor \hat{v}.1.4 = \SF{UIntSingle} \lor \hat{v}.1.4 = \SF{NumBot} }\\
      \{ \SF{RangeError} \} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{s \in \ahf{NewArrayObejct}_{\it def}} \set{\langle \hat{l}_R, s\rangle}\\
  LP_3 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H},\hat{C}, ``0")\\
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  \hat{es} = \left\{\begin{array}{ll}
      \hat{es}' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 1}\\
      \set{} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n != 1}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \hat{es}' & \owc
    \end{array}\right.\\  
  \hat{es}' = \left\{\begin{array}{ll}
      \set{}
      & \ifc{\hat{v}.1.4 = \SF{UInt} \lor \hat{v}.1.4 = \SF{UIntSingle} \lor \hat{v}.1.4 = \SF{NumBot} }\\
      \{ \SF{RangeError} \} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2}\bigcup_{s \in \ahf{NewArrayObejct}_{\it def}}
    \set{\langle \hat{l}, s\rangle}\\
  LP_2 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.isArray}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{arglen} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  LP_2 = getArgValue(\hat{H},\hat{C}, ``0") \cup  getArgValue(\hat{H},\hat{C}, ``legnth")\\
  \hat{es} = \left\{\begin{array}{ll}
      \hat{es}' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 1}\\
      \set{} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n != 1}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \hat{es}' & \owc
    \end{array}\right.\\  
  \hat{es}' = \left\{\begin{array}{ll}
      \set{}
      & \ifc{\hat{v}.1.4 = \SF{UInt} \lor \hat{v}.1.4 = \SF{UIntSingle} \lor \hat{v}.1.4 = \SF{NumBot} }\\
      \{ \SF{RangeError} \} & \owc
    \end{array}\right.\\
  LP_3 = \left\{\begin{array}{ll}
      \bigcup_{i \in \{0, ..., n-1\}} \set{\langle \hat{l}_R, i\rangle}
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n)}\\
      \set{} & \ifc{\hat{n}_{arglen} = \bot_{Number}}\\
      \\ahf{absPair}(\hat{H}, \hat{l}_R, \SF{NumStr} & \owc
    \end{array}\right.\\
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H},\hat{C}, ``0")\\
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  LP_1 = getArgValue(\hat{H},\hat{C}, ``0") \cup  getArgValue(\hat{H},\hat{C}, ``legnth")\\
  \hat{es} = \left\{\begin{array}{ll}
      \hat{es}' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 1}\\
      \set{} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n != 1}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \hat{es}' & \owc
    \end{array}\right.\\  
  \hat{es}' = \left\{\begin{array}{ll}
      \set{}
      & \ifc{\hat{v}.1.4 = \SF{UInt} \lor \hat{v}.1.4 = \SF{UIntSingle} \lor \hat{v}.1.4 = \SF{NumBot} }\\
      \{ \SF{RangeError} \} & \owc
    \end{array}\right.\\
  LP_2 = \left\{\begin{array}{ll}
      \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{i \in \{0, ..., n-1\}} \set{\langle \hat{l}, i\rangle}
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n)}\\
      \set{} & \ifc{\hat{n}_{arglen} = \bot_{Number}}\\
      \bigcup_{\hat{l} \in \hat{C}.2} \ahf{absPair}(\hat{H}, \hat{l}, \SF{NumStr} & \owc
    \end{array}\right.\\  
  LP_3 = \bigcup_{\hat{l} \in \hat{C}.2}\bigcup_{s \in \ahf{NewArrayObejct}_{\it def}}
  LP_4 = \ahf{RaiseException}_{\it use}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_5 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.isArray}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{v}.2} \set{\langle \hat{l}, \varprop{class}\rangle}\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{Array.prototype}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.join}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.concat}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{arglen} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  LP_2 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arglen} = \bot_{Number}}\\
      LP_2' & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n_arglen)}\\
      LP_{array} & \owc
    \end{array}\right.\\
  LP_2' = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{array} \cup \bigcup_{i \in \{0,...,n-1\}} \set{\langle \hat{l}_R, i\rangle}\\ & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n)}\\
      LP_{array}  & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{array} = \bigcup_{s \in \ahf{NewArrayObejct}_{\it def}} \set{\langle \hat{l}_R, s\rangle}\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.pop}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      LP_{length} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} = 0}\\
      LP_{length} \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, n_{len}-1) & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} > 0}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{length} \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{length} = \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.push}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  LP_1 =  \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arg} = \bot_{Number}}\\
      LP_1' & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      \bigcup_{\hat{l} \in \hat{C}.2} \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  LP_1' = \bigcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"}) \cup \bigcup_{i \in \{0,...n_{arg}-1\}}\ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{i+n}) & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.reverse}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_len = \bot_{Number}}\\
      LP_1' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) \cup
        \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\    
  LP_1' = \bigcup_{i \in \{0, ..., floor(n/2)\} } LP_{swap} \cup LP_{up} \cup LP_{low}\\
  LP_{swap} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{up}) 
      & \ifc{\atrue \sqsubseteq \hat{b}_{low} \land \atrue \sqsubseteq \hat{b}_{up} }\\
      \set{} & \owc
    \end{array}\right.\\
   LP_{up} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{up}) 
      & \ifc{\afalse \sqsubseteq \hat{b}_{low} \land \atrue \sqsubseteq \hat{b}_{up} }\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{low} = \left\{\begin{array}{ll}
      \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{up}) 
      & \ifc{\atrue \sqsubseteq \hat{b}_{low} \land \afalse \sqsubseteq \hat{b}_{up} }\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{s}_{low} = \hat{i}\\
  \hat{s}_{up} = \hat{n-i-1}\\
  \hat{b}_{low} \ \ahf{HasProperty}(\hat{H},\hat{C},\hat{s}_{low})\\
  \hat{b}_{up} \ \ahf{HasProperty}(\hat{H},\hat{C},\hat{s}_{up})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.shift}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_len = \bot_{Number}}\\
      LP_1' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      LP_{store_{len}} \cup
        \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\    
  LP_1' = \left\{\begin{array}{ll}
      LP_{store_{len}} & \ifc{n = 0}\\
      LP_{array} \cup LP_{delete} \cup LP_{store_{len}} & \owc
    \end{array}\right.\\
  LP_{array} = \bigcup_{i \in \{1, ..., n-1\}} LP_{shift1} \cup LP_{shift2}\\
  LP_{shift1} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to}) & \ifc{\atrue \sqsubseteq \hat{b}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{shift2} = \left\{\begin{array}{ll}
      \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to}) & \ifc{\afalse \sqsubseteq \hat{b}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{delete} = \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{n-1})\\
  LP_{store_{len}} = \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"})\\
  \hat{s}_{from} = \hat{i}\\
  \hat{s}_{to} = \hat{n-i-1}\\
  \hat{b} = \ahf{HasProperty}(\hat{H},\hat{C},\hat{s}_{from})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.slice}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{start} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``0"))\\
  \hat{n}_{end} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``1"))\\
  LP_2 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{start} = \bot_{Number} \lor \hat{n}_{end} = \bot_{Number}}\\
      LP_{single} & \ifc{\gamma(\hat{n}_{start}) = n_{start} \land \gamma(\hat{n}_{end}) = n_{end} }\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{array} \cup \bigcup_{i \in \{0,...,n_{span}-1\}} \set{\langle \hat{l}_R, i\rangle}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      LP_{array} & \owc
    \end{array}\right.\\
  LP_{top} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{array} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{array} = \bigcup_{s \in \ahf{NewArrayObject}_{\it def}} \set{\langle \hat{l}_R,s\rangle}\\
  n_{from} = \left\{\begin{array}{ll}
      max(n + n_{start}, 0) & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      min(n_{start}, n) & \owc
    \end{array}\right.\\
  n_{to} = \left\{\begin{array}{ll}
      max(n + n_{end}, 0) & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      min(n_{end}, n) & \owc
    \end{array}\right.\\
  n_{span} = max(n_{to}-n_{from}, 0)\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.splice}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it def}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{arg} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  \hat{n}_{start} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``0"))\\
  \hat{n}_{count} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``1"))\\
  LP_2 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{start} = \bot_{Number} \lor \hat{n}_{count} = \bot_{Number}}\\
      LP_{single} & \ifc{\gamma(\hat{n}_{start}) = n_{start} \land \gamma(\hat{n}_{count}) = n_{count} }\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{array} \cup LP_{single_{1}} \cup LP_{single_{2}}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len})}\\
      LP_{array} \cup LP_{top_{store}} \cup LP_{top_{delet}} & \owc
    \end{array}\right.\\
  LP_{single_{1}} = \bigcup_{i \in \{0,...,n_{delCount}-1\}} \set{\langle \hat{l}_R, i\rangle}\\
  n_{delCount} = min(max(n_{count}, 0), n_{len} - n_{start})\\
  LP_{single_{2}} = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arg} = \bot_{Number}}\\
     LP_{single_{3}}  & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      \cup LP_{top_{store}} \cup LP_{top_{delete}} & \owc
    \end{array}\right.\\
  LP_{single_{3}} = \left\{\begin{array}{ll}
      LP_{single_{move1}} \cup LP_{single_{add}} \cup LP_{single_{delete}} \cup LP_{single_{length}} & \ifc{n_{addCount} < n_{count}}\\
      LP_{single_{move2}} \cup LP_{single_{add}} \cup LP_{single_{length}} & \owc
    \end{array}\right.\\
  n_{addCount} = n_{arg} -2\\
  LP_{single_{move1}} = \bigcup_{i \in \{n_{moveStart},...,n_{len}-1\}}\ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to_1}) \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to_1})\\
  LP_{single_{move2}} = \bigcup_{i \in \{0,...,n_{len} - n_{moveStart}-1\}}\ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to_2}) \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to_2})\\
  \hat{s}_{to_1} = \hat{i - n_{count} + n_{addCount}}\\
  \hat{s}_{to_2} = \hat{n_{len} - 1 - i - n_{count} + n_{addCount}}\\
  LP_{single_{add}} = \bigcup_{i \in \{0,...,n_{addCount}-1\}}\ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{n_{start} + i})\\
  LP_{single_{delete}} = \bigcup_{i \in \{n_{newLen},...,n_{len}-1\}}\ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{i})\\
  n_{newLen} = n_{len} + n_{addCount} - n_{count}
  LP_{single_{length}} = \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{top} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{array} \cup LP_{top_{store}} \cup LP_{top_{delet}} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{array} = \bigcup_{s \in \ahf{NewArrayObject}_{\it def}} \set{\langle \hat{l}_R,s\rangle}\\
  LP_{top_{store}} = \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{top_{delete}} = \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.unshift}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, \hat{``length"}))\\
  LP_1 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arg} = \bot_{Number}}\\
      LP_{single} & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      LP_{top} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\    
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{unshift} \cup LP_{add} \cup LP_{single_{length}} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len})}\\
      LP_{store} \cup LP_{delete} & \owc
    \end{array}\right.\\
  LP_{unshift} = \bigcup_{i \in \{0,...n_{len}-1\} }\ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to}) \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{s}_{to})\\
  \hat{s}_{to} = \hat{n_{len} -1 -i + n_{arg}}\\
  LP_{add} = \bigcup_{i \in \{0,...n_{arg}-1\} }\ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, i)\\
  LP_{delete} = \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{store} = \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{single_{length}} = \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{top} = \bigcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{store} \cup LP_{delete} & \owc
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.indexOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.lastIndexOf}",args)\rbr(\hat{H},\hat{C}) =LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) =LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(\bigsqcup_{\hat{l} \in \hat{C}.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, ``length"))\\
  LP_2 = \left\{\begin{array}{ll}
      LP_2' \cup LP_2'' & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} > 0}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2' = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, ``0"))\\
  LP_2'' = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{i \in \{1,...,n_{len}-1\}}\ahf{Proto}_{\it use}(\hat{H}, \hat{l}, ``i"))\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.concat}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{arglen} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  LP_2 = getArgValue_{\it use}(\hat{H},\hat{C}, ``length")\\
  LP_3 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arglen} = \bot_{Number}}\\
      LP_{single} & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n_arglen)}\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{len} \cup LP_{array} & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n)}\\
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr})  & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{len} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{array} = \bigcup_{i \in \{0,...,n-1\}} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{i}) \cup
    \bigcup_{i \in \{0,...,n-1\}} getArgValue_{\it use}(\hat{H}, \hat{l}, i)\\
  LP_{top} =  \bigcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup getArgValue_{\it use}(\hat{H}, \hat{C}, \SF{NumStr})\\

  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.join}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H},\hat{C}, ``0")\\
  \hat{n}_{len} = \ahf{toUInt32}(\bigsqcup_{\hat{l} \in \hat{C}.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, ``length"))\\
  LP_3 = \left\{\begin{array}{ll}
      LP_{first} \cup LP_{remain} & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n_{arglen})}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{first} = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``0"})\\
  LP_{remain} = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{i \in \{1,...,n_{arglen}-1\}} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{i})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  
  }\\
\\
\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.pop}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(\bigsqcup_{\hat{l} \in \hat{C}.2}  \ahf{Proto}(\hat{H}, \hat{l}, ``length"))\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, ``length"))\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2}  \left\{\begin{array}{ll}
      LP_{length} \cup LP_{store} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} = 0}\\
      LP_{length} \cup LP_{single} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} > 0}\\
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{length} \cup LP_{top} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{single} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{n_{len}-1}) \cup \ahf{Delete}_{\it use}(\hat{H}, \hat{l}, \hat{n_{len}-1}) \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \hat{n_{len}-1}) \cup LP_{store}\\
  LP_{top} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup \ahf{Delete}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup \cup \ahf{Delete}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr}) \cup LP_{store}\\
  LP_{store} = \ahf{PropStore}_{\it use}(\hat{H}, \hat{l}, \hat{``length"}) \cup \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{length} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.push}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  LP_1 = getArgValue_{\it use}(\hat{H},\hat{C}, ``length")\\
  LP_2 =  \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arg} = \bot_{Number}}\\
      LP_{single} & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2}  LP_{length} \cup \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{single1} \cup LP_{single2} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      LP_{top} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{single1} = \bigcup_{i \in \{0,...,n-1\}} \ahf{PropStore}_{\it use}(\hat{H}, \hat{l}, \hat{i}) \cup \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{i}) \cup getArgValue_{\it use}(\hat{H},\hat{C}, i)\\
  LP_{single2} = \ahf{PropStore}_{\it use}(\hat{H}, \hat{l}, \hat{``length"}) \cup \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{length} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{top} = getArgValue_{\it use}(\hat{H},\hat{C}, \SF{NumStr})
    \cup \bigcup_{\hat{l} \in \hat{C}.2} \ahf{PropStore}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup  \ahf{PropStore}_{\it def}(\hat{H}, \hat{l}, \SF{NumStr})\\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.reverse}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} LP_{len} LP_1'\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\    
  LP_{len} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_1' = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_len = \bot_{Number}}\\
      LP_{single} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{i \in \{0, ..., floor(n/2)\} } 
    \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{s}_{up}) \cup LP_{swap} \cup LP_{up} \cup LP_{low}\\
  LP_{swap} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{up}) 
      & \ifc{\atrue \sqsubseteq \hat{b}_{low} \land \atrue \sqsubseteq \hat{b}_{up} }\\
      \set{} & \owc
    \end{array}\right.\\
   LP_{up} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{up}) 
      & \ifc{\afalse \sqsubseteq \hat{b}_{low} \land \atrue \sqsubseteq \hat{b}_{up} }\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{low} = \left\{\begin{array}{ll}
      \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{low}) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{up}) 
      & \ifc{\atrue \sqsubseteq \hat{b}_{low} \land \afalse \sqsubseteq \hat{b}_{up} }\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{top} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr}) \cup \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  \hat{s}_{low} = \hat{i}\\
  \hat{s}_{up} = \hat{n-i-1}\\
  \hat{b}_{low} \ \ahf{HasProperty}(\hat{H},\hat{C},\hat{s}_{low})\\
  \hat{b}_{up} \ \ahf{HasProperty}(\hat{H},\hat{C},\hat{s}_{up})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.shift}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} LP_{len} \cup LP_1' 
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\    
  LP_{len} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\  
  LP_1' = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{single} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \left\{\begin{array}{ll}
      LP_{store_{len}} & \ifc{n = 0}\\
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{0}) \cup LP_{array} \cup LP_{delete} \cup LP_{store_{len}} & \owc
    \end{array}\right.\\
  LP_{array} = \bigcup_{i \in \{1, ..., n-1\}} LP_{shift1} \cup LP_{shift2}\\
  LP_{shift1} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to}) \cup \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{s}_{from})
      & \ifc{\atrue \sqsubseteq \hat{b}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{shift2} = \left\{\begin{array}{ll}
      \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to}) & \ifc{\afalse \sqsubseteq \hat{b}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{delete} = \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{n-1})\\
  LP_{store_{len}} = \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{top} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{``length"}) \cup \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  \hat{s}_{from} = \hat{i}\\
  \hat{s}_{to} = \hat{n-i-1}\\
  \hat{b} = \ahf{HasProperty}(\hat{H},\hat{C},\hat{s}_{from})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.slice}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{l}_R = (\hat{a}_1, \SF{Recent})\\
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{start} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``0"))\\
  \hat{n}_{end} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``1"))\\
  LP_2 = getArgValue_{\it use}(\hat{H},\hat{C}, ``0") \sqcup getArgValue_{\it use}(\hat{H},\hat{C}, ``1")\\
  LP_3 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{start} = \bot_{Number} \lor \hat{n}_{end} = \bot_{Number}}\\
      LP_{single} & \ifc{\gamma(\hat{n}_{start}) = n_{start} \land \gamma(\hat{n}_{end}) = n_{end} }\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{array} \cup \bigcup_{i \in \{0,...,n_{span}-1\}} LP_{slice}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  LP_{slice} = \left\{\begin{array}{ll}
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{from+i})
      & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, \hat{i})}\\
      \set{} \cup LP_{array} & \owc
    \end{array}\right.\\
  LP_{top} = \bigcup_{\hat{l} \in \hat{C}.2} \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{length} \cup LP_{array} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{array} = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) & \owc
    \end{array}\right.\\
  LP_{length} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  n_{from} = \left\{\begin{array}{ll}
      max(n + n_{start}, 0) & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      min(n_{start}, n) & \owc
    \end{array}\right.\\
  n_{to} = \left\{\begin{array}{ll}
      max(n + n_{end}, 0) & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      min(n_{end}, n) & \owc
    \end{array}\right.\\
  n_{span} = max(n_{to}-n_{from}, 0)\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.splice}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  LP_1 = \ahf{Oldify}_{\it use}(\hat{H},\hat{C}, \hat{a}_1)\\
  \hat{n}_{arg} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``length"))\\
  \hat{n}_{start} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``0"))\\
  \hat{n}_{count} = \ahf{toInteger}(getArgValue(\hat{H},\hat{C}, ``1"))\\
  LP_2 =  getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``0"}) \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``1"}) \cup  getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``length"})\\
  LP_3 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{start} = \bot_{Number} \lor \hat{n}_{count} = \bot_{Number}}\\
      LP_{single} & \ifc{\gamma(\hat{n}_{start}) = n_{start} \land \gamma(\hat{n}_{count}) = n_{count} }\\
      LP_{top} & \owc
    \end{array}\right.\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2} LP_{len} \cup \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{single_{1}} \cup LP_{single_{2}}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len})}\\
      LP_{top_{proto}} \cup LP_{top_{store}} \cup LP_{top_{delete}} \cup LP_{top_{get}} & \owc
    \end{array}\right.\\
  LP_{single_{1}} = \bigcup_{i \in \{0,...,n_{delCount}-1\}} \left\{\begin{array}{ll}
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{i+from})
      & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, \hat{i})}\\
      \set{} & \owc
    \end{array}\right.\\
  n_{delCount} = min(max(n_{count}, 0), n_{len} - n_{start})\\
  LP_{single_{2}} = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arg} = \bot_{Number}}\\
      LP_{single_{3}}  & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      LP_{top_{store}} \cup LP_{top_{delete}} \cup LP_{top_{get}} & \owc
    \end{array}\right.\\
  LP_{single_{3}} = \left\{\begin{array}{ll}
      LP_{single_{move1}} \cup LP_{single_{add}} \cup LP_{single_{delete}} \cup LP_{single_{length}} & \ifc{n_{addCount} < n_{count}}\\
      LP_{single_{move2}} \cup LP_{single_{add}} \cup LP_{single_{length}} & \owc
    \end{array}\right.\\
  n_{addCount} = n_{arg} -2\\
  LP_{single_{move1}} = \bigcup_{i \in \{n_{moveStart},...,n_{len}-1\}}
     \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{s}_{from_1}) \cup LP_{move1_1}\cup LP_{move1_2}\\
  LP_{move1_1} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to_1})
      & \ifc{\atrue = \ahf{HasProperty}(\hat{H},\hat{l}, \hat{s}_{from_1})}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{move1_2} =   
    \left\{\begin{array}{ll}
      \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to_1}
      & \ifc{\afalse = \ahf{HasProperty}(\hat{H},\hat{l}, \hat{s}_{from_1})}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{single_{move2}} = \bigcup_{i \in \{0,...,n_{len} - n_{moveStart}-1\}}
    \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{s}_{from_2}) \cup LP_{move2_1} \cup LP_{move2_2}\\
  LP_{move2_1} = \left\{\begin{array}{ll}
      \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to_1})
      & \ifc{\atrue = \ahf{HasProperty}(\hat{H},\hat{l}, \hat{s}_{from_1})}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{move2_2} =  
    \left\{\begin{array}{ll}
      \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to_1}
      & \ifc{\afalse = \ahf{HasProperty}(\hat{H},\hat{l}, \hat{s}_{from_1})}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{s}_{to_1} = \hat{i - n_{count} + n_{addCount}}\\
  \hat{s}_{to_2} = \hat{n_{len} - 1 - i - n_{count} + n_{addCount}}\\
  \hat{s}_{from_1} = \hat{i}\\
  \hat{s}_{from_2} = \hat{n_{len} - 1 - i}\\
  LP_{single_{add}} = \bigcup_{i \in \{0,...,n_{addCount}-1\}} getArgValue(\hat{H},\hat{C}, \hat{i+2}) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{n_{start} + i})\\
  LP_{single_{delete}} = \bigcup_{i \in \{n_{newLen},...,n_{len}-1\}} \ahf{Delete}_{\it use}(\hat{H}, \hat{l}, \hat{i})\\
  LP_{single_{length}} = \ahf{PropStore}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  n_{newLen} = n_{len} + n_{addCount} - n_{count}\\
  LP_{top} = \bigcup_{\hat{l} \in \hat{C}.2} LP_{len} \cup \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{top_{proto}} \cup LP_{top_{store}} \cup LP_{top_{delete}} \cup LP_{top_{get}} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{len} =  \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{top_{proto}} = \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{top_{store}} = \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{top_{delete}} = \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{top_{get}} = getArgValue_{\it use}(\hat{H}, \hat{C}, \SF{NumStr})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.unshift}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, \hat{``length"}))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``length"})
  LP_2 = \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{arg} = \bot_{Number}}\\
      LP_{single} & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      LP_{top} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{len} =  \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2}  LP_{len} \cup \left\{\begin{array}{ll}
      \set{} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      LP_{unshift} \cup LP_{add} \cup LP_{single_{length}} & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len})}\\
     \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup  LP_{store} \cup LP_{delete} & \owc
    \end{array}\right.\\
  LP_{unshift} = \bigcup_{i \in \{0,...n_{len}-1\} } LP_{unshift1} \cup LP_{unshift2}\\
  LP_{unshift1} = \left\{\begin{array}{ll}
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{s}_{from}) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to})
      & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, \hat{s}_{from})}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_{unshift2} = \left\{\begin{array}{ll}
      \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \hat{s}_{to})
      & \ifc{\atrue \sqsubseteq \ahf{HasProperty}(\hat{H}, \hat{l}, \hat{s}_{from})}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{s}_{to} = \hat{n_{len} -1 -i + n_{arg}}\\
  LP_{add} = \bigcup_{i \in \{0,...n_{arg}-1\} } getArgValue_{\it use}(\hat{H}, \hat{C}, i) \cup \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, i)\\
  LP_{single_{length}} = \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{delete} = \ahf{Delete}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{store} = \ahf{PropStore}_{\it use/def}(\hat{H}, \hat{l}, \SF{NumStr})\\
  LP_{top} = \bigcup_{\hat{l} \in \hat{C}.2}  LP_{len} \cup \left\{\begin{array}{ll}
      \set{}& \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \SF{NumStr}) \cup LP_{store} \cup LP_{delete} & \owc
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\



\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.indexOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, \hat{``length"}))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``length"})\\
  LP_2 = \left\{\begin{array}{ll}
      LP_{search} \cup LP_{single} & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{v}_{search} = getArgValue(\hat{H}, \hat{C}, \hat{``0"})\\
  LP_{search} = getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``0"})\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2}  LP_{len} \cup \left\{\begin{array}{ll}
      LP_{start} \cup LP_{find}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} \neq 0}\\
     \set{} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{len} =  \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  \hat{n}_{start} = \left\{\begin{array}{ll}
      \ahf{toInteger}(getArgValue(\hat{H}, \hat{C}, ``1")) & \ifc{n_{arg} > 1}\\
      \hat{0} & \owc
    \end{array}\right.\\
  LP_{start} = \left\{\begin{array}{ll}
      getArgValue_{\it use}(\hat{H}, \hat{C}, ``1" & \ifc{n_{arg} > 1}\\
      \hat{0} & \owc
    \end{array}\right.\\
  LP_{find} = \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n_k-1\}} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{i})
      & \ifc{(\hat{n}_{start} = \SF{UIntSingle}(n_{start}) \lor \hat{n}_{start} = \SF{NUIntSingle}(n_{start})) \land n_{start} < n_{len}}\\
      \set{} & \owc
    \end{array}\right.\\
  n_k = \left\{\begin{array}{ll}
      n_{len} - abs(n_{start}) & \ifc{n_{start} < 0}\\
      n_{start} & \owc
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Array.prototype.lastIndexOf}",args)\rbr(\hat{H},\hat{C}) =LP_1\\
\quad\wherec{
  \hat{n}_{arg} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, \hat{``length"}))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``length"})\\
  LP_2 = \left\{\begin{array}{ll}
      LP_{search} \cup LP_{single} & \ifc{\hat{n}_{arg} = \SF{UIntSingle}(n_{arg})}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{v}_{search} = getArgValue(\hat{H}, \hat{C}, \hat{``0"})\\
  LP_{search} = getArgValue_{\it use}(\hat{H}, \hat{C}, \hat{``0"})\\
  LP_{single} = \bigcup_{\hat{l} \in \hat{C}.2}  LP_{len} \cup \left\{\begin{array}{ll}
      LP_{start} \cup LP_{find}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n_{len}) \land n_{len} \neq 0}\\
     \set{} & \owc
    \end{array}\right.\\
  \hat{n}_{len} = \ahf{toUInt32}(\ahf{Proto}(\hat{H}, \hat{l}, \hat{``length"}))\\
  LP_{len} =  \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``length"})\\
  \hat{n}_{start} = \left\{\begin{array}{ll}
      \ahf{toInteger}(getArgValue(\hat{H}, \hat{C}, ``1")) & \ifc{n_{arg} > 1}\\
      \hat{0} & \owc
    \end{array}\right.\\
  LP_{start} = \left\{\begin{array}{ll}
      getArgValue_{\it use}(\hat{H}, \hat{C}, ``1" & \ifc{n_{arg} > 1}\\
      \hat{0} & \owc
    \end{array}\right.\\
  LP_{find} = \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n_k-1\}} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{k-i})
      & \ifc{(\hat{n}_{start} = \SF{UIntSingle}(n_{start}) \lor \hat{n}_{start} = \SF{NUIntSingle}(n_{start})) \land n_{start} < n_{len}}\\
      \set{} & \owc
    \end{array}\right.\\
  n_k = \left\{\begin{array}{ll}
      min(n_{start}, n_{len}-1) & \ifc{n_{start} \geq 0}\\
      n_{len} - abs(n_{start}) & \owc
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{String}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  \hat{s} = \left\{\begin{array}{ll}
      \hat{``"}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 0}\\
      \ahf{toString}(\ahf{toPrimitive}(getArgValue(\hat{H}, \hat{C}, ``0")))
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n > 0}\\
      \bot_{String} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \top_{String} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewString}_{\it def}(\hat{s})}
    \set{\langle \hat{l}, s \rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.fromCharCode}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\




\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = \left\{\begin{array}{ll}
      \set{}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n == 0}\\
      getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n > 0}\\
      getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")
      & \ifc{\SF{UInt} \sqsubseteq \hat{n}_{len}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\  
  
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = \left\{\begin{array}{ll}
      getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n > 0}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{s} = \left\{\begin{array}{ll}
      \hat{``"}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 0}\\
      \ahf{toString}(\ahf{toPrimitive}(getArgValue(\hat{H}, \hat{C}, ``0")))
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n > 0}\\
      \bot_{String} & \ifc{\hat{n}_{len} = \bot_{Number}}\\
      \top_{String} & \owc
    \end{array}\right.\\
  LP_3 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewString}_{\it def}(\hat{s})}
    \set{\langle \hat{l}, s \rangle}\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.fromCharCode}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = \left\{\begin{array}{ll}
      \bigcup_{i \in \{0,...,n-1\} } getArgValue_{\it use}(\hat{H}, \hat{C}, i)
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n)}\\
      getArgValue_{\it use}(\hat{H}, \hat{C}, \SF{NumStr})
      & \ifc{\SF{UInt} \sqsubseteq \hat{n}_{len}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]



\subsection{String.prototype}
\[
\begin{array}{l}


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``String"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charAt}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charCodeAt}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.concat}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.indexOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.lastIndexOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.localeCompare}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.slice}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.substring}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLowerCase}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleLowerCase}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toUpperCase}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleUpperCase}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{String.prototype.trim}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\end{array}
\]
\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``String"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{class} \rangle}\\
  \hat{L}_{string} = \set{\hat{l} \mid \hat{l} \in \hat{C}.2 \land \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 = \hat{``String"}}\\
  LP_2 = \bigcup_{\hat{l} \in \hat{L}_{string}} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_3 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charAt}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.charCodeAt}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.concat}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{n}_{len} = \ahf{toUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_3 = \left\{\begin{array}{ll}
      \set{}
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n = 0}\\
      \bigcup_{i \in \{0,...,n-1\} } getArgValue_{\it use}(\hat{H}, \hat{C}, i)
      & \ifc{\hat{n}_{len} = \SF{UIntSingle}(n) \land n > 0}\\
      getArgValue_{\it use}(\hat{H}, \hat{C}, \SF{NumStr})
      & \ifc{\SF{UInt} \sqsubseteq \hat{n}_{len}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.localeCompare}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.indexOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.lastIndexOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.slice}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.substring}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0") \cup getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLowerCase}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleLowerCase}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toUpperCase}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.toLocaleUpperCase}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{String.prototype.trim}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]



\subsection{Boolean}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Boolean}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Boolean.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewBoolean}_{\it def}}
    \set{\langle \hat{l}, s \rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Boolean}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Boolean.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_3 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewBoolean}_{\it def}}
    \set{\langle \hat{l}, s \rangle}\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]
\subsection{Boolean.prototype}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Boolean"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Boolean.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{class} \rangle}\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Boolean"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  \hat{L}_{bool} = \set{\hat{l} \mid \hat{l} \in \hat{C}.2 \land \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 = \hat{``Boolean"}}\\
  LP_3 = \bigcup_{\hat{l} \in \hat{L}_{bool}} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]


\subsection{Number}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewNumber}_{\it def}}
    \set{\langle \hat{l}, s \rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.constructor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_3 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewNumber}_{\it def}}
    \set{\langle \hat{l}, s \rangle}\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]

\subsection{Number.prorotype}
\[
\begin{array}{l}
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{n}_{arglen} = \ahf{ToUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  \hat{v}_{1} =getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Number"}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{es}_2 = \left\{\begin{array}{ll}
      \{ \} & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n) \land n = 0}\\
      \{ \SF{RangeError} \}
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n) \land n > 0 
        \land (\atrue \sqsubseteq \hat{v}_1 \hat{<} \hat{2} \lor \atrue \sqsubseteq \hat{v}_1 \hat{>} \hat{36} )}\\
      \{ \} & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n) \land n > 0 
        \land \afalse \sqsubseteq \hat{v}_1 \hat{<} \hat{2} \land \afalse \sqsubseteq \hat{v}_1 \hat{>} \hat{36} )}\\
      \{ \} & \ifc{\hat{n}_{arglen} = \bot_{number}}\\
      \{ \SF{RangeError} \} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Number"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\




\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toFixed}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v}_1 =getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_2 = \left\{\begin{array}{ll}
      Value(PValue(\hat{v}_1.1.1,\hat{v}_1.1.2,\hat{v}_1.1.3,
        \hat{0} \sqcup \hat{v}_1.1.4,\hat{v}_1.1.5), \hat{v}_1.2)
      & \ifc{\top_{Undef} \sqsubseteq \hat{v}.1.1}\\
      \hat{v}_1 & \owc
    \end{array}\right.\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{RangeError} \}
      & \ifc{\atrue \sqsubseteq \hat{v}_2 \hat{<} \hat{0} \lor \atrue \sqsubseteq \hat{v}_2 \hat{>} \hat{20}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toExponential}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v}_1 =getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_2 = \left\{\begin{array}{ll}
      Value(PValue(\hat{v}_1.1.1,\hat{v}_1.1.2,\hat{v}_1.1.3,
        \hat{v}_1.1.4,\hat{v}_1.1.5), \hat{v}_1.2)
      & \ifc{\top_{Undef} \sqsubseteq \hat{v}.1.1}\\
      \hat{v}_1 & \owc
    \end{array}\right.\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{RangeError} \}
      & \ifc{\atrue \sqsubseteq \hat{v}_2 \hat{<} \hat{0} \lor \atrue \sqsubseteq \hat{v}_2 \hat{>} \hat{20}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toPrecision}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v}_1 =getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_2 = \left\{\begin{array}{ll}
      Value(PValue(\hat{v}_1.1.1,\hat{v}_1.1.2,\hat{v}_1.1.3,
        \hat{v}_1.1.4,\hat{v}_1.1.5), \hat{v}_1.2)
      & \ifc{\top_{Undef} \sqsubseteq \hat{v}.1.1}\\
      \hat{v}_1 & \owc
    \end{array}\right.\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{RangeError} \}
      & \ifc{\atrue \sqsubseteq \hat{v}_2 \hat{<} \hat{1} \lor \atrue \sqsubseteq \hat{v}_2 \hat{>} \hat{21}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_1 = \ahf{RaiseException}_{\it def}(\hat{es})\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4 \cup LP_5 \cup LP_6\\
\quad\wherec{
  \hat{n}_{arglen} = \ahf{ToUInt32}(getArgValue(\hat{H}, \hat{C}, ``length"))\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  \hat{v}_{1} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  \hat{es}_1 = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Number"}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{class} \rangle}\\
  \hat{L}_{num} = \set{\hat{l} \mid \hat{l} \in \hat{C}.2 \land \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 = \hat{``Number"}}\\
  LP_3 = \bigcup_{\hat{l} \in \hat{L}_{Number}} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  \hat({es}_2, LP_4) = \left\{\begin{array}{ll}
      (\{ \}, \set{}) & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n) \land n = 0}\\
      (\{ \SF{RangeError} \}, getArgValue_{\it use}(\hat{H}, \hat{C}, ``0"))
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n) \land n > 0 
        \land (\atrue \sqsubseteq \hat{v}_1 \hat{<} \hat{2} \lor \atrue \sqsubseteq \hat{v}_1 \hat{>} \hat{36} )}\\
      (\{ \}, getArgValue_{\it use}(\hat{H}, \hat{C}, ``0"))
      & \ifc{\hat{n}_{arglen} = \SF{UIntSingle}(n) \land n > 0 
        \land \afalse \sqsubseteq \hat{v}_1 \hat{<} \hat{2} \land \afalse \sqsubseteq \hat{v}_1 \hat{>} \hat{36} )}\\
      (\{ \}, \set{}) & \ifc{\hat{n}_{arglen} = \bot_{number}}\\
      (\{ \SF{RangeError} \}, getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")) & \owc
    \end{array}\right.\\
  LP_5 = \ahf{RaiseException}_{\it use}(\hat{es}_1 \sqcup \hat{es}_2)\\
  LP_6 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{TypeError} \}
      & \ifc{\exists\hat{l}\in\hat{C}.2: \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 \neq \hat{``Number"}}\\
      \set{} & \owc
    \end{array}\right.\\
  \hat{L}_{num} = \set{\hat{l} \mid \hat{l} \in \hat{C}.2 \land \hat{H}(\hat{l})(\avarprop{class}).1.2.1.5 = \hat{``Number"}}\\
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l},\varprop{class} \rangle}\\
  LP_2 = \bigcup_{\hat{l} \in \hat{L}_{Number}} \set{\langle \hat{l},\varprop{primitive} \rangle}\\
  LP_3 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toFixed}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_2 = \left\{\begin{array}{ll}
      Value(PValue(\hat{v}_1.1.1,\hat{v}_1.1.2,\hat{v}_1.1.3,
        \hat{0} \sqcup \hat{v}_1.1.4,\hat{v}_1.1.5), \hat{v}_1.2)
      & \ifc{\top_{Undef} \sqsubseteq \hat{v}.1.1}\\
      \hat{v}_1 & \owc
    \end{array}\right.\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{RangeError} \}
      & \ifc{\atrue \sqsubseteq \hat{v}_2 \hat{<} \hat{0} \lor \atrue \sqsubseteq \hat{v}_2 \hat{>} \hat{20}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toExponential}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 =getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_2 = \left\{\begin{array}{ll}
      Value(PValue(\hat{v}_1.1.1,\hat{v}_1.1.2,\hat{v}_1.1.3,
        \hat{v}_1.1.4,\hat{v}_1.1.5), \hat{v}_1.2)
      & \ifc{\top_{Undef} \sqsubseteq \hat{v}.1.1}\\
      \hat{v}_1 & \owc
    \end{array}\right.\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{RangeError} \}
      & \ifc{\atrue \sqsubseteq \hat{v}_2 \hat{<} \hat{0} \lor \atrue \sqsubseteq \hat{v}_2 \hat{>} \hat{20}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Number.prototype.toPrecision}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v}_1 =getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v}_2 = \left\{\begin{array}{ll}
      Value(PValue(\hat{v}_1.1.1,\hat{v}_1.1.2,\hat{v}_1.1.3,
        \hat{v}_1.1.4,\hat{v}_1.1.5), \hat{v}_1.2)
      & \ifc{\top_{Undef} \sqsubseteq \hat{v}.1.1}\\
      \hat{v}_1 & \owc
    \end{array}\right.\\
  \hat{es} = \left\{\begin{array}{ll}
      \{ \SF{RangeError} \}
      & \ifc{\atrue \sqsubseteq \hat{v}_2 \hat{<} \hat{1} \lor \atrue \sqsubseteq \hat{v}_2 \hat{>} \hat{21}}\\
      \set{} & \owc
    \end{array}\right.\\
  LP_2 = \ahf{RaiseException}_{\it use}(\hat{es})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\subsection{Math}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.abs}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.acos}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.asin}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.atan}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.atan2}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.ceil}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.cos}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.exp}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.floor}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.max}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.min}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.pow}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.log}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.random}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.round}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.sin}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.sqrt}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Math.tan}",args)\rbr(\hat{H},\hat{C})= LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.random}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.abs}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.acos}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.asin}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.atan}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.ceil}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.cos}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.exp}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\  
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.floor}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\ 
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.log}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.round}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.sin}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.sqrt}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.tan}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")
  \land\ LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
  
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.atan2}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.pow}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")
  \land\ LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``1")\\
  \land\ LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.max}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Math.min}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{n} = getArgValue(\hat{H}, \hat{C}, ``length")\\
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = \left\{\begin{array}{ll}
      \bigsqcup_{i \in \{0, ..., n-1\}} getArgValue_{\it use}(\hat{H}, \hat{C}, i)
      & \ifc{\hat{n} = \SF{UIntSingle}(n)} \\
      \set{} & \owc
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\









\end{array}
\]


\subsection{Date}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewDate}_{\it def}}
    \set{\langle \hat{l}, s \rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.now}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3 \cup LP_4\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``length")\\
  LP_2 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_3 = \bigcup_{\hat{l} \in \hat{C}.2} \bigcup_{s \in \ahf{NewDate}_{\it def}}
    \set{\langle \hat{l}, s \rangle}\\
  LP_4 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.now}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{Date.prototype}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toDateString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toTimeString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleDateString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleTimeString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toUTCString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toISOString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTime}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDate}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDay}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getHours}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTimezoneOffset}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDate}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDay}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCHours}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setTime}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setHours}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setDate}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCHours}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCDate}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l}, \varprop{primitive}\rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\[
\begin{array}{l}

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toDateString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toTimeString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleDateString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toLocaleTimeString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toUTCString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.toISOString}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDate}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getDay}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getHours}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTimezoneOffset}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDate}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCDay}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCHours}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getUTCMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\
\end{array}
\]

\[
\begin{array}{l}
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.valueOf}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.getTime}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setTime}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setHours}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setDate}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMilliseconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCSeconds}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMinutes}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCHours}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCDate}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCMonth}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Date.prototype.setUTCFullYear}",args)\rbr(\hat{H},\hat{C}) = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = \bigcup_{\hat{l} \in \hat{C}.2} \set{\langle \hat{l}, \varprop{primitive}\rangle}\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{RegExp}
\[
\begin{array}{l}
\end{array}
\]

\subsection{RegExp.prototype}
\[
\begin{array}{l}
\end{array}
\]

\subsection{Error}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{ErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Error.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{ErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\subsection{Error.prototype}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{Error.prototype.toString}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{Error.prototype.toString}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = \bigsqcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``name"})\\
  LP_2 = \bigsqcup_{\hat{l} \in \hat{C}.2} \ahf{Proto}_{\it use}(\hat{H}, \hat{l}, \hat{``message"})\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]

\subsection{EvalError}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{EvalError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{EvalErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{EvalError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{EvalErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{RangeError}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{RangeError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{RangeErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{RangeError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{RangeErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{ReferenceError}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{ReferenceError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{RefErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{ReferenceError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{RefErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{SyntaxError}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{SyntaxError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{SyntaxErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{SyntaxError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{SyntaxErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{TypeError}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{TypeError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{TypeErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{TypeError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{TypeErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{URIError}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{URIError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2 \cup LP_3\\
\quad\wherec{
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_1 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{URIErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_2 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{URIError.constructor}",args)\rbr(\hat{H},\hat{C})
  = LP_1 \cup LP_2\\
\quad\wherec{
  LP_1 = getArgValue_{\it use}(\hat{H}, \hat{C}, ``0")\\
  \hat{v} = getArgValue(\hat{H}, \hat{C}, ``0")\\
  LP_2 = \left\{\begin{array}{ll}
  \set{\langle\avarloc{URIErrorLoc}_O, ``message"\rangle} & \ifc{\hat{v}.1.1 \not\sqsubseteq \bot_{Undef}}\\
  \set{} & \owc\\
    \end{array}\right.\\
  LP_3 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


\subsection{JSON}
\[
\begin{array}{l}

\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{JSON.parse}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it def}\lbr \SF{BuiltintCall}(``\SF{JSON.stringify}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\


\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{JSON.parse}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\aI_{\it use}\lbr \SF{BuiltintCall}(``\SF{JSON.stringify}",args)\rbr(\hat{H},\hat{C})
  = LP_1\\
\quad\wherec{
  LP_1 = \set{\langle\avarloc{PureLocal}_R,\varprop{return}\rangle}\\
  }\\
\\

\end{array}
\]


 
