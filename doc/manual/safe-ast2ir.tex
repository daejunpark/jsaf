\chapter{AST}
\small
\[
\begin{array}{llll}
\pgm & ::=  & \fd^*\ \vd^*\ \stmt^* & \mtt{Program(TopLevel body)}\\
&&&\mtt{TopLevel(List<FunDecl> fds, List<VarDecl> vds,}\\
&&&\mtt{\phantom{TopLevel(}List<SourceElement> stmts)}\\

\fd &::=& {\tt function} \ f \verb+(+(x\verb+,+)^*\verb+)+ \ \verb+{+\fd^*\ \vd^*\ \stmt^*\verb+}+
  & \mtt{FunDecl(Id name, Functional ftn)}\\
&&&\mtt{Functional(List<FunDecl> fds, List<VarDecl> vds,}\\
&&&\mtt{\phantom{Functional(}List<SourceElement> stmts, List<Id> params)}\\

\vd &::=& {\tt var} \ x & \mtt{VarDecl(Id name, Option<Expr> expr)}\\

% &&&\mtt{\phantom{FunDecl(}List<SourceElement> body)} \\
\stmt &::=& \verb+{+\stmt^*\verb+}+ & \mtt{Block(List<Stmt> stmts, boolean internal = false)}\\
& \mid & {\tt var} \ \vd(\verb+,+ \vd)^* \verb+;+ & \mtt{VarStmt(List<VarDecl> vds)}\\
& \mid & \verb+;+ & \mtt{EmptyStmt()}\\
& \mid & \expr \verb+;+ & \mtt{ExprStmt(Expr expr)}\\
& \mid & {\tt if} \ \verb+(+\expr\verb+)+ \ \stmt \ ({\tt else} \ \stmt)^?
& \mtt{If(Expr cond, Stmt trueBranch,}\\
&&&\mtt{\phantom{If(}Option<Stmt> falseBranch)}\\
& \mid &  {\tt switch} \ \verb+(+\expr\verb+)+ \ \verb+{+\cc^* \ ({\tt default} \verb+:+ \stmt^{*})^? \ \cc^* \verb+}+
& \mtt{Switch(Expr cond, List<Case> frontCases,}\\
&&&\mtt{\phantom{Switch(}Option<List<Stmt>> def, List<Case> backCases)}\\
& \mid & {\tt do} \ \stmt \ {\tt while} \ \verb+(+\expr\verb+)+ \verb+;+ & \mtt{DoWhile(Stmt body, Expr cond)}\\
  &\mid& {\tt while} \ \verb+(+\expr\verb+)+ \ \stmt & \mtt{While(Expr cond, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+\expr^?\verb+;+ \expr^?\verb+;+ \expr^? \verb+)+ \ \stmt
  & \mtt{For(Option<Expr> init, Option<Expr> cond,}\\
&&&\mtt{\phantom{For(}Option<Expr> action, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+ \lhs \ {\tt in} \ \expr \verb+)+ \ \stmt & 
\mtt{ForIn(LHS lhs, Expr expr, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+{\tt var} \ \vd(\verb+,+ \vd)^*\verb+;+ \expr^?\verb+;+ \expr^?\verb+)+ \ \stmt
  & \mtt{ForVar(List<VarDecl> vars, Option<Expr> cond,}\\
&&&\mtt{\phantom{ForVar(}Option<Expr> action, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+{\tt var} \ \vd \ {\tt in} \ \expr \verb+)+ \ \stmt & \mtt{ForVarIn(VarDecl var, Expr expr, Stmt body)}\\
& \mid & {\tt continue} \  \myid^{?} \verb+;+ & \mtt{Continue(Option<Label> target)}\\
& \mid & {\tt break} \  \myid^{?} \verb+;+ & \mtt{Break(Option<Label> target)}\\
& \mid & {\tt return} \ \expr^? \verb+;+ & \mtt{Return(Option<Expr> expr)}\\
& \mid & {\tt with} \ \verb+(+\expr\verb+)+ \ \stmt & \mtt{With(Expr expr, Stmt stmt)}\\
& \mid & 
l \; \verb+:+ \; \stmt & \mtt{LabelStmt(Label label, Stmt stmt)}\\
& \mid & {\tt throw} \ \expr \verb+;+ & \mtt{Throw(Expr expr)}\\
& \mid &
{\tt try} \verb+{+\stmt^*\verb+}+ ({\tt catch} \verb+(+\myid\verb+)+ \verb+{+\stmt^*\verb+}+)^? ({\tt finally} \verb+{+\stmt^*\verb+}+)^?
& \mtt{Try(Block body, Option<Catch> catchBlock,}\\
&&& \mtt{\phantom{Try(}Option<Block> fin)}\\
&&& \mtt{Catch(Id id, Block body)}\\
& \mid & {\tt debugger} \verb+;+ & \mtt{Debugger()}\\

\cc &::=& {\tt case} \ \expr \; \verb+:+ \; \stmt^{*} & \mtt{Case(Expr cond, Block body)}\\

\expr &::=& \expr\verb+,+ \ \expr & \mtt{ExprList(List<Expr> exprs)}\\
  &\mid& \expr \ \verb+?+ \ \expr \ \verb+:+ \ \expr & \mtt{Cond(Expr cond, Expr trueBranch, Expr falseBranch)}\\
  &\mid& \expr \ \inop \ \expr & \mtt{InfixOpApp(Expr left, Op op, Expr right)}\\
  &\mid& \preop \ \expr & \mtt{PrefixOpApp(Op op, Expr right)}\\
  &\mid& \lhs \ \postop & \mtt{UnaryAssignOpApp(LHS lhs, Op op)}\\
  &\mid& \lhs \ \aop \ \expr & \mtt{AssignOpApp(LHS lhs, Op op, Expr right)}\\
  &\mid& \lhs & \mtt{LHS()}\\
\end{array}
\]

\[
\begin{array}{llll}
\lhs &::=& \lit & \mtt{Literal()}\\
 &\mid& \myid & \mtt{VarRef(Id id)}\\
 &\mid& \verb+[+ (\expr^?\verb+,+)^* \ \verb+]+ & \mtt{ArrayExpr(List<Option<Expr>> elements)}\\
 &\mid& \verb+{+ (\member\verb+,+)^* \verb+}+ & \mtt{ObjectExpr(List<Member> members)}\\
 &\mid& \verb+(+ \expr \verb+)+ & \mtt{Parenthesized(Expr expr)}\\
 & \mid & {\tt function} \ \myid^?  \verb+(+(\myid\verb+,+)^*\verb+)+ \ \verb+{+\fd^*\ \vd^*\ \stmt^*\verb+}+ &
\mtt{FunExpr(Option<Id> name, Functional ftn)}\\
 %  \mtt{FunExpr(Option<Id> name, List<Id> params, List<VarDecl> vds, List<FunDecl> fds,}\\
 % &&&\mtt{\phantom{FunExpr(}List<SourceElement> body)} \\


 &\mid& \lhs \verb+[+ \expr \verb+]+ & \mtt{Bracket(LHS obj, Expr index)}\\
 &\mid& \lhs \verb+.+ \myid & \mtt{Dot(LHS obj, Id member)}\\
 &\mid& {\tt new} \ \lhs & \mtt{New(LHS lhs)}\\
 &\mid& \lhs \verb+(+ (\expr\verb+,+)^* \verb+)+ & \mtt{FunApp(LHS fun, List<Expr> args)} \\ \\

\lit &::=& {\tt this} & \mtt{This()}\\
 &\mid& {\tt null} & \mtt{Null()}\\
 &\mid& {\tt true} & \mtt{Bool(boolean bool)}\\
 &\mid& {\tt false} & \mtt{Bool(boolean bool)}\\
 &\mid& \num & \mtt{DoubleLiteral(ignoreForEquals String text, Double num)}\\
&&&\mtt{IntLiteral(BigInteger intVal, int radix)}\\
 &\mid& \str & \mtt{StringLiteral(String str, String quote)}\\
 &\mid& \reg & \mtt{RegularExpression(String reg)}\\ \\

\member &::=& \prop \ \verb+:+ \ \expr & \mtt{Field(Property prop, Expr expr)}\\
 &\mid& {\tt get}\ \prop \verb+() {+ \fd^*\ \vd^*\ \stmt^* \verb+}+ 
 & \mtt{GetProp(Property prop, Functional ftn)}\\
 &\mid& {\tt set}\ \prop \verb+(+ \myid \verb+) {+ \fd^*\ \vd^*\ \stmt^* \verb+}+
 & \mtt{SetProp(Property prop, Functional ftn)}\\ \\

\prop &::= & \myid & \mtt{PropId(Id id)}\\
 &\mid& \str & \mtt{PropStr(String str)}\\
 &\mid& \num & \mtt{PropNum(NumberLiteral num)}\\
\end{array}
\]

\[
\begin{array}{l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l}
\aop &::=&
\verb+=+ & \mid &
\verb+*=+ & \mid &
\verb+/=+ & \mid &
\verb+%=+ & \mid &
\verb!+=! & \mid &
\verb+-=+ & \mid &
\verb+<<=+ & \mid &
\verb+>>=+ & \mid &
\verb+>>>=+ & \mid &
\verb+&=+ & \mid &
\verb+^=+ & \mid &
\verb+|=+
\\

\inop &::=& \verb+&&+ & \mid & \verb+||+ & \mid & \verb+|+ & \mid & \verb+&+ & \mid & \verb+^+ & \mid & \verb+<<+ & \mid & \verb+>>+ & \mid & \verb+>>>+ 
 & \mid & \verb!+! & \mid & \verb+-+ & \mid & \verb+*+ & \mid & \verb+/+ & \mid & \verb+%+
 &\mid& \verb+==+ & \mid & \verb+!=+ & \mid & \verb+===+ & \mid & \verb+!==+ & \mid & \verb+<+ & \mid & \verb+>+ & \mid & \verb+<=+
 & \mid & \verb+>=+ \\
 & \mid &
\lefteqn{
 {\tt instanceof} \ \mid \ {\tt in} }\\

\preop &::=& \verb!++! & \mid & \verb+--+ & \mid & \verb+~+ & \mid & \verb+!+ & \mid & \verb!+! & \mid & \verb+-+ & \mid &
\lefteqn{
 {\tt delete} \ \mid \ {\tt void} \ \mid \ {\tt typeof} }\\

\postop &::=& \verb!++! & \mid & \verb+--+\\[1em]

\end{array}
\]


            % abstract SourceElement();
            % abstract Expr();
            % abstract Property();
            % abstract Name();
            %     abstract IdOrOpOrAnonymousName();
            %         abstract IdOrOp(String text);
            %             Id();
            %             Op();
            %         AnonymousFnName();
            % Label(Id id);

{\inred
\begin{itemize}
\item {\tt VarDecl}: The {\tt expr} field is {\tt None} after {\tt Hoister}.
\item {\tt VarStmt}, {\tt ForVar}, {\tt ForVarIn}: Removed by {\tt Hoister}.
\item {\tt RegularExpression}: Not yet supported.
\end{itemize}
}

{\inblue
\begin{itemize}
\item {\tt StmtUnit}: Internally generated statement unit by {\tt Hoister}.
\end{itemize}
}

% \let\cleardoublepage\relax
% \let\clearpage\relax

\chapter{IR}
\small
\[
\begin{array}{llll}
\ir\pgm & ::= & \ir\stmt^* & \mtt{IRRoot}\\
%\mtt{IRRoot(List<IRFunDecl> fds, List<IRVarStmt> vds,}\\
%&&&\mtt{\phantom{IRRoot(}List<IRStmt> irs)}\\

\ir\stmt & ::= & \irid \ \verb+=+ \ \ir\expr &
 \mtt{IRExprStmt(IRId lhs, IRExpr right, boolean ref = false)}\\

&\mid& \irid \ \verb+=+ \ {\sf delete}\ \irid
& \mtt{IRDelete(IRId lhs, IRId id)}\\

 &\mid& \irid \ \verb+=+ \ {\sf delete}\ \irid\verb+[+\irid\verb+]+
 & \mtt{IRDeleteProp(IRId lhs, IRId obj, IRId index)}\\

 &\mid& \irid\verb+[+\irid\verb+] =+ \ \irexpr & \mtt{IRStore(IRId obj, IRId index, IRExpr rhs)}\\
 &\mid& \irid \ \verb+=+ \ \verb+{+ (\ir\member\verb+,+)^* \verb+}+
 & \mtt{IRObject(IRId lhs, List<IRMember> members,}\\
&&&\mtt{\phantom{IRObject(}Option<IRId> proto)}\\
 &\mid& \irid \ \verb+=+ \ \verb+[+ (\irexpr\verb+,+)^* \verb+]+ & \mtt{IRArray(IRId lhs, List<Option<IRExpr>> elements)}\\
&&&\mtt{IRArgs(IRId lhs, List<Option<IRExpr>> elements)}\\

 &\mid& \irid \ \verb+=+ \ \irid\verb+(+\irid\verb+,+\irid\verb+)+
 & \mtt{IRCall(IRId lhs, IRId fun, IRId thisB, IRId args)}\\
 &\mid& \irid \ \verb+=+ \ \irid\verb+(+\irid(\verb+,+\irid)^?\verb+)+
& \mtt{IRInternalCall(IRId lhs, IRId fun, IRExpr first,}\\
&&&\mtt{\phantom{IRInternalCall(}Option<IRId> second)}\\
&&&{\inblue \mtt{toObject}, \mtt{toNumber}, \mtt{isObject},
\mtt{getBase}, \mtt{iteratorInit},}\\
&&&{\inblue \mtt{iteratorHasNext}, \mtt{iteratorKey}}\\

 &\mid& \irid \ \verb+=+ \ {\sf new}\ \irid\verb+(+(\irid\verb+,+)^*\verb+)+
 & \mtt{IRNew(IRId lhs, IRId fun, List<IRId> args)}\\
 &\mid& \irid \ \verb+=+ \ {\sf function} \ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
& \mtt{IRFunExpr(IRId lhs, IRFunctional ftn)}\\
&&&\mtt{IRFunctional(IRId name, List<IRId> params,}\\
&&&\mtt{\phantom{IRFunctional(}List<IRStmt> args, List<IRFunDecl> fds,}\\
&&&\mtt{\phantom{IRFunctional(}List<IRVarStmt> vds, List<IRStmt> body)}\\

 &\mid& {\sf function} \ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 & \mtt{IRFunDecl(IRFunctional ftn)}\\

 &\mid& \irid \ \verb+=+ \ {\sf eval}\verb+(+\ir\expr\verb+)+ & \mtt{IREval(IRId lhs, IRExpr arg)}\\
 &\mid& {\sf break} \ \irid & \mtt{IRBreak(IRId label)}\\
 &\mid& {\sf return} \ \irexpr^?& \mtt{IRReturn(Option<IRExpr> expr)}\\
 &\mid& {\sf with} \ \verb+(+\irid\verb+)+ \ \ir\stmt & \mtt{IRWith(IRId id, IRStmt stmt)}\\

 & \mid & \ir{l} \; \verb+: {+ \; \ir\stmt \; \verb+}+
 & \mtt{IRLabelStmt(IRId label, IRStmt stmt)}\\


 &\mid& {\sf var} \ \irid& \mtt{IRVarStmt(IRId lhs)}\\
 &\mid& {\sf throw} \ \irexpr& \mtt{IRThrow(IRExpr expr)}\\
 &\mid& {\ir\stmt}^*& \mtt{IRSeq(List<IRStmt> stmts)}\\
 &\mid& {\sf if} \ \verb+(+\irexpr\verb+)+\ {\sf then} \ \ir\stmt \ ({\sf else} \ \ir\stmt)^?
& \mtt{IRIf(IRExpr expr, IRStmt trueB, Option<IRStmt> falseB)}\\
 &\mid& {\sf while} \ \verb+(+\irexpr\verb+)+\ \ir\stmt& \mtt{IRWhile(IRExpr cond, IRStmt body)}\\
 &\mid& {\sf try} \ \verb+{+ \ir\stmt \verb+}+ \
({\sf catch} \ \verb+(+\irid\verb+){+ \ir\stmt \verb+}+)^? \
({\sf finally} \ \verb+{+ \ir\stmt \verb+}+)^?
& \mtt{IRTry(IRStmt body, Option<IRId> name,}\\
&&&\mtt{\phantom{IRTry(}Option<IRStmt> catchB, Option<IRStmt> finallyB)}\\
&\mid& \open {\ir\stmt}^* \close & \mtt{IRStmtUnit(List<IRStmt> stmts)}\\

\ir\expr &::=&
 \irexpr \ \inop \irexpr & \mtt{IRBin(IRExpr first, IROp op, IRExpr second)}\\
 &\mid& \preop \irexpr & \mtt{IRUn(IROp op, IRExpr expr)}\\
 &\mid& \irid\verb+[+\ir\expr\verb+]+ & \mtt{IRLoad(IRId obj, IRExpr index)}\\
 &\mid& \irid& \mtt{IRUserId(String text)}\\
 &\mid& \newvar{x}& \mtt{IRTmpId(String text)}\\
 &\mid& \ir\num & \mtt{IRNumber(ignoreForEquals String text, Double num)}\\
 &\mid& \ir\str & \mtt{IRString(String str)}\\
 &\mid& {\sf true} & \mtt{IRBool(boolean bool)}\\
 &\mid& {\sf false} & \mtt{IRBool(boolean bool)}\\
 &\mid& {\sf undefined} & \mtt{IRUndef()}\\
 &\mid& {\sf null} & \mtt{IRNull()}\\
 &\mid& {\sf this} & \mtt{IRThis()}
\end{array}
\]

\[
\begin{array}{llll}
\ir\member &::=& \irid \ \verb+:+ \ \irexpr & \mtt{IRField(IRId prop, IRExpr expr)}\\
 &\mid& {\tt get}\ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 &\mtt{IRGetProp(IRFunctional ftn)}\\
 &\mid& {\tt set}\ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 &\mtt{IRSetProp(IRFunctional ftn)}\\

\end{array}
\]

Assumptions and notations:
\begin{itemize}
\item Functions and variables are hoisted to their closest enclosing functions
or the top level via {\tt Hoister}.
\item Identifiers and labels that exist in the source program,
except when they appear at top level or within the {\tt with} statement,
are already disambiguated via {\tt Disambiguator},
so that they have unique names.
\item We use $\env$ to disambiguate the generated labels and temporary variables in the AST to IR translation.
For the presentation brevity, we simply add the newly generated names to $\env$.
\begin{itemize}
\item In the actual implementation, we need to create a unique id for each generated name and
add the binding information from the general name to the unique id to $\env$.
For example, when we say ``$\env; \newvar{break}$'',
we actually create a unique id for $\newvar{break}$, say $\newvar{break}_{42}$, and add it to $\env$ as $\env; \newvar{break} \mapsto \newvar{break}_{42}$.
When we look up the environment by $\env(\newvar{break})$, the unique $\newvar{break}_{42}$ is returned.
\item In the scope when the generated name is created, we don't add it to the environment but use the unique id instead of the general name.
For example, when we say ``$\newvar{eq}\ \verb+=+\ \env(\newvar{val}) \verb+===+ \newvar{break};$'',
we create a unique id for \newvar{eq}, say $\newvar{eq}_{910157}$, and it is acually
``$\newvar{eq}_{910157}\ \verb+=+\ \env(\newvar{val}) \verb+===+ \newvar{break}_{42};$''.
\item To be clear, we use blue for the binding sites of such names and red for the use sites of such names.
\end{itemize}
\item We denote a list as a possibly empty, semicolon-separated sequence, enclosed by $\langle$ and $\rangle$.
\item We denote a series of list appends as superscripted $*$ such as $\stmt^*$.
\item We denote a fresh variable name as $\newvar{}$ and its variants.
\item We abuse our notations by mixing semicolon-separated sequences and lists.
\item We use the following:\\
\verb+===+, {\sf \ensuremath{\diamond}toObject}, {\sf \ensuremath{\diamond}toNumber}, {\sf \ensuremath{\diamond}isObject},
{\sf \ensuremath{\diamond}iteratorInit}, {\sf \ensuremath{\diamond}iteratorHasNext}, {\sf \ensuremath{\diamond}iteratorNext},
% {\sf startsWith},
{\sf \ensuremath{\diamond}global}, {\sf \ensuremath{\diamond}getBase}
\item To denote an AST-level statement granularity in the translated IR statements,
we use {\tt IRStmtUnit} which is represented as green angle brackets {\ingreen $\open\ \close$} in this document.
To reduce the number of temporary variables, we use global variables to denote constants such as {\sf 1} and
{\sf true} which is represented in green {\ingreen\sf 1} and  {\ingreen\sf true} in this document.
\item We wrap a possibly identical assignment with a box so that the actual implementation, {\tt Translator}, can eliminate identical assignments.
\end{itemize}


\chapter{AST to IR}
\small
\[
\begin{array}{lll}
\env&:& \verb+Env+\\
\atoiP&:& \verb+Program -> IRRoot+\\
\atoiFD&:& \verb+FunDecl -> Env -> IRFunDecl+\\
\atoiVD&:& \verb+VarDecl -> Env -> IRVarStmt+\\
\atoiS&:& \verb+Stmt -> Env -> IRStmtUnit+\\
%\atoiCC& \verb+Case -> Env -> Option[Stmt] => List[IRStmt]+\\
\atoiC&:& \verb+List[Case] * Option[List[Stmt]] * List[Case] -> Env ->+\\
          && \verb+List[Option[Expr] * IRId] -> IRStmt+\\
\atoiSC&:& \verb+List[Option[Expr] * IRId] -> Env -> IRStmt+\\
\atoiLVAL&:& \verb+Expr -> Env -> List[IRStmt] -> IRExpr -> boolean -> List[IRStmt] * IRExpr+\\
\atoiE&:& \verb+Expr -> Env -> IRId -> List[IRStmt] * IRExpr+\\
\atoiLHS&:& \verb+LHS -> Env -> IRId -> List[IRStmt] * IRExpr+\\
\atoiLIT&:& \verb+LIT -> Env -> IRId -> List[IRStmt] * IRExpr+\\
\atoiM&:& \verb+Member -> Env -> IRId -> List[IRStmt] * IRMember+\\
\atoiPR&:& \verb+Property -> IRId+
\end{array}
\]

\[
%\begin{array}{l@{}l@{~}l}
\begin{array}{lll}
\atoiPf{\fd^*\ \vd^*\ \stmt^*}
&=&\langle (\atoiFDf{\fd}{\emptyenv})^*\ (\atoiVDf{\vd}{\emptyenv})^*\ (\atoiSf{\stmt}{\emptyenv})^* \rangle
\\[1em]

\atoiFD\lbr{ {\tt function} \ f \verb+(+(x\verb+,+)^*\verb+)+ \ \verb+{+ \fd^* \vd^* \stmt^* \verb+}+}\rbr(\env)
&=&
{\sf function} \ \ir{f} \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad
(\atoiFDfd{\fd})^*\\
&&\quad
({\sf var}\ \ir{x_i})^*\\
&&\quad
(\atoiVDf{\vd}\env)^*\\
&&\quad
(\ir{x_i} = {\inred\newvar{arguments}}\verb+["i"]+)^*
\quad\note{where \ir{x_i} is not the name of any of \mbox{fd}}\\
\\
&&\quad
(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+
\\
\lefteqn{\note{
A function always receives explicit ``this'' and ``arguments'' arguments
so that the desugaring of {\tt this} and {\tt arguments}}}\\
\lefteqn{\note{ is correct.
Currently, ``arguments'' denotes copies of the arguments instead of their aliases.
An early exit from a function
}}\\
\lefteqn{\note{
using {\tt return} statements is
rewritten as a non-local jump to the label \newvar{return}.
}}\\[.5em]

% var
\atoiVD\lbr {\tt var} \ x \rbr(\env)
&=&  {\sf var}\ \ir{x}\\[1em]



% block
\atoiS\lbr \verb+{+\stmt^*\verb+}+ \rbr(\env)
&=& \open(\atoiSfd{\stmt})^*\close
\\

% empty
\atoiS\lbr \verb+;+ \rbr(\env)
&=& \open \close
\\

% expr stmt
\atoiS\lbr e\verb+;+ \rbr(\env)
&=& \mbox{LET\ } (\ir\stmt^*, \ir\expr) = \atoiEfd{e}({\inred\newvar{\_}})\\
& & \mbox{IN}\hspace*{1.2em}
\open\ir\stmt^*\verb+;+\ \fbox{{\inred\newvar{\_}}\ {\tt =} \ \irexpr}\close

%\open\atoiEfd{e}({\inblue\newvar{\_}})\close
\\


% if &&
\emph{\inblue Candidate for optimization}
\\
\atoiS\lbr {\inblue\verb+if+ \ \verb+(+e_1 \verb+&&+ e_2\verb+)+\ s_1\ (\verb+else+\ s_2)^? }\rbr(\env)
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
& & \mbox{IN}\hspace*{1.2em}
\open\irstmt_1^*\verb+;+\
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\sf if\ (}{\irexpr_1}{\sf )}
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\sf then}\ \langle \irstmt_2^*\verb+;+\
{\sf if\ (} {\irexpr_2} {\sf )\ then\ } \verb+{+\atoiSfd{s_1}\verb+;+\
{\sf break}\ {\inred\newvar{label}}\verb+}+\rangle\verb+;+
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
(\atoiSfd{s_2})^?
\verb+}+\close\\

% label : {
%   if (e1) {
%     if (e2) {
%       s_1
%       break label
%     }
%   }
%   s_2
% }


% if ||
\emph{\inblue Candidate for optimization}
\\
\atoiS\lbr {\inblue\verb+if+ \ \verb+(+e_1 \verb+||+ e_2\verb+)+\ s_1\ (\verb+else+\ s_2)^? }\rbr(\env)
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
& & \mbox{IN}\hspace*{1.2em}
\open\irstmt_1^*\verb+;+\
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label_2}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\inblue \newvar{label_1}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (}{\irexpr_1}{\sf )}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf then\ break}\ {\inred\newvar{label_1}}\verb+;+\ \irstmt_2^*\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (} {\irexpr_2} {\sf )\ then\ } {\sf break}\ {\inred\newvar{label_1}}\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
(\atoiSfd{s_2}\verb+;+\ {\sf break})^?\ {\inred\newvar{label_2}}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
\verb+};+\ \atoiSfd{s_1}\verb+}+\close\\

% label2: {
%   label1: {
%     if (e1) {
%       break label1
%     }
%     if (e2) {
%       break label1
%     }
%     s_2
%     break label2
%   }
%   s_1
% }


% \atoiS\lbr \verb+if+ \ \verb+(+e_1 \verb+||+ e_2\verb+)+\ s_1\ (\verb+else+\ s_2)^? \rbr(\env)
% &=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
% & & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
% & & \mbox{IN}\hspace*{1.2em}
% \open\irstmt_1^*\verb+;+\ \irstmt_2^*\verb+;+\\
% & & \phantom{\mbox{IN}\hspace*{1.2em}\open}
% {\sf if\ (} {\irexpr_1} {\sf )\ then\ } \atoiSfd{s_1}\\
% & & \phantom{\mbox{IN}\hspace*{1.2em}\open{\sf if\ (} {\irexpr_1} {\sf )\ }}
% {\sf else\ } {\sf if\ (} {\irexpr_2} {\sf )\ then\ } \atoiSfd{s_1}\ 
% ({\sf else\ } \atoiSfd{s_2})^?
% \close\\
% % if (e1) {
% %   s_1
% % } else if (e2) {
% %   s_1
% % } else s_2



\end{array}
\]

\[
\begin{array}{l@{}l@{~}l}

% if
\atoiS\lbr \verb+if+ \ \verb+(+e \verb+)+\ s_1\ (\verb+else+\ s_2)^? \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{new}})\\
& & \mbox{IN}\hspace*{1.2em}
\open\irstmt^*\verb+;+\
{\sf if\ (} {\irexpr} {\sf )\ then\ } \atoiSfd{s_1}\ ({\sf else\ } \atoiSfd{s_2})^?
\close\\



% \open
% \atoiEfd{e}({\inblue\newva})\\
% &&
% \phantom{\langle}
% {\inblue\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva});}
% \\
% &&
% \phantom{\langle}
% {\sf if (} {\inred\newvb} {\sf )\ then\ } {\sf IRSeq(}\ \atoiSfd{s_1}\ {\sf )}\
% ({\sf else\ } {\sf IRSeq(}\ \atoiSfd{s_2}\ {\sf )})^?
% \close
% \\


%% 2nd trial
%%
% %% switch
% \atoiS\lbr \verb+switch(+e \verb+){+\cc_1^*\ (\verb+default:+s)^?\ \cc_2^* \verb+}+ \rbr(\env)
% &=&\langle
% {\inblue\newvar{break}} \; \verb+:+ \; \verb+{+ \ {\sf IRSeq(} \langle
% \\&&
% \quad
% \atoiEfd{e}({\inblue\newvar{val}}) \verb+;+\
% {\inblue\newvar{found}}\ \verb+=+ \ {\sf false} \verb+;+\
% {\inblue\newvar{default}}\ \verb+=+ \ {\sf false} \verb+;+
% \\&&
% \quad
% (\atoiCCf{\cc_1}{\env; \newvar{break}; \newvar{val}; \newvar{found}; \newvar{default}})^*
% \\&&
% \quad
% (
% {\sf if\ (} {\inred\newvar{found}} {\sf )\ then}\ {\sf IRSeq(} \langle
% \atoiSf{\stmt}{\env; \newvar{break}}\verb+;+\
% {\inred\newvar{default}}\ \verb+=+ \ {\sf true}
% \rangle{\sf)})^?
% \\&&\quad
% (\atoiCCf{\cc_2}{\env; \newvar{break}; \newvar{val}; \newvar{found}; \newvar{default}})^*
% \\&&
% \quad
% {\inblue\newvar{cond}}\ \verb+=+ \ {\inred\newvar{default}}\ \verb+||+ {\inred\newvar{found}}\verb+;+
% \\&&
% \quad
% (
% {\sf if\ (} {\inred\newvar{cond}} {\sf )\ then}\ {\sf IRSeq(} \emptyenv{\sf)}
% \\&&\quad\phantom{(}
% {\sf else\ IRSeq(} \langle
% \atoiSf{\stmt}{\env; \newvar{break}}\verb+;+\
% {\inred\newvar{default}}\ \verb+=+ \ {\sf true}\verb+;+
% \\&&\quad\phantom{({\sf else\ IRSeq(} \langle}
% (\atoiCCf{\cc_2}{\env; \newvar{break}; \newvar{val}; \newvar{found}; \newvar{default}})^*
% \rangle{\sf)})^?
% \\&&
% \rangle
% {\sf )}\verb+}+\rangle
% \\

% \atoiCC\lbr {\tt case} \ \expr \; \verb+:+ \; \stmt^{*} \rbr(\env)
% &=&\langle
% {\inblue\newvar{cond_1}}\ \verb+=+ \ \env(\newvar{default})\ \verb+||+ \env(\newvar{found})\verb+;+
% \\&&\phantom{\langle}
% {\sf if\ (}{\inred\newvar{cond_1}}{\sf)\ then\ IRSeq(}\emptyenv{\sf)}\\
% &&\phantom{\langle}
% {\sf else\ IRSeq(}\langle\ \atoiEfd{\expr}({\inblue\newvar{cond_2}})\verb+;+\\
% &&\phantom{\langle{\sf else\ IRSeq(}\langle\ }
% {\inblue\newvar{eq}}\ \verb+=+\ \env(\newvar{val}) \verb+===+ {\inred\newvar{cond_2}}\verb+;+\\
% &&\phantom{\langle{\sf else\ IRSeq(}\langle\ }
% {\sf if\ ({\inred\newvar{eq}})\ then}\ \env(\newvar{found}) \verb+=+ {\sf true}\ \rangle{\sf)}\verb+;+\\
% &&\phantom{\langle}
% {\inred\newvar{cond_1}}\ \verb+=+ \ \env(\newvar{default})\ \verb+||+ \env(\newvar{found})\verb+;+
% \\&&\phantom{\langle}
% {\sf if\ (}{\inred\newvar{cond_1}}{\sf)\ then\ IRSeq(}\langle\
% (\atoiSfd{\stmt})^*\ \rangle{\sf )}\rangle
% \\


%% 1st trial
%%
% switch
% \atoiS\lbr \verb+switch(+e \verb+){+\cc_1^*\ (\verb+default:+s)^?\ \cc_2^* \verb+}+ \rbr(\env)
% &=&\langle
% {\inblue\newvar{break}} \; \verb+:+ \; \verb+{+ \ {\sf IRSeq(} \langle
% \\&&
% \quad
% \atoiEfd{e}({\inblue\newvar{val}}) \verb+;+
% {\inblue\newvar{testing}}\ \verb+=+ \ {\sf true} \verb+;+
% {\inblue\newvar{keepgoing}}\ \verb+=+ \ {\sf true} \verb+;+
% \\&&
% \quad
% (\atoiCCf{\cc_1}{\env; \newvar{break}; \newvar{val}; \newvar{testing}})^*
% \\&&
% \quad
% ({\sf while\ (} {\inred\newvar{keepgoing}} {\sf )}
% \\&&
% \quad\quad
% {\sf IRSeq(}\langle\
%   {\sf if\ (} {\inred\newvar{testing}} {\sf )\ then}\
%   {\inblue\newvar{\_}}\; \verb+=+ \; {\tt undefined}\
%   {\sf else}\ {\sf IRSeq(}\ \atoiSfd{s}\ {\sf )}
% \verb+;+
% \\&&
% \quad\quad\quad\quad\quad
% \phantom{\langle}
%   (\atoiCCf{\cc_2}{\env; \newvar{break}; \newvar{val}; \newvar{testing}})^*
% \\&&
% \quad\quad\quad\quad\quad
% \phantom{\langle}
%   {\sf if\ (} {\inred\newvar{testing}} {\sf )\ then}\
%   {\inred\newvar{testing}}\; \verb+=+ \; {\sf false}\
%   {\sf else}\ {\inred\newvar{keepgoing}}\ \verb+=+ {\sf false}
% \rangle
% {\sf )}
% )^?
% \\&&
% \rangle
% {\sf )}\verb+}+\rangle
% \\


% \atoiCC\lbr {\tt case} \ \expr \; \verb+:+ \; \stmt^{*} \rbr(\env)
% &=&
% \langle
% {\sf if\ (}\env(\newvar{testing}){\sf)}\\
% &&
% \phantom{\langle}
% {\sf then\ IRSeq(}\langle
% \atoiEfd{\expr}({\inblue\newvar{cond}});\\
% &&
% \phantom{\langle{\sf then\ IRSeq(}\langle}
% {\inblue\newvar{eq}}\ \verb+=+\ \env(\newvar{val}) \verb+===+ {\inred\newvar{cond}};\\
% &&
% \phantom{\langle{\sf then\ IRSeq(}\langle}
% {\sf if\ ({\inred\newvar{eq}})\ then\ \env(\newvar{testing}) \verb+=+ false} \rangle{\sf);}\\
% &&
% \phantom{\langle}
% {\sf if\ (}\env(\newvar{testing}){\sf)\ then\ {\inblue\newvar{\_}} \verb+=+ undefined\
% else\ IRSeq(}\ (\atoiSfd{\stmt})^*\ {\sf )}
% \rangle
% \\

% \lefteqn{\note{
% We introduce one label \newvar{break} and two variables, \newvar{testing} and \newvar{keepgoing},
% to denote the current status.}}\\
% \lefteqn{\note{
% Initially \newvar{testing} is {\sf true} meaning that the conditions are to be
% evaluated,}}\\
% \lefteqn{\note{
% and \newvar{keepgoing} is also {\sf true} meaning that the {\tt default}
% case is to be evaluated.
% }}\\
% \lefteqn{\note{
% \newvar{testing} is set to {\sf false} when a matching case is found, or no matching case is found
% after the lexically last case.
% }}\\
% \lefteqn{\note{
% In the latter case, the control flow moves back to the start of the {\tt default} case, if any,
% via {\sf while}.
% }}\\
% \lefteqn{\note{
% When \newvar{testing} is {\sf false} and the control flow reaches the end of {\tt switch},
% \newvar{keepgoing} is set to {\sf false} so that the {\sf while} loop terminates.
% }}\\


%% switch
\atoiS\lbr \verb+switch (+e \verb+) {+\cc_1^*\ (\verb+default:+s^*)^?\ \cc_2^* \verb+}+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{val}})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open\quad}
\irstmt^*\verb+;+\ \fbox{{\inred\newvar{val}} \; {\tt =} \; \irexpr{\tt;}}
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open\quad}
 \atoiC\lbr({\sf rev}\ \cc_2^*) (s^*)^? ({\sf rev}\  \cc_1^*)\rbr
({\env; {\inred\newvar{break}}; {\inred\newvar{val}}})\verb+}+\close
\\

%% case
\atoiC \lbr ({\tt case} \ \expr \; \verb+:+ \; \stmt_1^{*})::cc_2^{*} \ (\stmt_2^*)^?\  cc_1^{*} \rbr
(\env)(c^{*})
&=&\langle
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+
  \atoiC \lbr cc_2^{*} \ (\stmt_2^*)^{?}\  cc_1^{*} \rbr(\env)(({e,\inred \newvar{label}})::c^{*}) \verb+};+
\\&&\phantom{\langle}
 (\atoiS\lbr \stmt_1 \rbr(\env))^{*}
\rangle
\\
\atoiC \lbr () \ (\stmt^{*})^{?}\  cc_1^{*} \rbr(\env)(c^{*})
&=&\langle
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+
  \atoiC \lbr () \ ()\  cc_1^{*} \rbr(\env)(c^{*}@[({(),\inred \newvar{label}})])\verb+};+
\\&&\phantom{\langle}
 ((\atoiS\lbr \stmt \rbr(\env))^{*})^{?}
\rangle
\\
\atoiC \lbr () \ () \ ({\tt case} \ \expr \; \verb+:+ \; \stmt^{*})::cc_1^{*} \rbr(\env)(c^{*})
&=&\langle
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+
  \atoiC \lbr () \ ()\  cc_1^{*} \rbr(\env)(({e,\inred \newvar{label}})::c^{*}) \verb+};+
\\&&\phantom{\langle}
 (\atoiS\lbr \stmt \rbr(\env))^{*}
\rangle
\\
\atoiC \lbr () \ () \ () \rbr(\env)((e, \ir{l})^{*})
&=&\langle
  \atoiSC \lbr (e,\ir{l})^{*} \rbr(\env)\verb+;+
\\&&\phantom{\langle}
   {\sf break}\ \env(\newvar{break})
 \rangle
\\
\atoiSC \lbr (e,\ir{l})::(c^{*}) \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{cond}})\\
& & \mbox{IN}\hspace*{1.2em}
\langle\irstmt^*\verb+;+\
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
 {\sf if\ (}\env(\newvar{val}) \; \verb+===+ \; \irexpr
{\sf)\ then\ break}\ \ir{l}\ {\sf else\ }\atoiSC\lbr c^{*}\rbr(\env)\rangle
\\

\atoiSC \lbr [((),\ir{l})] \rbr(\env)
&=&\langle
 {\sf break}\ \ir{l}\rangle
\\
\atoiSC \lbr () \rbr(\env)
&=&\langle\rangle
\\
\lefteqn{\note{
Where $c$ is either $(\expr, \ir{l})$ or $((), \ir{l})$.
}}\\\\


%% do-while
\atoiS\lbr \verb+do+\ s\  \verb+while (+ e \verb+);+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\
% &&
% \qquad\qquad
% {\inblue\newvar{cond}}\ \verb+=+\ {\sf true;}
% \\
&&
\qquad\qquad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+
\\
&&
\qquad\qquad
\irstmt^*\verb+;+
%\fbox{{\inred\newva} {\tt =} \irexpr}
\\
&&
\qquad\qquad
{\sf while\ (}\irexpr{)}\ \verb+{+
\\
&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+
\\
&&
\qquad\qquad\quad
\irstmt^*\verb+;+
%\fbox{{\inred\newva} {\tt =} \irexpr}
\\
&&\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\

%% while
\atoiS\lbr  \verb+while (+ \expr \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
\irstmt^*\verb+;+
%%%\fbox{{\inred\newva} {\tt =} \irexpr}
%\atoiEfd{\expr}({\inblue\newva}) \verb+;+
% \\&&\quad
% {\inblue\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva});}
\\&&
\qquad\qquad
{\sf while\ (}\irexpr{)} \;\verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}}\verb+};+
\\&&
\qquad\qquad\quad
\irstmt^*\verb+;+
%%%\fbox{{\inred\newva} {\tt =} \irexpr}
% \\&&
% \qquad\qquad\quad
% \atoiEfd{e}({\inred\newva}) \verb+;+
% \\&&\quad\quad
% {\inred\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva})}
\\&&
\qquad\qquad\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\


%% for-none
\atoiS\lbr  \verb+for (+ e_1^? \verb+;+ \verb+;+e_3^? \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } ((\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inred\newvar{\_}}))^?\\
& & \phantom{\mbox{LET\ }} ((\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}({\inred\newvar{\_}}))^?\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
(\irstmt_1^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_1$})^?
\\&&
\qquad\qquad
{\sf while\ ({\ingreen true})} \; \verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}}\verb+};+
\\&&
\qquad\qquad\quad
(\irstmt_3^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_3$})^?
%(\atoiEfd{e_3}({\inblue\newvar{\_}}) \verb+;+)^?
\\&&\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\



%% for-some
\atoiS\lbr  \verb+for (+ e_1^? \verb+;+e_2 \verb+;+e_3^? \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } ((\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inred\newvar{\_}}))^?\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
& & \phantom{\mbox{LET\ }} ((\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}({\inred\newvar{\_}}))^?\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
(\irstmt_1^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_1$})^?
\\&&
\qquad\qquad
\irstmt_2^*\verb+;+
%%%\fbox{{\inred\newvb} {\tt =} $\irexpr_2$}\verb+;+
%\atoiEfd{e_2}({\inblue\newvb}) \verb+;+
% \\&&\quad
% {\inblue\newvc}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newvb});}
\\&&
\qquad\qquad
{\sf while\ (}\irexpr_2{)} \; \verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+
\\&&
\qquad\qquad\quad
(\irstmt_3^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_3$})^?
%(\atoiEfd{e_3}({\inblue\newvc}) \verb+;+)^?
\\&&
\qquad\qquad\quad
\irstmt_2^*\verb+;+
%%%\fbox{{\inred\newvb} {\tt =} $\irexpr_2$}\verb+;+
%\atoiEfd{e_2}({\inred\newvb}) \verb+;+
% \\&&\quad\quad
% {\inred\newvc}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newvb});}
\\&&
\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\




\end{array}
\]

\[
\begin{array}{l@{}l@{~}l}

%% for-in
\atoiS\lbr  \verb+for (+ \lhs\ \verb+in+\ e \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&\qquad\qquad
\irstmt^*\verb+;+
%%%\fbox{{\inred\newva} {\tt =} \irexpr}
\\&&\qquad\qquad
  {\inblue\newvar{obj}} \ \verb+=+\ {\sf \ensuremath{\diamond}toObject}\verb+(+\irexpr\verb+)+\verb+;+\\
&&\qquad\qquad
  {\inblue\newvar{iterator}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorInit(}{\inred\newvar{obj}}{\sf)}\verb+;+
\\&&\qquad\qquad
  {\inblue\newvar{cond_1}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorHasNext(}{\inred\newvar{obj}}\verb+,+ {\inred\newvar{iterator}}{\sf)}\verb+;+
\\
&&\qquad\qquad
  {\sf while} \ \verb+(+{\inred\newvar{cond_1}}\verb+) {+\\
&&\qquad\qquad\quad
    {\inblue\newvar{key}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorNext(}{\inred\newvar{obj}}\verb+,+ {\inred\newvar{iterator}}{\sf)}\verb+;+
\\&&\qquad\qquad\quad
      \atoiLVALf{\lhs}{\env}(;\ {\inred\newvar{key}})({\rm false}).\_1\verb+;+\\
&&\qquad\qquad\quad
      {\inblue\newvar{continue}}\verb+:{+ \atoiSf{\stmt}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+\\
&&\qquad\qquad\quad
  {\inred\newvar{cond_1}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorHasNext(}{\inred\newvar{obj}}\verb+,+ {\inred\newvar{iterator}}{\sf)}\verb+;+
\\
&&\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\


% 
% \atoiS\lbr  \verb+for (var+ \ (vd,)^*\verb+,+e_1^? \verb+,+e_2^? \verb+)+\ s\rbr(\env)
% &=&
% 
% \langle
% (\atoiVDfd{vd})^*\verb+;+\
% \atoiS\lbr  \verb+for (+ \verb+,+e_1^? \verb+,+e_2^? \verb+)+\ s\rbr(\env)
% \rangle
% \\


% \atoiS\lbr
% \verb+for (var+ \ x \ \verb+in+ \ \expr \verb+)+ \ \stmt
% \rbr(\env)
% &=&
% \atoiS\lbr
% \verb+for (+ x \ \verb+in+ \ \expr \verb+)+ \ \stmt
% \rbr(\env)
% \\

% \atoiS\lbr
% \verb+for (var+ \ x \ \verb+=+ \ \expr \ \verb+in+ \ \expr' \verb+)+ \ \stmt
% \rbr(\env)
% &=&
% \atoiS\lbr
% \verb+{+ \
% x \ \verb+=+ \ \expr \verb+;+ \
% \verb+for (+ x \ \verb+in+ \ \expr' \verb+)+ \ \stmt
% \ \verb+}+
% \rbr(\env)
% \\


% continue 1
\atoiS\lbr  \verb+continue;+ \rbr(\env)
&=&\open
{\sf break}\ \env(\newvar{continue})
\close\\


% continue 2
\atoiS\lbr  \verb+continue+ \ l\verb+;+ \rbr(\env)
&=&\open
%{\sf break}\ \env(\newvar{continue})
{\sf break}\ \ir{l}
\close\\


%% break 1
\atoiS\lbr  \verb+break;+\rbr(\env)
&=&\open
{\sf break}\ \env(\newvar{break})
\close\\


%% break 2
\atoiS\lbr  \verb+break+ \ l\verb+;+ \rbr(\env)
&=&\open
{\sf break}\ \ir{l}
\close\\


%% return 1
\atoiS\lbr  \verb+return;+ \rbr(\env)
&=&\open
{\sf return}
\close\\


%% return 2
\atoiS\lbr  \verb+return+ \ e \verb+;+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\langle\irstmt^*\verb+;+\
{\sf return}\ \irexpr
\close\\

%
% \atoiS\lbr  \verb+with(+ e \verb+)+\ s \rbr(\env)
% &=&\langle
% \atoiEfd{e}(\newva) \verb+;+
% \\&&
% \phantom{\langle}
% \newvb\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(\newva);}
% \\&&
% \phantom{\langle}
% \atoiS\lbr s\rbr(\env\verb+;+\;\newvb)\rangle
% \\



%% with
\atoiS\lbr  \verb+with (+ e \verb+)+\ s \rbr(\env)
&=& \mbox{LET\ } (\ir\stmt^*, \ir\expr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open\ir\stmt^*\verb+;+\
\\&& \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr{\sf);}
\\&& \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\sf with\ (}{\inred\newvb}{\sf)}\
\atoiS\lbr s\rbr(\env)
\close
\\

%% labelled statement
\atoiS\lbr  l\ \verb+:+\ s \rbr(\env)
&=& \open
\ir{l}\ \verb+:+\ \verb+{+\ \atoiSfd{s} \ \verb+}+\close
\\

%% throw
\atoiS\lbr \verb+throw+\ e \verb+;+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \ir\expr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open\ir\stmt^*\verb+;+\
{\sf throw}\ \irexpr
\close
\\

%% try
\atoiS\lbr \verb+try {+s_1^* \verb+}+\
  (\verb+catch(+x \verb+){+s_2^* \verb+}+)^?
  (\verb+finally {+s_3^* \verb+}+)^? \rbr(\env)
&=&\open
{\sf try} \ \verb+{+ (\atoiSfd{s_1})^* \verb+}+
\\&&\phantom{\langle}
(\verb+catch(+\ir{x} \verb+){+ (\atoiSfd{s_2})^* \verb+}+)^?
\\&&\phantom{\langle}
(\verb+finally {+ (\atoiSfd{s_3})^* \verb+}+)^?
\close
\\

\atoiS\lbr \verb+debugger;+ \rbr(\env)
&=&\langle\rangle
\\[1em]


%%% Definitions of LVAL
\atoiLVAL\lbr \verb+(+\expr\verb+)+\rbr(\env)(\ir{\stmt}^*; \ir{\expr}')(\kold)
&=&
\atoiLVAL\lbr \expr\rbr(\env)(\ir{\stmt}^*; \ir{\expr}')(\kold)
\\

\atoiLVAL\lbr x \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
&=&\mbox{IF keepOld THEN\ }
(\langle
{\inblue\newvar{old}}\ \verb+=+\ \ir{x}\verb+;+\
\ir{\stmt}^*\verb+;+\
\ir{x}\ \verb+=+\ \ir{\expr}
\rangle, \ir{x})
\\
&&\mbox{ELSE\ }
\langle
\ir{\stmt}^*\verb+;+\
\ir{x}\ \verb+=+\ \ir{\expr}
\rangle
\\

\atoiLVAL\lbr \lhs\verb+.+x \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
&=&
\atoiLVAL\lbr \lhs\verb+["+x\verb+"]+ \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
\\


%% LVAL Load
\atoiLVAL\lbr \lhs\verb+[+\expr\verb+]+ \rbr(\env)(\ir{\stmt}^*; \ir{\expr}')(\kold)
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e}({\inblue\newvar{field_1}})\\
& & \mbox{IN}\hspace*{1.2em}
\mbox{IF keepOld}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{THEN\ }
(\langle
\irstmt_1^*\verb+;+{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
\irstmt_2^*\verb+;+
\\&& \phantom{\mbox{IN}\hspace*{1.2em}\mbox{THEN\ }(\langle}
%%{\inblue\newvar{val}}\ \verb+=+\ \ir{\expr}'\verb+;+\
 {\inblue{\newvar{old}}}\ \verb+=+\ {\inred\newvar{obj}}\verb+[+\irexpr_2\verb+];+
\ir{\stmt}^*\verb+;+
{\inred\newvar{obj}}\verb+[+\irexpr_2\verb+] =+\ \ir{\expr}'
\rangle, 
\\
&& \phantom{\mbox{IN}\hspace*{1.2em}\mbox{THEN\ }\langle}
{\inred\newvar{obj}}\verb+[+\irexpr_2\verb+]+)
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{ELSE\ }
(\langle
\irstmt_1^*\verb+;+{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
 \irstmt_2^*\verb+;+\\
%{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)} \verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\mbox{ELSE\ }(\langle}
\ir{\stmt}^*\verb+;+
{\inred\newvar{obj}}\verb+[+\irexpr_2\verb+] =+\ \ir{\expr}'
\rangle,
 {\inred\newvar{obj}}\verb+[+\irexpr_2\verb+]+)
\\

\atoiLVAL\lbr \expr \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
&=& \mbox{\inred Warning: ReferenceError!}
\\[1em]


%% expression sequence
\atoiE\lbr e_1\verb+,+\ e_2 \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newvar{y}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\inred\newvar{y}}\ \verb+=+\ \irexpr_1\verb+;+
\irstmt_2^*, \irexpr_2)

%\open\ir\stmt^*\verb+;+\ \fbox{{\inred\newvar{\_}}\ {\tt =} \ \irexpr}\close
\\

%% ternary &&
\emph{\inblue Candidate for optimization}
\\
\atoiE\lbr {\inblue e_a \verb+&&+ e_b\ \verb+?+\ e_2\ \verb+:+\ e_3}\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_a^*, \irexpr_a) = \atoiEfd{e_a}({\inblue\newvar{new_a}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_b^*, \irexpr_b) = \atoiEfd{e_b}({\inblue\newvar{new_b}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \phantom{\mbox{LET\ }} (\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_a^*\verb+;+\
% \irstmt_b^*\verb+;+
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\sf if\ (}\irexpr_a{\sf )}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\sf then}\
\langle\irstmt_b^*\verb+;+\
{\sf if\ (} {\irexpr_b} {\sf )\ then\ }
\verb+{+\irstmt_2^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_2$}\verb+;+\
{\sf break}\ {\inred\newvar{label}}\verb+}+\rangle\verb+;+
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
\irstmt_3^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_3$} \verb+}+,\ir{x})
\\


\end{array}
\]

\[
\begin{array}{l@{~}l@{~}l}


%% ternary ||
\emph{\inblue Candidate for optimization}
\\
\atoiE\lbr {\inblue e_a \verb+||+ e_b\ \verb+?+\ e_2\ \verb+:+\ e_3}\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_a^*, \irexpr_a) = \atoiEfd{e_a}({\inblue\newvar{new_a}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_b^*, \irexpr_b) = \atoiEfd{e_b}({\inblue\newvar{new_b}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \phantom{\mbox{LET\ }} (\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_a^*\verb+;+\
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label_2}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\inblue \newvar{label_1}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (}\irexpr_a{\sf )}
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf then\ break}\ {\inred\newvar{label_1}}\verb+;+ \irstmt_b^*\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (} {\irexpr_b} {\sf )\ then\ } {\sf break}\ {\inred\newvar{label_1}}\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
\irstmt_3^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_3$}\verb+;+\
{\sf break}\ {\inred\newvar{label_2}}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
\verb+};+\ \irstmt_2^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_2$}\verb+}+,\ir{x})\\


%% ternary
\atoiE\lbr e_1\ \verb+?+\ e_2\ \verb+:+\ e_3\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \phantom{\mbox{LET\ }} (\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\sf if} \ \verb+(+{\irexpr_1}\verb+)+ \
{\sf then} \ \verb+{+\irstmt_2^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_2$} \verb+}+\
{\sf else} \ \verb+{+\irstmt_3^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_3$} \verb+}+,
\ir{x})
\\


\atoiE\lbr\lhs\ \verb+=+\ \expr\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
\mbox{IF\ $\irexpr$ contains $\lhs$}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{THEN\ }
    \atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ \irexpr \ )({\rm false})
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{ELSE\ }
    (\atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ \irexpr \ )({\rm false}).\_1, \irexpr)
\\

\atoiE\lbr{\lhs \aop\verb+=+\ \expr}\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{y}})\\
% & & \mbox{IN}\hspace*{1.2em}
%     (\atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ {\inblue{\newvar{new}}}\ \verb+=+\ {\inred{\newvar{old}}} \inop \irexpr;\ {\inred\newvar{new}})\verb+;+
%      \ir{x} \; {\tt =} \; {\inred\newvar{new}}, \ir{x})
% \\
& & \mbox{IN}\hspace*{1.2em}
    (\atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ {\inred{\newvar{old}}} \aop \irexpr)({\rm true}).\_1,
{\inred{\newvar{old}}} \aop \irexpr)
\\


\atoiE\lbr{\verb!++! \expr}\rbr(\env)(\ir{x})
% &=&
% (\atoiLVAL\lbr \expr \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new_2}}, \ir{x})
% \\
&=&
(\atoiLVAL\lbr \expr \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1})({\rm true}).\_1,
{\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1})
% ;\
% {\inred{\newvar{old}}}\ \verb!+! {\sf\ingreen 1})({\rm true}).\_1,
% {\inred{\newvar{old}}}\ \verb!+! {\sf\ingreen 1})
\\


\atoiE\lbr{\verb!--! \expr}\rbr(\env)(\ir{x})
&=& (\atoiLVAL\lbr \expr \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1})({\rm true}).\_1,
{\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1})
% ;\
% {\inred{\newvar{old}}}\ \verb!-! {\sf\ingreen 1})({\rm true}).\_1,
% {\inred{\newvar{old}}}\ \verb!-! {\sf\ingreen 1})
\\
% &=& (\atoiLVAL\lbr \expr \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new_2}}, \ir{x})
% \\


\atoiE\lbr{\sf delete}\ x\rbr(\env)(\ir{y})
&=&(\langle\ir{y}\ \verb+= + {\sf delete}\ x\rangle, \ir{y})\\

\atoiE\lbr{\sf delete}\ \verb+(+x\verb+)+\rbr(\env)(\ir{y})
&=&(\langle\ir{y}\ \verb+= + {\sf delete}\ x\rangle, \ir{y})\\

\atoiE\lbr{\sf delete}\ \lhs\verb+.+x\rbr(\env)(\ir{y})
&=& \atoiE\lbr{\sf delete}\ \lhs\verb+["+x\verb+"]+\rbr(\env)(\ir{y})
\\

\atoiE\lbr{\sf delete}\ \lhs\verb+[+e\verb+]+\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e}({\inblue\newvar{field_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
\irstmt_2^*\verb+;+
%{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)} \verb+;+
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}(}
 \ir{x}\ \verb+= + {\sf delete}\ {\inred\newvar{obj}}\verb+[+\irexpr_2\verb+]+, \ir{x})
\\

\atoiE\lbr{\sf delete}\ e\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{y}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*\verb+;+
{\inred\newvar{\_}}\ \verb+= + \ir{e}, {\sf true})
\\

\atoiEfd{\preop e}(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{y}})\\
& & \mbox{IN}\hspace*{1.2em}
% (\irstmt^*\verb+;+\ \ir{x} \ \verb+=+ \ \preop \irexpr, \ir{x})
(\irstmt^*, \preop \irexpr)
\\

\atoiE\lbr \lhs \verb!++!\rbr(\env)(\ir{x})
&=&
(\atoiLVAL\lbr \lhs \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1})({\rm true}).\_1,
{\inred\newvar{new}})
% ;\
% {\inred{\newvar{old}}}\ \verb!+! {\sf\ingreen 1})({\rm true}).\_1,
% {\inred\newvar{old}})
\\
% (\atoiLVAL\lbr \lhs \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new}}, \ir{x})
% \\

\atoiE\lbr \lhs \verb!--!\rbr(\env)(\ir{x})
&=&
(\atoiLVAL\lbr \lhs \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1})({\rm true}).\_1,
{\inred\newvar{new}})
% ;\
% {\inred{\newvar{old}}}\ \verb!-! {\sf\ingreen 1})({\rm true}).\_1,
% {\inred\newvar{old}})
\\
% (\atoiLVAL\lbr \lhs \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new}}, \ir{x})
% \\

% binary operation &&
\emph{\inblue Candidate for optimization}
\\
 \atoiE\lbr{{\inblue e_1 \verb+&&+ e_2}}\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newvar{y}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvar{z}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\sf if\ (}\irexpr_1)\
{\sf then\ }\irstmt_2^*\verb+;+\ \ir{x}\ \verb+=+\ {\irexpr_2}\
{\sf else\ }\ir{x}\ \verb+=+\ {\irexpr_1},
\ir{x})
\\

 % &=& \langle
 % \atoiEfd{e_1}({\inblue\ir{y}})\verb+;+\\
 % &&\phantom{\langle}
 % {\inblue\newvar{y_1}}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean(}{\inred\ir{y}}{\sf)}\verb+;+\\
 % &&\phantom{\langle}

% binary operation ||
\emph{\inblue Candidate for optimization}
\\
 \atoiE\lbr{{\inblue e_1 \verb+||+ e_2}}\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newvar{y}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvar{z}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\sf if\ (}\irexpr_1)\
{\sf then\ }\ir{x}\ \verb+=+\ {\irexpr_1}
{\sf else\ }\irstmt_2^*\verb+;+\ \ir{x}\ \verb+=+\ {\irexpr_2},
\ir{x})
\\


 % &=& \langle
 % \atoiEfd{e_1}({\inblue\ir{y}})\verb+;+\\
 % &&\phantom{\langle}
 % {\inblue\newvar{y_1}}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean(}{\inred\ir{y}}{\sf)}\verb+;+\\
 % &&\phantom{\langle}
 % {\sf if\ ({\inred{\newvar{y_1}}})\ then}\
 % {\sf IRSeq(}\langle\ \ir{x}\ \verb+=+\ {\inred\ir{y}}\verb+;+ \rangle{\sf)}\
 % {\sf else}\
 % \atoiEfd{e_2}({\ir{x}})\rangle\\



% ast2ir_e[e1&&e2])(sigma)(x) = <ast2ir_e[e1](sigma)(y); y1=\ensuremath{\diamond}toBoolean(y); if y1 then x=y else ast2ir_e[e2](sigma)(x)>
% ast2ir_e[e1||e2])(sigma)(x) = <ast2ir_e[e1](sigma)(y); y1=\ensuremath{\diamond}toBoolean(y); if y1 then ast2ir_e[e2](sigma)(x) else x=y >


\lefteqn{\note{
In order to preserve the semantics when the evaluation of $\irexpr_1$ throws an exception,
we force to evaluate $\irexpr_1$ before evaluating}}\\
\lefteqn{\note{
$\irstmt_2^*$ by introducing an assignment ``{\inred$\newvar{new_1}$}\ {\tt =} $\irexpr_1$''
to avoid any side effects by $\irstmt_2^*$.
Note that we add the assignment only when}}\\
\lefteqn{\note{
$\irstmt_2^*$ is not empty for a simple optimization.
}}\\

% binary operation
\emph{\inblue Candidate for optimization}
\\
\atoiEfd{{\inblue e_1 \inop e_2}}(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newvar{y}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvar{z}})\\
& & \mbox{IN}\hspace*{1.2em}
%(\irstmt_1^*\verb+;+\irstmt_2^*, \irexpr_1 \inop \irexpr_2)
\mbox{IF\ $\irstmt_2^*$ is empty}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{THEN\ }(\irstmt_1^*, \irexpr_1 \inop \irexpr_2)
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{ELSE\ }(\irstmt_1^*\verb+;+\
{\inred\newvar{y}}\ \verb+=+\ \irexpr_1\verb+;+\
\irstmt_2^*, {\inred\newvar{y}} \inop \irexpr_2)
\\



%% lhs
\atoiEfd{\lhs}(\ir{x})
&=& \atoiLHSfd{\lhs}(\ir{x})
\\[1em]


\end{array}
\]


\[
\begin{array}{l@{~}l@{~}l}
%% literal
\atoiLHSfd{lit}(\ir{x})
&=& \atoiLITfd{lit}(\ir{x})
\\

%% arguments
\atoiLHS\lbr\verb+arguments+\rbr(\env)(\ir{x})
&=& (\emptyenv, \env(\newvar{arguments}))
\\

%% variable reference
\atoiLHSfd{x}(\ir{y})
&=& (\langle\rangle, \ir{x})\\

%% array expression
\emph{\inblue Candidate for optimization}
\\
\atoiLHS \lbr{\inblue \verb+[+(e^?\verb+,+)^* \verb+]+ }\rbr(\env)(\ir{x})
&=&
\mbox{LET\ } ((\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{elem}}))^*
\\
& & \mbox{IN}\hspace*{1.2em}
((\ir{s}^*\verb+;+\ {\inred\newvar{elem}}\ \verb+=+\ \irexpr)^* \verb+;+\
\irid \ \verb+=+ \ \verb+[+ ({\inred\newvar{elem}}\verb+,+)^* \verb+]+, \ir{x})
\\

%% object expressions
\atoiLHS \lbr \verb+{+(m\verb+,+)^* \verb+}+ \rbr(\env)(\ir{x})
&=&
\mbox{LET\ } ((\irstmt^*, \ir{\emph mem}) = \atoiMfd{m}({\inblue\newvar{member}}))^*
\\
& & \mbox{IN}\hspace*{1.2em}
((\ir{s}^*)^* \verb+;+\
\irid \ \verb+=+ \ \verb+{+ (\ir{\emph mem}\verb+,+)^* \verb+}+, \ir{x})
\\

%% parenthesized expression
\atoiLHS \lbr \verb+(+e \verb+)+ \rbr(\env)(\ir{x})
&=& \atoiEfd{e}(\ir{x})
\\


%% function expression
\atoiLHS\lbr{ {\tt function} \ f^? \verb+(+(x\verb+,+)^*\verb+)+ \ \verb+{+ \fd^* \vd^* \stmt^* \verb+}+}\rbr(\env)(\ir{y})
&=&
(\langle\ir{y}\ \verb+=+\
{\sf function} \ \ir{f}^? \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad\quad\quad(\atoiFDfd{\fd})^*\\
&&\quad\quad\quad
({\sf var}\ \ir{x_i})^*\\
&&\quad\quad\quad(\atoiVDf{\vd}\env)^*\\
&&\quad\quad\quad
(\ir{x_i} = {\inred\newvar{arguments}}\verb+["i"]+)^*
\quad\note{where \ir{x_i} is not the name of any of \mbox{fd}}\\
&&\quad\quad\quad(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+\rangle,
\ir{y})
\\


\atoiLHS \lbr \lhs\verb+.+x \rbr(\env)(\ir{y})
&=& \atoiLHS \lbr \lhs\verb+["+x\verb+"]+ \rbr(\env)(\ir{y})
\\


%% property access by string
\atoiLHS \lbr \lhs\verb+["+x \verb+"]+ \rbr(\env)(\ir{y})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)},
{\inred\newvar{obj}}\verb+["x"]+)
\\




%% property access
\atoiLHS \lbr \lhs\verb+[+e \verb+]+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{\expr}({\inblue\newvar{field_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
\irstmt_2^*,
%{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)}
{\inred\newvar{obj}}\verb+[+\irexpr_2\verb+]+)
\\


%% new fun app
\emph{\inblue Candidate for optimization}
\\
\atoiLHS \lbr {\inblue \verb+new+\ \lhs\verb+(+(e,)^* \verb+)+} \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_l^*, \irexpr_l) = \atoiLHSfd{\lhs}({\inblue\newvar{fun_1}})\\
& & \phantom{\mbox{LET\ }} ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_l^*\verb+;+
{\inblue\newvar{fun}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_l{\sf)} \verb+;+\
%(\irstmt^*)^*\verb+;+
(\irstmt^*\verb+;+\ {\inred\newvar{y}}\ \verb+=+\ \irexpr)^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+({\inred\newvar{y_i}}\verb+,+)^*\verb+];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
% %%%%%%%
% % proto = fun["prototype"]
{\inblue\newvar{proto}} = {\inred\newvar{fun}}\verb+["prototype"];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{obj}}\ \verb+= {[[Prototype]] = +{\inred\newvar{proto}}\verb+};+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{newObj}}\ \verb+=+\
{\sf new}\
{\inred\newvar{fun}}\verb+(+{\inred\newvar{obj}}\verb+, + {\inred\newvar{arguments}}\verb+);+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{cond}}\ \verb+=+\ {\sf \ensuremath{\diamond}isObject({\inred\newvar{newObj}})}\verb+;+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\sf if (} {\inred\newvar{cond}} {\sf )\ then}\
\ir{x}\ \verb+=+\ {\inred\newvar{newObj}}\ {\sf \ else}\
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}, \ir{x})
\\





%% new
\atoiLHS \lbr \verb+new+\ \lhs \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiLHSfd{\lhs}({\inblue\newvar{fun_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*\verb+;+
{\inblue\newvar{fun}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr{\sf)} \verb+;+\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
% %%%%%%%
% % proto = fun["prototype"]
{\inblue\newvar{proto}} = {\inred\newvar{fun}}\verb+["prototype"];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{obj}}\ \verb+= {[[Prototype]] = +{\inred\newvar{proto}}\verb+};+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{newObj}}\ \verb+=+\
{\sf new}\
{\inred\newvar{fun}}\verb+(+{\inred\newvar{obj}}\verb+, + {\inred\newvar{arguments}}\verb+);+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{cond}}\ \verb+=+\ {\sf \ensuremath{\diamond}isObject({\inred\newvar{newObj}})}\verb+;+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\sf if (} {\inred\newvar{cond}} {\sf )\ then}\
\ir{x}\ \verb+=+\ {\inred\newvar{newObj}}\ {\sf \ else}\
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}, \ir{x})
\\


\end{array}
\]

\[
\begin{array}{l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l}
\aop &::=&
\verb+*+ & \mid &
\verb+/+ & \mid &
\verb+%+ & \mid &
\verb!+! & \mid &
\verb+-+ & \mid &
\verb+<<+ & \mid &
\verb+>>+ & \mid &
\verb+>>>+ & \mid &
\verb+&+ & \mid &
\verb+^+ & \mid &
\verb+|+
\\

\preop &::=& \verb+~+ & \mid & \verb+!+ & \mid & \verb!+! & \mid & \verb+-+ & \mid &
\lefteqn{
 {\tt delete} \ \mid \ {\tt void} \ \mid \ {\tt typeof} }\\

\inop &::=& \verb+|+ & \mid & \verb+&+ & \mid & \verb+^+ & \mid & \verb+<<+ & \mid & \verb+>>+ & \mid & \verb+>>>+ 
 & \mid & \verb!+! & \mid & \verb+-+ & \mid & \verb+*+ & \mid & \verb+/+ & \mid & \verb+%+
 &\mid& \verb+==+ & \mid & \verb+!=+ & \mid & \verb+===+ & \mid & \verb+!==+ & \mid & \verb+<+ & \mid & \verb+>+ & \mid & \verb+<=+
 & \mid & \verb+>=+ & \mid & {\tt instanceof} & \mid & {\tt in}\\[1em]
\end{array}
\]


\[
\begin{array}{l@{~}l@{~}l}
%% eval
\atoiLHS \lbr {\emph eval} \verb+(+e \verb+)+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*\verb+;+
\irid \ \verb+=+ \ {\sf eval}\verb+(+\irexpr\verb+)+, \irid)
\\
\atoiLHS \lbr \verb+(+f \verb+)(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=&
\atoiLHS \lbr f \verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
\\

\emph{\inblue Candidate for optimization}
\\
%% function id call
\atoiLHS \lbr {\inblue f \verb+(+(e,)^* \verb+)+} \rbr(\env)(\ir{x})
&=& \mbox{LET\ } ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
({\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\ir{f}{\sf)} \verb+;+\
(\irstmt^*\verb+;+\ {\inred\newvar{y}}\ \verb+=+\ \irexpr)^*\verb+;+
%(\irstmt^*)^*\verb+;+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+({\inred\newvar{y_i}}\verb+,+)^*\verb+];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{fun}}\ \verb+=+\ \newvar{getBase}\verb+(+\ir{f}\verb+);+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}\verb+(+{\inred\newvar{fun}}, {\inred\newvar{arguments}}\verb+)+,
\ir{x})
\\

%% property access call
\atoiLHS \lbr \verb+(+\lhs\verb+.+x \verb+)(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
&=& \atoiLHS \lbr \lhs\verb+["+x\verb+"]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
\\

\atoiLHS \lbr \lhs\verb+.+x \verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
&=& \atoiLHS \lbr \lhs\verb+["+x\verb+"]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
\\


% \atoiLHSfd{\lhs}(\newvar{constr}) \verb+;+
% \\
% &&\phantom{\langle}
% (\atoiEfd{\expr}(\ir{y}))^*
% \\
% &&\phantom{\langle}
% \newvar{arguments}\ \verb+= {+(\verb+"i" : +\ir{y_i})^*\verb+};+
% \\
% &&\phantom{\langle}
% \newvar{obj}\ \verb+= {+ \newvar{proto}\verb+:+ \newvar{constr}\verb+["prototype"]}+
% \\
% &&\phantom{\langle}
% \ir{x}\ \verb+=+\ \newvar{constr}\verb+(+\newvar{obj}\verb+, + \newvar{arguments}\verb+);+
% \\
% &&\phantom{\langle}
% \newvar{obj}
% \\

\atoiLHS \lbr \verb+(+\lhs\verb+[+e' \verb+])+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=&
\atoiLHS \lbr \lhs\verb+[+e' \verb+]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
\\


%% property access call
\emph{\inblue Candidate for optimization}
\\
\atoiLHS \lbr {\inblue\lhs\verb+[+e' \verb+]+\verb+(+(e,)^* \verb+)+} \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_l^*, \irexpr_l) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt'^*, \irexpr') = \atoiEfd{\expr'}({\inblue\newvar{field_1}})\\
& & \phantom{\mbox{LET\ }} ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_l^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_l{\sf)} \verb+;+
\irstmt'^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
%{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr'{)} \verb+;+\
(\irstmt^*\verb+;+\ {\inred\newvar{y}}\ \verb+=+\ \irexpr)^*\verb+;+
%(\irstmt^*)^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+({\inred\newvar{y_i}}\verb+,+)^*\verb+];+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{fun}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}{\inred\newvar{obj}}\verb+[+\irexpr'\verb+]+{\sf)} \verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
\ir{x}\ \verb+=+\ {\inred\newvar{fun}}\verb+(+{\inred\newvar{obj}}\verb+, + {\inred\newvar{arguments}}\verb+)+,
\ir{x})
\\



%% function call
\emph{\inblue Candidate for optimization}
\\
\atoiLHS \lbr {\inblue\lhs \verb+(+(e,)^* \verb+)+} \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_l^*, \irexpr_l) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_l^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_l{\sf)} \verb+;+\
(\irstmt^*\verb+;+\ {\inred\newvar{y}}\ \verb+=+\ \irexpr)^*\verb+;+
%(\irstmt^*)^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+({\inred\newvar{y_i}}\verb+,+)^*\verb+];+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}\verb+(+\newvar{global}\verb+, + {\inred\newvar{arguments}}\verb+)+, \ir{x})
\\[1em]



\atoiLITfd {{\tt this}}(\ir{x})
&=&
(\emptyenv, \env(\newvar{this}))\\

\atoiLITfd{{\tt null}}(\ir{x})
&=& 
(\emptyenv, {\sf null})\\
\atoiLITfd{{\tt true}}(\ir{x})
&=& 
(\emptyenv, {\sf true})\\
\atoiLITfd{{\tt false}}(\ir{x})
&=& 
(\emptyenv, {\sf false})\\
\atoiLITfd{num}(\ir{x})
&=& 
(\emptyenv, \ir\num)\\

\atoiLITfd {str}(\ir{x})
&=& 
(\emptyenv, \ir\str)\\

\inred\atoiLITfd { reg }
&=&

\\[1em]
\atoiM\lbr {\prop \ \verb+:+ \ \expr}  \rbr(\env)(\ir{y})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{\expr}(\ir{y})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*, \atoiPRfd{\prop} \ \verb+:+ \ \irexpr)
\\


\atoiM\lbr {\tt get} \ \prop \verb+(){+ \fd^* \vd^* \stmt^* \verb+}+  \rbr(\env)(\ir{x})
&=& (
\langle\rangle,

{\sf get} \ \atoiPRfd{\prop} \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad\quad\quad(\atoiFDfd{\fd})^*\\
&&\quad\quad\quad(\atoiVDf{\vd}\env)^*\\
&&\quad\quad\quad(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+
)
\\

\atoiM\lbr {\tt set} \ \prop \verb+(+x \verb+){+ \fd^* \vd^* \stmt^* \verb+}+  \rbr(\env)(\ir{y})
&=& (
\langle\rangle,

{\sf set} \ \atoiPRfd{\prop} \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad\quad\quad(\atoiFDfd{\fd})^*\\
&&\quad\quad\quad{\sf var}\ \ir{x}\\
&&\quad\quad\quad(\atoiVDf{\vd}\env)^*\\
&&\quad\quad\quad
\ir{x} = {\inred\newvar{arguments}}\verb+["0"];+
\quad\note{where \ir{x} is not the name of any of \mbox{fd}}\\
&&\quad\quad\quad(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+
)
\end{array}
\]
