\documentclass[a4paper, leqno]{amsart}
\usepackage{amsmath,amssymb,graphicx,fullpage,color,stmaryrd,url}
\usepackage{anysize}
\RequirePackage[nonfrench]{kotex}
\marginsize{.5in}{.5in}{.5in}{.5in}

\newcommand{\newvar}[1]{\ensuremath{\underline{\sf \diamond{#1}}}}
\newcommand{\newva}{\newvar{new_1}}
\newcommand{\newvb}{\newvar{new_2}}
\newcommand{\newvc}{\newvar{new_3}}

\newcommand{\kold}{{\rm keepOld}}
\newcommand{\false}{{\rm false}}
\newcommand{\true}{{\rm true}}
\newcommand{\myid}{x}
\newcommand{\myfn}{f}
\newcommand{\name}{\alpha}
\newcommand{\env}{\Sigma}
\newcommand{\wenv}{\Gamma}
\newcommand{\open}{{\ingreen\langle}}
\newcommand{\close}{{\ingreen\rangle}}
%\newcommand{\emptyenv}{\langle\rangle, \langle\rangle}
\newcommand{\emptyenv}{\langle\rangle}
% added commands by changhee
\newcommand{\nestedname}{\beta}
\newcommand{\listname}{\phi\;\alpha}
\newcommand{\namelist}{\phi}
\newcommand{\emptylist}{\epsilon}
\newcommand{\emptyval}{{\ingreen\mbox{\tt empty}}}
\newcommand{\listscope}{\varphi}
\newcommand{\flag}{{\emph{IsNested}}}
\newcommand{\trueflag}{{\bold{True}}}
\newcommand{\falseflag}{{\bold{False}}}
\newcommand{\argmk}[3]{\langle#1, #2, #3\rangle}
\newcommand{\rewritearg}{\langle\listname, \listscope, \flag\rangle}
%\newcommand{\isshadowed}[2]{\ensuremath{\emph{IsShadowed}\lbr#1\mid#2\rbr}}
\newcommand{\isshadowed}[2]{\ensuremath{#1\in#2}}
\newcommand{\mylet}{\bold{Let}\ }
\newcommand{\myif}{\bold{If}\ }
\newcommand{\mythen}{\bold{Then}\ }
\newcommand{\myelse}{\bold{Else}\ }
\newcommand{\myifend}{\bold{EndIf}}
\newcommand{\myelseend}{\bold{EndElse}}
\newcommand{\namecheck}[2]{\ensuremath{#1 \equiv #2}}
\newcommand{\getlocaldecls}{\ensuremath{\emph{LocalDecls}}}

\newcommand{\pgm}{p}
\newcommand{\stmt}{s}
\newcommand{\expr}{e}
\newcommand{\exprs}{e^+}
%\newcommand{\topl}{t}
\newcommand{\fd}{\emph{fd}}
\newcommand{\vd}{\emph{vd}}
\newcommand{\cc}{\emph{cc}}
\newcommand{\me}{\emph{me}}
\newcommand{\ce}{\emph{ce}}
\newcommand{\lhs}{\emph{lhs}}
\newcommand{\lval}{\emph{lval}}
\newcommand{\prop}{\emph{pr}}
\newcommand{\lit}{\emph{lit}}
\newcommand{\num}{\emph{num}}
\newcommand{\str}{\emph{str}}
\newcommand{\reg}{\emph{reg}}
\newcommand{\member}{\emph{m}}
\newcommand{\aop}{\ensuremath{\odot}}
\newcommand{\inop}{\ensuremath{\otimes}}
\newcommand{\preop}{\ensuremath{\ominus}}
\newcommand{\postop}{\ensuremath{\oslash}}

\newcommand{\atoi}{\ensuremath{\emph{ast2ir}}}
% p::=t*
\newcommand{\atoiP}{\ensuremath{\atoi_p}}
\newcommand{\atoiPf}[1]{\ensuremath{\atoiP\lbr#1\rbr}}
% t::= s | ...
% \newcommand{\atoiT}{\ensuremath{\atoi_t}}
% \newcommand{\atoiTf}[2]{\ensuremath{\atoiT\lbr{#1}\rbr(#2)}}
% \newcommand{\atoiTfd}[1]{\ensuremath\atoiTf{#1}{\env}}
% s::= {s*} | ...
\newcommand{\atoiS}{\ensuremath{\atoi_s}}
\newcommand{\atoiSf}[2]{\ensuremath{\atoiS\lbr#1\rbr(#2)}}
\newcommand{\atoiSfd}[1]{\atoiSf{#1}{\env}}

\newcommand{\atoiN}{\ensuremath{\atoi_n}}
\newcommand{\atoiNf}[2]{\ensuremath{\atoiN\lbr#1\rbr(#2)}}
\newcommand{\atoiNfd}[1]{\atoiNf{#1}{\env}}
% vd::= id(=e)?
\newcommand{\atoiVD}{\ensuremath{\atoi_{\emph{vd}}}}
\newcommand{\atoiVDf}[2]{\ensuremath{\atoiVD\lbr#1\rbr(#2)}}
% fd
\newcommand{\atoiFD}{\ensuremath{\atoi_{\emph{fd}}}}
\newcommand{\atoiFDf}[2]{\ensuremath{\atoiFD\lbr#1\rbr(#2)}}
\newcommand{\atoiFDfd}[1]{\atoiFDf{#1}{\env}}
% cc::= case e:s*
\newcommand{\atoiCC}{\ensuremath{\atoi_{\emph{cc}}}}
\newcommand{\atoiCCf}[2]{\ensuremath{\atoiCC\lbr#1\rbr(#2)}}
\newcommand{\atoiCCfd}[1]{\atoiCCf{#1}{\env}}
% e::= e,e | ...
\newcommand{\atoiE}{\ensuremath{\atoi_e}}
\newcommand{\atoiEf}[2]{\ensuremath{\atoiE\lbr#1\rbr(#2)}}
\newcommand{\atoiEfd}[1]{\atoiEf{#1}{\env}}
% lhs ::= lit | id | ...
\newcommand{\atoiLHS}{\ensuremath{\atoi_{\emph{lhs}}}}
\newcommand{\atoiLHSf}[2]{\ensuremath{\atoiLHS\lbr#1\rbr(#2)}}
\newcommand{\atoiLHSfd}[1]{\atoiLHSf{#1}{\env}}
% lval
\newcommand{\atoiLVAL}{\ensuremath{\atoi_{\emph{lval}}}}
\newcommand{\atoiLVALf}[2]{\ensuremath{\atoiLVAL\lbr#1\rbr(#2)}}
\newcommand{\atoiLVALfd}[1]{\atoiLVALf{#1}{\env}}
% lit ::= this|null|...
\newcommand{\atoiLIT}{\ensuremath{\atoi_{\emph{lit}}}}
\newcommand{\atoiLITf}[2]{\ensuremath{\atoiLIT\lbr#1\rbr(#2)}}
\newcommand{\atoiLITfd}[1]{\atoiLITf{#1}{\env}}
% m ::= pr:e | get/set
\newcommand{\atoiM}{\ensuremath{\atoi_m}}
\newcommand{\atoiMf}[2]{\ensuremath{\atoiM\lbr#1\rbr(#2)}}
\newcommand{\atoiMfd}[1]{\atoiMf{#1}{\env}}
% pr ::= id | str | num
\newcommand{\atoiPR}{\ensuremath{\atoi_{\emph{pr}}}}
\newcommand{\atoiPRf}[1]{\ensuremath{\atoiPR\lbr#1\rbr}}
\newcommand{\atoiPRfd}[1]{\atoiPRf{#1}}

\newcommand{\atoiL}{\ensuremath{\atoi_l}}
\newcommand{\atoiLf}[1]{\ensuremath{\atoiL\lbr#1\rbr}}
\newcommand{\collectLV}[1]{\ensuremath{\emph{collectLV}(#1)}}

% Add Ast2IR Lit???
\newcommand{\Field}{\emph{Field}}


\newcommand{\atoiLit}{\ensuremath{\atoi_{\emph{lit}}}}
% \newcommand{\atoiM}{\ensuremath{\atoi_m}}
\newcommand{\atoiPr}{\ensuremath{\atoi_{\emph{pr}}}}

\newcommand{\atoiC}{\ensuremath{\atoi_}\emph{case}}
\newcommand{\atoiSC}{\ensuremath{\atoi_}\emph{scond}}


\newcommand{\lbr}{\ensuremath{\llbracket}}
\newcommand{\rbr}{\ensuremath{\rrbracket}}

\newcommand{\note}[1]{~~~~{\color{blue}{\emph{#1}}}}

\def\inred{\color{red}}
\def\inblue{\color{blue}}
\def\ingreen{\color{green}}
\def\inblack{\color{black}}


\definecolor{orange}{rgb}{0.9,0.45,0}
\definecolor{purple}{rgb}{0.5,0,0.5}

\newif\iftr
\ifx\tr\undefined
  \trfalse
\else
 \trtrue
\fi
%\trtrue

\newcommand{\mtt}[1]{\mbox{\tt\footnotesize #1}}

\begin{document}
\vspace*{-.5em}
\title{AST to IR Translation}
\maketitle

\section{AST}
\small
\[
\begin{array}{l@{}l@{}ll}
\pgm & ::=  & \fd^*\ \vd^*\ \stmt^* & \mtt{Program(TopLevel body)}\\
&&&\mtt{TopLevel(List<FunDecl> fds, List<VarDecl> vds, List<SourceElement> stmts)}\\

\fd &::=& {\tt function} \ f \verb+(+(x\verb+,+)^*\verb+)+ \ \verb+{+\fd^*\ \vd^*\ \stmt^*\verb+}+
  & \mtt{FunDecl(Id name, Functional ftn)}\\
&&&\mtt{Functional(List<FunDecl> fds, List<VarDecl> vds, List<SourceElement> stmts,}\\
&&&\mtt{\phantom{Functional(}List<Id> params)}\\

\vd &::=& {\tt var} \ x & \mtt{VarDecl(Id name, Option<Expr> expr)}\\

% &&&\mtt{\phantom{FunDecl(}List<SourceElement> body)} \\
\stmt &::=& \verb+{+\stmt^*\verb+}+ & \mtt{Block(List<Stmt> stmts, boolean internal = false)}\\
& \mid & {\tt var} \ \vd(\verb+,+ \vd)^* \verb+;+ & \mtt{VarStmt(List<VarDecl> vds)}\\
& \mid & \verb+;+ & \mtt{EmptyStmt()}\\
& \mid & \expr \verb+;+ & \mtt{ExprStmt(Expr expr)}\\
& \mid & {\tt if} \ \verb+(+\expr\verb+)+ \ \stmt \ ({\tt else} \ \stmt)^? & \mtt{If(Expr cond, Stmt trueBranch, Option<Stmt> falseBranch)}\\
& \mid &

 {\tt switch} \ \verb+(+\expr\verb+)+ \ \verb+{+\cc^* \ ({\tt default} \verb+:+ \stmt^{*})^? \ \cc^* \verb+}+
& \mtt{Switch(Expr cond, List<Case> frontCases,}\\
&&&\mtt{\phantom{Switch(}Option<List<Stmt>> def, List<Case> backCases)}\\
& \mid & {\tt do} \ \stmt \ {\tt while} \ \verb+(+\expr\verb+)+ \verb+;+ & \mtt{DoWhile(Stmt body, Expr cond)}\\
  &\mid& {\tt while} \ \verb+(+\expr\verb+)+ \ \stmt & \mtt{While(Expr cond, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+\expr^?\verb+;+ \expr^?\verb+;+ \expr^? \verb+)+ \ \stmt
  & \mtt{For(Option<Expr> init, Option<Expr> cond, Option<Expr> action, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+ \lhs \ {\tt in} \ \expr \verb+)+ \ \stmt & 
\mtt{ForIn(LHS lhs, Expr expr, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+{\tt var} \ \vd(\verb+,+ \vd)^*\verb+;+ \expr^?\verb+;+ \expr^?\verb+)+ \ \stmt
  & \mtt{ForVar(List<VarDecl> vars, Option<Expr> cond, Option<Expr> action, Stmt body)}\\
  &\mid& {\tt for} \ \verb+(+{\tt var} \ \vd \ {\tt in} \ \expr \verb+)+ \ \stmt & \mtt{ForVarIn(VarDecl var, Expr expr, Stmt body)}\\
& \mid & {\tt continue} \  \myid^{?} \verb+;+ & \mtt{Continue(Option<Label> target)}\\
& \mid & {\tt break} \  \myid^{?} \verb+;+ & \mtt{Break(Option<Label> target)}\\
& \mid & {\tt return} \ \expr^? \verb+;+ & \mtt{Return(Option<Expr> expr)}\\
& \mid & {\tt with} \ \verb+(+\expr\verb+)+ \ \stmt & \mtt{With(Expr expr, Stmt stmt)}\\
& \mid & 
l \; \verb+:+ \; \stmt & \mtt{LabelStmt(Label label, Stmt stmt)}\\
& \mid & {\tt throw} \ \expr \verb+;+ & \mtt{Throw(Expr expr)}\\
& \mid &
{\tt try} \verb+{+\stmt^*\verb+}+ ({\tt catch} \verb+(+\myid\verb+)+ \verb+{+\stmt^*\verb+}+)^? ({\tt finally} \verb+{+\stmt^*\verb+}+)^?
& \mtt{Try(Block body, Option<Catch> catchBlock, Option<Block> fin)}\\
&& & \mtt{Catch(Id id, Block body)}\\
& \mid & {\tt debugger} \verb+;+ & \mtt{Debugger()}\\

\cc &::=& {\tt case} \ \expr \; \verb+:+ \; \stmt^{*} & \mtt{Case(Expr cond, Block body)}\\

\expr &::=& \expr\verb+,+ \ \expr & \mtt{ExprList(List<Expr> exprs)}\\
  &\mid& \expr \ \verb+?+ \ \expr \ \verb+:+ \ \expr & \mtt{Cond(Expr cond, Expr trueBranch, Expr falseBranch)}\\
  &\mid& \expr \ \inop \ \expr & \mtt{InfixOpApp(Expr left, Op op, Expr right)}\\
  &\mid& \preop \ \expr & \mtt{PrefixOpApp(Op op, Expr right)}\\
  &\mid& \lhs \ \postop & \mtt{UnaryAssignOpApp(LHS lhs, Op op)}\\
  &\mid& \lhs \ \aop \ \expr & \mtt{AssignOpApp(LHS lhs, Op op, Expr right)}\\
  &\mid& \lhs & \mtt{LHS()}\\

\lhs &::=& \lit & \mtt{Literal()}\\
 &\mid& \myid & \mtt{VarRef(Id id)}\\
 &\mid& \verb+[+ (\expr^?\verb+,+)^* \ \verb+]+ & \mtt{ArrayExpr(List<Option<Expr>> elements)}\\
 &\mid& \verb+{+ (\member\verb+,+)^* \verb+}+ & \mtt{ObjectExpr(List<Member> members)}\\
 &\mid& \verb+(+ \expr \verb+)+ & \mtt{Parenthesized(Expr expr)}\\
 & \mid & {\tt function} \ \myid^?  \verb+(+(\myid\verb+,+)^*\verb+)+ \ \verb+{+\fd^*\ \vd^*\ \stmt^*\verb+}+ &
\mtt{FunExpr(Option<Id> name, Functional ftn)}\\
 %  \mtt{FunExpr(Option<Id> name, List<Id> params, List<VarDecl> vds, List<FunDecl> fds,}\\
 % &&&\mtt{\phantom{FunExpr(}List<SourceElement> body)} \\


 &\mid& \lhs \verb+[+ \expr \verb+]+ & \mtt{Bracket(LHS obj, Expr index)}\\
 &\mid& \lhs \verb+.+ \myid & \mtt{Dot(LHS obj, Id member)}\\
 &\mid& {\tt new} \ \lhs & \mtt{New(LHS lhs)}\\
 &\mid& \lhs \verb+(+ (\expr\verb+,+)^* \verb+)+ & \mtt{FunApp(LHS fun, List<Expr> args)} \\

\lit &::=& {\tt this} & \mtt{This()}\\
 &\mid& {\tt null} & \mtt{Null()}\\
 &\mid& {\tt true} & \mtt{Bool(boolean bool)}\\
 &\mid& {\tt false} & \mtt{Bool(boolean bool)}\\
 &\mid& \num & \mtt{DoubleLiteral(ignoreForEquals String text, Double num)}\\
&&&\mtt{IntLiteral(BigInteger intVal, int radix)}\\
 &\mid& \str & \mtt{StringLiteral(String str, String quote)}\\
 &\mid& \reg & \mtt{RegularExpression(String reg)}\\

\member &::=& \prop \ \verb+:+ \ \expr & \mtt{Field(Property prop, Expr expr)}\\
 &\mid& {\tt get}\ \prop \verb+() {+ \fd^*\ \vd^*\ \stmt^* \verb+}+ 
 & \mtt{GetProp(Property prop, Functional ftn)}\\
 &\mid& {\tt set}\ \prop \verb+(+ \myid \verb+) {+ \fd^*\ \vd^*\ \stmt^* \verb+}+
 & \mtt{SetProp(Property prop, Functional ftn)}\\

\prop &::= & \myid & \mtt{PropId(Id id)}\\
 &\mid& \str & \mtt{PropStr(String str)}\\
 &\mid& \num & \mtt{PropNum(NumberLiteral num)}\\
\end{array}
\]

\[
\begin{array}{l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l}
\aop &::=&
\verb+=+ & \mid &
\verb+*=+ & \mid &
\verb+/=+ & \mid &
\verb+%=+ & \mid &
\verb!+=! & \mid &
\verb+-=+ & \mid &
\verb+<<=+ & \mid &
\verb+>>=+ & \mid &
\verb+>>>=+ & \mid &
\verb+&=+ & \mid &
\verb+^=+ & \mid &
\verb+|=+
\\

\inop &::=& \verb+&&+ & \mid & \verb+||+ & \mid & \verb+|+ & \mid & \verb+&+ & \mid & \verb+^+ & \mid & \verb+<<+ & \mid & \verb+>>+ & \mid & \verb+>>>+ 
 & \mid & \verb!+! & \mid & \verb+-+ & \mid & \verb+*+ & \mid & \verb+/+ & \mid & \verb+%+
 &\mid& \verb+==+ & \mid & \verb+!=+ & \mid & \verb+===+ & \mid & \verb+!==+ & \mid & \verb+<+ & \mid & \verb+>+ & \mid & \verb+<=+
 & \mid & \verb+>=+ \\
 & \mid &
\lefteqn{
 {\tt instanceof} \ \mid \ {\tt in} }\\

\preop &::=& \verb!++! & \mid & \verb+--+ & \mid & \verb+~+ & \mid & \verb+!+ & \mid & \verb!+! & \mid & \verb+-+ & \mid &
\lefteqn{
 {\tt delete} \ \mid \ {\tt void} \ \mid \ {\tt typeof} }\\

\postop &::=& \verb!++! & \mid & \verb+--+\\[1em]

\end{array}
\]


            % abstract SourceElement();
            % abstract Expr();
            % abstract Property();
            % abstract Name();
            %     abstract IdOrOpOrAnonymousName();
            %         abstract IdOrOp(String text);
            %             Id();
            %             Op();
            %         AnonymousFnName();
            % Label(Id id);

{\inred
\begin{itemize}
\item {\tt VarDecl}: The {\tt expr} field is {\tt None} after {\tt Hoister}.
\item {\tt VarStmt}, {\tt ForVar}, {\tt ForVarIn}: Removed by {\tt Hoister}.
\item {\tt RegularExpression}: Not yet supported.
\end{itemize}
}

{\inblue
\begin{itemize}
\item {\tt StmtUnit}: Internally generated statement unit by {\tt Hoister}.
\end{itemize}
}

\newpage
\newcommand{\ir}[1]{\ensuremath{\underline{#1}}}
\newcommand{\irid}{\ir{x}}
\newcommand{\irstmt}{\ir{\stmt}}
\newcommand{\irexpr}{\ir{\expr}}
%\newcommand{\msf}[1]{\mbox{\sf\footnotesize #1}}
\section{IR}
\small
\[
\begin{array}{l@{~~}l@{~~}ll}
\ir\pgm & ::= & \ir\stmt^* & \mtt{IRRoot(List<IRFunDecl> fds, List<IRVarStmt> vds, List<IRStmt> irs)}\\

\ir\stmt & ::= & \irid \ \verb+=+ \ \ir\expr & \mtt{IRExprStmt(IRId lhs, IRExpr right, boolean ref = false)}\\
 &\mid& \irid \ \verb+=+ \ {\sf delete}\ \irid
 & \mtt{IRDelete(IRId lhs, IRId id)}\\

 &\mid& \irid \ \verb+=+ \ {\sf delete}\ \irid\verb+[+\irid\verb+]+
 & \mtt{IRDeleteProp(IRId lhs, IRId obj, IRId index)}\\

 &\mid& \irid\verb+[+\irid\verb+] =+ \ \irexpr & \mtt{IRStore(IRId obj, IRId index, IRExpr rhs)}\\
 &\mid& \irid \ \verb+=+ \ \verb+{+ (\ir\member\verb+,+)^* \verb+}+& \mtt{IRObject(IRId lhs, List<IRMember> members, Option<IRId> proto)}\\
 &\mid& \irid \ \verb+=+ \ \verb+[+ (\irexpr\verb+,+)^* \verb+]+ & \mtt{IRArray(IRId lhs, List<Option<IRExpr>> elements)}\\
&&&\mtt{IRArgs(IRId lhs, List<Option<IRExpr>> elements)}\\

 &\mid& \irid \ \verb+=+ \ \irid\verb+(+\irid\verb+,+\irid\verb+)+
 & \mtt{IRCall(IRId lhs, IRId fun, IRId thisB, IRId args)}\\
 &\mid& \irid \ \verb+=+ \ \irid\verb+(+\irid(\verb+,+\irid)^?\verb+)+
& \mtt{IRInternalCall(IRId lhs, IRId fun, IRExpr first, Option<IRId> second)}\\
&&&{\inblue \mtt{toObject}, \mtt{toString}, \mtt{toNumber}, \mtt{isObject},
\mtt{getBase}, \mtt{iteratorInit}, \mtt{iteratorHasNext}, \mtt{iteratorKey}}\\

 &\mid& \irid \ \verb+=+ \ {\sf new}\ \irid\verb+(+(\irid\verb+,+)^*\verb+)+
 & \mtt{IRNew(IRId lhs, IRId fun, List<IRId> args)}\\
 &\mid& \irid \ \verb+=+ \ {\sf function} \ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
& \mtt{IRFunExpr(IRId lhs, IRFunctional ftn)}\\
&&&\mtt{IRFunctional(IRId name, List<IRId> params, List<IRStmt> args,}\\
&&&\mtt{\phantom{IRFunctional(}List<IRFunDecl> fds, List<IRVarStmt> vds, List<IRStmt> body)}\\

 &\mid& {\sf function} \ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 & \mtt{IRFunDecl(IRFunctional ftn)}\\

 &\mid& \irid \ \verb+=+ \ {\sf eval}\verb+(+\ir\expr\verb+)+ & \mtt{IREval(IRId lhs, IRExpr arg)}\\
 &\mid& {\sf break} \ \irid & \mtt{IRBreak(IRId label)}\\
 &\mid& {\sf return} \ \irexpr^?& \mtt{IRReturn(Option<IRExpr> expr)}\\
 &\mid& {\sf with} \ \verb+(+\irid\verb+)+ \ \ir\stmt & \mtt{IRWith(IRId id, IRStmt stmt)}\\

 & \mid & \ir{l} \; \verb+: {+ \; \ir\stmt \; \verb+}+
 & \mtt{IRLabelStmt(IRId label, IRStmt stmt)}\\


 &\mid& {\sf var} \ \irid& \mtt{IRVarStmt(IRId lhs)}\\
 &\mid& {\sf throw} \ \irexpr& \mtt{IRThrow(IRExpr expr)}\\
 &\mid& {\ir\stmt}^*& \mtt{IRSeq(List<IRStmt> stmts)}\\
 &\mid& {\sf if} \ \verb+(+\irexpr\verb+)+\ {\sf then} \ \ir\stmt \ ({\sf else} \ \ir\stmt)^?
& \mtt{IRIf(IRExpr expr, IRStmt trueB, Option<IRStmt> falseB)}\\
 &\mid& {\sf while} \ \verb+(+\irexpr\verb+)+\ \ir\stmt& \mtt{IRWhile(IRExpr cond, IRStmt body)}\\
 &\mid& {\sf try} \ \verb+{+ \ir\stmt \verb+}+ \
({\sf catch} \ \verb+(+\irid\verb+){+ \ir\stmt \verb+}+)^? \
({\sf finally} \ \verb+{+ \ir\stmt \verb+}+)^?
& \mtt{IRTry(IRStmt body, Option<IRId> name, Option<IRStmt> catchB,}\\
&&&\mtt{\phantom{IRTry(}Option<IRStmt> finallyB)}\\
&\mid& \open {\ir\stmt}^* \close & \mtt{IRStmtUnit(List<IRStmt> stmts)}\\\\

\ir\expr &::=&
 \irexpr \ \inop \irexpr & \mtt{IRBin(IRExpr first, IROp op, IRExpr second)}\\
 &\mid& \preop \irexpr & \mtt{IRUn(IROp op, IRExpr expr)}\\
 &\mid& \irid\verb+[+\ir\expr\verb+]+ & \mtt{IRLoad(IRId obj, IRExpr index)}\\
 &\mid& \irid& \mtt{IRUserId(String text)}\\
 &\mid& \newvar{x}& \mtt{IRTmpId(String text)}\\
 &\mid& \ir\num & \mtt{IRNumber(ignoreForEquals String text, Double num)}\\
 &\mid& \ir\str & \mtt{IRString(String str)}\\
 &\mid& {\sf true} & \mtt{IRBool(boolean bool)}\\
 &\mid& {\sf false} & \mtt{IRBool(boolean bool)}\\
 &\mid& {\sf undefined} & \mtt{IRUndef()}\\
 &\mid& {\sf null} & \mtt{IRNull()}\\
 &\mid& {\sf this} & \mtt{IRThis()}\\\\

\ir\member &::=& \irid \ \verb+:+ \ \irexpr & \mtt{IRField(IRId prop, IRExpr expr)}\\
 &\mid& {\tt get}\ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 &\mtt{IRGetProp(IRFunctional ftn)}\\
 &\mid& {\tt set}\ \ir{f} \verb+(+\irid\verb+,+\irid\verb+) {+ \ir\stmt^* \verb+}+
 &\mtt{IRSetProp(IRFunctional ftn)}\\

\end{array}
\]

Assumptions and notations:
\begin{itemize}
\item Functions and variables are hoisted to their closest enclosing functions
or the top level via {\tt Hoister}.
\item Identifiers and labels that exist in the source program,
except when they appear at top level or within the {\tt with} statement,
are already disambiguated via {\tt Disambiguator},
so that they have unique names.
\item We use $\env$ to disambiguate the generated labels and temporary variables in the AST to IR translation.
For the presentation brevity, we simply add the newly generated names to $\env$.
\begin{itemize}
\item In the actual implementation, we need to create a unique id for each generated name and
add the binding information from the general name to the unique id to $\env$.
For example, when we say ``$\env; \newvar{break}$'',
we actually create a unique id for $\newvar{break}$, say $\newvar{break}_{42}$, and add it to $\env$ as $\env; \newvar{break} \mapsto \newvar{break}_{42}$.
When we look up the environment by $\env(\newvar{break})$, the unique $\newvar{break}_{42}$ is returned.
\item In the scope when the generated name is created, we don't add it to the environment but use the unique id instead of the general name.
For example, when we say ``$\newvar{eq}\ \verb+=+\ \env(\newvar{val}) \verb+===+ \newvar{break};$'',
we create a unique id for \newvar{eq}, say $\newvar{eq}_{910157}$, and it is acually
``$\newvar{eq}_{910157}\ \verb+=+\ \env(\newvar{val}) \verb+===+ \newvar{break}_{42};$''.
\item To be clear, we use blue for the binding sites of such names and red for the use sites of such names.
\end{itemize}
\item We denote a list as a possibly empty, semicolon-separated sequence, enclosed by $\langle$ and $\rangle$.
\item We denote a series of list appends as superscripted $*$ such as $\stmt^*$.
\item We denote a fresh variable name as $\newvar{}$ and its variants.
\item We abuse our notations by mixing semicolon-separated sequences and lists.
\item We use the following:\\
\verb+===+, {\sf \ensuremath{\diamond}toBoolean}, {\sf \ensuremath{\diamond}toObject}, {\sf \ensuremath{\diamond}toNumber}, {\sf \ensuremath{\diamond}toString}, {\sf \ensuremath{\diamond}isObject},
{\sf \ensuremath{\diamond}iteratorInit}, {\sf \ensuremath{\diamond}iteratorHasNext}, {\sf \ensuremath{\diamond}iteratorNext},
% {\sf startsWith},
{\sf \ensuremath{\diamond}global}, {\sf \ensuremath{\diamond}getBase}
\item To denote an AST-level statement granularity in the translated IR statements,
we use {\tt IRStmtUnit} which is represented as green angle brackets {\ingreen $\open\ \close$} in this document.
To reduce the number of temporary variables, we use global variables to denote constants such as {\sf 1} and
{\sf true} which is represented in green {\ingreen\sf 1} and  {\ingreen\sf true} in this document.
\item We wrap a possibly identical assignment with a box so that the actual implementation, {\tt Translator}, can eliminate identical assignments.
\end{itemize}


\newpage
\section{AST to IR}
\[
\begin{array}{l@{~:~}l}
\env& \verb+Env+\\
\atoiP& \verb+Program -> IRRoot+\\
\atoiFD& \verb+FunDecl -> Env -> IRFunDecl+\\
\atoiVD& \verb+VarDecl -> Env -> IRVarStmt+\\
\atoiS& \verb+Stmt -> Env -> IRStmtUnit+\\
%\atoiCC& \verb+Case -> Env -> Option[Stmt] => List[IRStmt]+\\
\atoiC& \verb+List[Case] * Option[List[Stmt]] * List[Case] -> Env -> List[Option[Expr] * IRId] -> IRStmt+\\
\atoiSC& \verb+List[Option[Expr] * IRId] -> Env -> IRStmt+\\
\atoiLVAL& \verb+Expr -> Env -> List[IRStmt] -> IRExpr -> boolean -> List[IRStmt] * IRExpr+\\
\atoiE& \verb+Expr -> Env -> IRId -> List[IRStmt] * IRExpr+\\
\atoiLHS& \verb+LHS -> Env -> IRId -> List[IRStmt] * IRExpr+\\
\atoiLIT& \verb+LIT -> Env -> IRId -> List[IRStmt] * IRExpr+\\
\atoiM& \verb+Member -> Env -> IRId -> List[IRStmt] * IRMember+\\
\atoiPR& \verb+Property -> IRId+\\
%\atoi& \verb++\\
\end{array}
\]

\[
%\begin{array}{l@{}l@{~}l}
\begin{array}{lll}
\atoiPf{\fd^*\ \vd^*\ \stmt^*}
&=&\langle (\atoiFDf{\fd}{\emptyenv})^*\ (\atoiVDf{\vd}{\emptyenv})^*\ (\atoiSf{\stmt}{\emptyenv})^* \rangle
\\[1em]

\atoiFD\lbr{ {\tt function} \ f \verb+(+(x\verb+,+)^*\verb+)+ \ \verb+{+ \fd^* \vd^* \stmt^* \verb+}+}\rbr(\env)
&=&
{\sf function} \ \ir{f} \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad
(\ir{x_i} = {\inred\newvar{arguments}}\verb+["i"]+)^*\\
&&\quad
(\atoiFDfd{\fd})^*\\
&&\quad
(\atoiVDf{\vd}\env)^*\\
&&\quad
(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+
\\
\lefteqn{\note{
A function always receives explicit ``this'' and ``arguments'' arguments
so that the desugaring of {\tt this} and {\tt arguments}}}\\
\lefteqn{\note{ is correct.
Currently, ``arguments'' denotes copies of the arguments instead of their aliases.
An early exit from a function
}}\\
\lefteqn{\note{
using {\tt return} statements is
rewritten as a non-local jump to the label \newvar{return}.
}}\\[.5em]

% var
\atoiVD\lbr {\tt var} \ x \rbr(\env)
&=& {\sf var}\ \atoiEfd{x}({\inred\newvar{\_}})
\\[1em]



% block
\atoiS\lbr \verb+{+\stmt^*\verb+}+ \rbr(\env)
&=& \open(\atoiSfd{\stmt})^*\close
\\

% empty
\atoiS\lbr \verb+;+ \rbr(\env)
&=& \open \close
\\

% expr stmt
\atoiS\lbr e\verb+;+ \rbr(\env)
&=& \mbox{LET\ } (\ir\stmt^*, \ir\expr) = \atoiEfd{e}({\inred\newvar{\_}})\\
& & \mbox{IN}\hspace*{1.2em}
\open\ir\stmt^*\verb+;+\ \fbox{{\inred\newvar{\_}}\ {\tt =} \ \irexpr}\close

%\open\atoiEfd{e}({\inblue\newvar{\_}})\close
\\

% if &&
\atoiS\lbr \verb+if+ \ \verb+(+e_1 \verb+&&+ e_2\verb+)+\ s_1\ (\verb+else+\ s_2)^? \rbr(\env)
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
& & \mbox{IN}\hspace*{1.2em}
\open\irstmt_1^*\verb+;+\ \irstmt_2^*\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\sf if\ (} {\irexpr_1} {\sf )\ then\ }
{\sf if\ (} {\irexpr_2} {\sf )\ then\ } \verb+{+\atoiSfd{s_1}\verb+;+\
{\sf break}\ {\inred\newvar{label}}\verb+};+
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
(\atoiSfd{s_2})^?
\verb+}+\close\\

% label : {
%   if (e1) {
%     if (e2) {
%       s_1
%       break label
%     }
%   }
%   s_2
% }

% if ||
\atoiS\lbr \verb+if+ \ \verb+(+e_1 \verb+||+ e_2\verb+)+\ s_1\ (\verb+else+\ s_2)^? \rbr(\env)
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
& & \mbox{IN}\hspace*{1.2em}
\open\irstmt_1^*\verb+;+\ \irstmt_2^*\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label_2}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\inblue \newvar{label_1}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (} {\irexpr_1} {\sf )\ then\ } {\sf break}\ {\inred\newvar{label_1}}\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (} {\irexpr_2} {\sf )\ then\ } {\sf break}\ {\inred\newvar{label_1}}\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
(\atoiSfd{s_2}\verb+;+\ {\sf break})^?\ {\inred\newvar{label_2}}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
\verb+};+\ \atoiSfd{s_1}\verb+}+\close\\

% label2: {
%   label1: {
%     if (e1) {
%       break label1
%     }
%     if (e2) {
%       break label1
%     }
%     s_2
%     break label2
%   }
%   s_1
% }


% \atoiS\lbr \verb+if+ \ \verb+(+e_1 \verb+||+ e_2\verb+)+\ s_1\ (\verb+else+\ s_2)^? \rbr(\env)
% &=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
% & & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
% & & \mbox{IN}\hspace*{1.2em}
% \open\irstmt_1^*\verb+;+\ \irstmt_2^*\verb+;+\\
% & & \phantom{\mbox{IN}\hspace*{1.2em}\open}
% {\sf if\ (} {\irexpr_1} {\sf )\ then\ } \atoiSfd{s_1}\\
% & & \phantom{\mbox{IN}\hspace*{1.2em}\open{\sf if\ (} {\irexpr_1} {\sf )\ }}
% {\sf else\ } {\sf if\ (} {\irexpr_2} {\sf )\ then\ } \atoiSfd{s_1}\ 
% ({\sf else\ } \atoiSfd{s_2})^?
% \close\\
% % if (e1) {
% %   s_1
% % } else if (e2) {
% %   s_1
% % } else s_2


% if
\atoiS\lbr \verb+if+ \ \verb+(+e \verb+)+\ s_1\ (\verb+else+\ s_2)^? \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{new}})\\
& & \mbox{IN}\hspace*{1.2em}
\open\irstmt^*\verb+;+\
{\sf if\ (} {\irexpr} {\sf )\ then\ } \atoiSfd{s_1}\ ({\sf else\ } \atoiSfd{s_2})^?
\close\\


% \open
% \atoiEfd{e}({\inblue\newva})\\
% &&
% \phantom{\langle}
% {\inblue\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva});}
% \\
% &&
% \phantom{\langle}
% {\sf if (} {\inred\newvb} {\sf )\ then\ } {\sf IRSeq(}\ \atoiSfd{s_1}\ {\sf )}\
% ({\sf else\ } {\sf IRSeq(}\ \atoiSfd{s_2}\ {\sf )})^?
% \close
% \\


%% 2nd trial
%%
% %% switch
% \atoiS\lbr \verb+switch(+e \verb+){+\cc_1^*\ (\verb+default:+s)^?\ \cc_2^* \verb+}+ \rbr(\env)
% &=&\langle
% {\inblue\newvar{break}} \; \verb+:+ \; \verb+{+ \ {\sf IRSeq(} \langle
% \\&&
% \quad
% \atoiEfd{e}({\inblue\newvar{val}}) \verb+;+\
% {\inblue\newvar{found}}\ \verb+=+ \ {\sf false} \verb+;+\
% {\inblue\newvar{default}}\ \verb+=+ \ {\sf false} \verb+;+
% \\&&
% \quad
% (\atoiCCf{\cc_1}{\env; \newvar{break}; \newvar{val}; \newvar{found}; \newvar{default}})^*
% \\&&
% \quad
% (
% {\sf if\ (} {\inred\newvar{found}} {\sf )\ then}\ {\sf IRSeq(} \langle
% \atoiSf{\stmt}{\env; \newvar{break}}\verb+;+\
% {\inred\newvar{default}}\ \verb+=+ \ {\sf true}
% \rangle{\sf)})^?
% \\&&\quad
% (\atoiCCf{\cc_2}{\env; \newvar{break}; \newvar{val}; \newvar{found}; \newvar{default}})^*
% \\&&
% \quad
% {\inblue\newvar{cond}}\ \verb+=+ \ {\inred\newvar{default}}\ \verb+||+ {\inred\newvar{found}}\verb+;+
% \\&&
% \quad
% (
% {\sf if\ (} {\inred\newvar{cond}} {\sf )\ then}\ {\sf IRSeq(} \emptyenv{\sf)}
% \\&&\quad\phantom{(}
% {\sf else\ IRSeq(} \langle
% \atoiSf{\stmt}{\env; \newvar{break}}\verb+;+\
% {\inred\newvar{default}}\ \verb+=+ \ {\sf true}\verb+;+
% \\&&\quad\phantom{({\sf else\ IRSeq(} \langle}
% (\atoiCCf{\cc_2}{\env; \newvar{break}; \newvar{val}; \newvar{found}; \newvar{default}})^*
% \rangle{\sf)})^?
% \\&&
% \rangle
% {\sf )}\verb+}+\rangle
% \\

% \atoiCC\lbr {\tt case} \ \expr \; \verb+:+ \; \stmt^{*} \rbr(\env)
% &=&\langle
% {\inblue\newvar{cond_1}}\ \verb+=+ \ \env(\newvar{default})\ \verb+||+ \env(\newvar{found})\verb+;+
% \\&&\phantom{\langle}
% {\sf if\ (}{\inred\newvar{cond_1}}{\sf)\ then\ IRSeq(}\emptyenv{\sf)}\\
% &&\phantom{\langle}
% {\sf else\ IRSeq(}\langle\ \atoiEfd{\expr}({\inblue\newvar{cond_2}})\verb+;+\\
% &&\phantom{\langle{\sf else\ IRSeq(}\langle\ }
% {\inblue\newvar{eq}}\ \verb+=+\ \env(\newvar{val}) \verb+===+ {\inred\newvar{cond_2}}\verb+;+\\
% &&\phantom{\langle{\sf else\ IRSeq(}\langle\ }
% {\sf if\ ({\inred\newvar{eq}})\ then}\ \env(\newvar{found}) \verb+=+ {\sf true}\ \rangle{\sf)}\verb+;+\\
% &&\phantom{\langle}
% {\inred\newvar{cond_1}}\ \verb+=+ \ \env(\newvar{default})\ \verb+||+ \env(\newvar{found})\verb+;+
% \\&&\phantom{\langle}
% {\sf if\ (}{\inred\newvar{cond_1}}{\sf)\ then\ IRSeq(}\langle\
% (\atoiSfd{\stmt})^*\ \rangle{\sf )}\rangle
% \\


%% 1st trial
%%
% switch
% \atoiS\lbr \verb+switch(+e \verb+){+\cc_1^*\ (\verb+default:+s)^?\ \cc_2^* \verb+}+ \rbr(\env)
% &=&\langle
% {\inblue\newvar{break}} \; \verb+:+ \; \verb+{+ \ {\sf IRSeq(} \langle
% \\&&
% \quad
% \atoiEfd{e}({\inblue\newvar{val}}) \verb+;+
% {\inblue\newvar{testing}}\ \verb+=+ \ {\sf true} \verb+;+
% {\inblue\newvar{keepgoing}}\ \verb+=+ \ {\sf true} \verb+;+
% \\&&
% \quad
% (\atoiCCf{\cc_1}{\env; \newvar{break}; \newvar{val}; \newvar{testing}})^*
% \\&&
% \quad
% ({\sf while\ (} {\inred\newvar{keepgoing}} {\sf )}
% \\&&
% \quad\quad
% {\sf IRSeq(}\langle\
%   {\sf if\ (} {\inred\newvar{testing}} {\sf )\ then}\
%   {\inblue\newvar{\_}}\; \verb+=+ \; {\tt undefined}\
%   {\sf else}\ {\sf IRSeq(}\ \atoiSfd{s}\ {\sf )}
% \verb+;+
% \\&&
% \quad\quad\quad\quad\quad
% \phantom{\langle}
%   (\atoiCCf{\cc_2}{\env; \newvar{break}; \newvar{val}; \newvar{testing}})^*
% \\&&
% \quad\quad\quad\quad\quad
% \phantom{\langle}
%   {\sf if\ (} {\inred\newvar{testing}} {\sf )\ then}\
%   {\inred\newvar{testing}}\; \verb+=+ \; {\sf false}\
%   {\sf else}\ {\inred\newvar{keepgoing}}\ \verb+=+ {\sf false}
% \rangle
% {\sf )}
% )^?
% \\&&
% \rangle
% {\sf )}\verb+}+\rangle
% \\


% \atoiCC\lbr {\tt case} \ \expr \; \verb+:+ \; \stmt^{*} \rbr(\env)
% &=&
% \langle
% {\sf if\ (}\env(\newvar{testing}){\sf)}\\
% &&
% \phantom{\langle}
% {\sf then\ IRSeq(}\langle
% \atoiEfd{\expr}({\inblue\newvar{cond}});\\
% &&
% \phantom{\langle{\sf then\ IRSeq(}\langle}
% {\inblue\newvar{eq}}\ \verb+=+\ \env(\newvar{val}) \verb+===+ {\inred\newvar{cond}};\\
% &&
% \phantom{\langle{\sf then\ IRSeq(}\langle}
% {\sf if\ ({\inred\newvar{eq}})\ then\ \env(\newvar{testing}) \verb+=+ false} \rangle{\sf);}\\
% &&
% \phantom{\langle}
% {\sf if\ (}\env(\newvar{testing}){\sf)\ then\ {\inblue\newvar{\_}} \verb+=+ undefined\
% else\ IRSeq(}\ (\atoiSfd{\stmt})^*\ {\sf )}
% \rangle
% \\

% \lefteqn{\note{
% We introduce one label \newvar{break} and two variables, \newvar{testing} and \newvar{keepgoing},
% to denote the current status.}}\\
% \lefteqn{\note{
% Initially \newvar{testing} is {\sf true} meaning that the conditions are to be
% evaluated,}}\\
% \lefteqn{\note{
% and \newvar{keepgoing} is also {\sf true} meaning that the {\tt default}
% case is to be evaluated.
% }}\\
% \lefteqn{\note{
% \newvar{testing} is set to {\sf false} when a matching case is found, or no matching case is found
% after the lexically last case.
% }}\\
% \lefteqn{\note{
% In the latter case, the control flow moves back to the start of the {\tt default} case, if any,
% via {\sf while}.
% }}\\
% \lefteqn{\note{
% When \newvar{testing} is {\sf false} and the control flow reaches the end of {\tt switch},
% \newvar{keepgoing} is set to {\sf false} so that the {\sf while} loop terminates.
% }}\\


%% switch
\atoiS\lbr \verb+switch (+e \verb+) {+\cc_1^*\ (\verb+default:+s^*)^?\ \cc_2^* \verb+}+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{val}})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open\quad}
\irstmt^*\verb+;+\ \fbox{{\inred\newvar{val}} \; {\tt =} \; \irexpr{\tt;}}
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open\quad}
 \atoiC\lbr({\sf rev}\ \cc_2^*) (s^*)^? ({\sf rev}\  \cc_1^*)\rbr
({\env; {\inred\newvar{break}}; {\inred\newvar{val}}})\verb+}+\close
\\

%% case
\atoiC \lbr ({\tt case} \ \expr \; \verb+:+ \; \stmt_1^{*})::cc_2^{*} \ (\stmt_2^*)^?\  cc_1^{*} \rbr
(\env)(c^{*})
&=&\langle
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+
  \atoiC \lbr cc_2^{*} \ (\stmt_2^*)^{?}\  cc_1^{*} \rbr(\env)(({e,\inred \newvar{label}})::c^{*}) \verb+};+
\\&&\phantom{\langle}
 (\atoiS\lbr \stmt_1 \rbr(\env))^{*}
\rangle
\\
\atoiC \lbr () \ (\stmt^{*})^{?}\  cc_1^{*} \rbr(\env)(c^{*})
&=&\langle
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+
  \atoiC \lbr () \ ()\  cc_1^{*} \rbr(\env)(c^{*}@[({(),\inred \newvar{label}})])\verb+};+
\\&&\phantom{\langle}
 ((\atoiS\lbr \stmt \rbr(\env))^{*})^{?}
\rangle
\\
\atoiC \lbr () \ () \ ({\tt case} \ \expr \; \verb+:+ \; \stmt^{*})::cc_1^{*} \rbr(\env)(c^{*})
&=&\langle
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+
  \atoiC \lbr () \ ()\  cc_1^{*} \rbr(\env)(({e,\inred \newvar{label}})::c^{*}) \verb+};+
\\&&\phantom{\langle}
 (\atoiS\lbr \stmt \rbr(\env))^{*}
\rangle
\\
\atoiC \lbr () \ () \ () \rbr(\env)((e, \ir{l})^{*})
&=&\langle
  \atoiSC \lbr (e,\ir{l})^{*} \rbr(\env)\verb+;+
\\&&\phantom{\langle}
   {\sf break}\ \env(\newvar{break})
 \rangle
\\
\atoiSC \lbr (e,\ir{l})::(c^{*}) \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{cond}})\\
& & \mbox{IN}\hspace*{1.2em}
\langle\irstmt^*\verb+;+\
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
 {\sf if\ (}\env(\newvar{val}) \; \verb+===+ \; \irexpr
{\sf)\ then\ break}\ \ir{l}\ {\sf else\ }\atoiSC\lbr c^{*}\rbr(\env)\rangle
\\

\atoiSC \lbr [((),\ir{l})] \rbr(\env)
&=&\langle
 {\sf break}\ \ir{l}\rangle
\\
\atoiSC \lbr () \rbr(\env)
&=&\langle\rangle
\\
\lefteqn{\note{
Where $c$ is either $(\expr, \ir{l})$ or $((), \ir{l})$.
}}

\end{array}
\]

\[
\begin{array}{l@{}l@{~}l}

%% do-while
\atoiS\lbr \verb+do+\ s\  \verb+while (+ e \verb+);+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inred\newvar{cond}})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
{\inblue\newvar{cond}}\ \verb+=+\ {\sf true;}
\\&&
\qquad\qquad
{\sf while\ ({\inred\newvar{cond}})}\ \verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+
\\&&
\qquad\qquad\quad
\irstmt^*\verb+;+
\fbox{{\inred\newvar{cond}} {\tt =} \irexpr}\\
%\atoiEfd{e}({\inred\newvar{cond}})\\
&&\qquad\qquad
\verb+}+
% \\&&
% {\inred\newvar{cond}}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva})}
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\

%% while
\atoiS\lbr  \verb+while (+ \expr \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
\irstmt^*\verb+;+
%%%\fbox{{\inred\newva} {\tt =} \irexpr}
%\atoiEfd{\expr}({\inblue\newva}) \verb+;+
% \\&&\quad
% {\inblue\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva});}
\\&&
\qquad\qquad
{\sf while\ (}\irexpr{)} \;\verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}}\verb+};+
\\&&
\qquad\qquad\quad
\irstmt^*\verb+;+
%%%\fbox{{\inred\newva} {\tt =} \irexpr}
% \\&&
% \qquad\qquad\quad
% \atoiEfd{e}({\inred\newva}) \verb+;+
% \\&&\quad\quad
% {\inred\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newva})}
\\&&
\qquad\qquad\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\



%% for-none
\atoiS\lbr  \verb+for (+ e_1^? \verb+;+ \verb+;+e_3^? \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } ((\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inred\newvar{\_}}))^?\\
& & \phantom{\mbox{LET\ }} ((\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}({\inred\newvar{\_}}))^?\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
(\irstmt_1^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_1$})^?
\\&&
\qquad\qquad
{\sf while\ ({\ingreen true})} \; \verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}}\verb+};+
\\&&
\qquad\qquad\quad
(\irstmt_3^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_3$})^?
%(\atoiEfd{e_3}({\inblue\newvar{\_}}) \verb+;+)^?
\\&&\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\



%% for-some
\atoiS\lbr  \verb+for (+ e_1^? \verb+;+e_2 \verb+;+e_3^? \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } ((\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inred\newvar{\_}}))^?\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvb})\\
& & \phantom{\mbox{LET\ }} ((\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}({\inred\newvar{\_}}))^?\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&
\qquad\qquad
(\irstmt_1^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_1$})^?
\\&&
\qquad\qquad
\irstmt_2^*\verb+;+
%%%\fbox{{\inred\newvb} {\tt =} $\irexpr_2$}\verb+;+
%\atoiEfd{e_2}({\inblue\newvb}) \verb+;+
% \\&&\quad
% {\inblue\newvc}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newvb});}
\\&&
\qquad\qquad
{\sf while\ (}\irexpr_2{)} \; \verb+{+
\\&&
\qquad\qquad\quad
{\inblue\newvar{continue}} \; \verb+:+ \;
\verb+{+ \atoiSf{s}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+
\\&&
\qquad\qquad\quad
(\irstmt_3^*\verb+;+
\fbox{{\inred\newvar{\_}} {\tt =} $\irexpr_3$})^?
%(\atoiEfd{e_3}({\inblue\newvc}) \verb+;+)^?
\\&&
\qquad\qquad\quad
\irstmt_2^*\verb+;+
%%%\fbox{{\inred\newvb} {\tt =} $\irexpr_2$}\verb+;+
%\atoiEfd{e_2}({\inred\newvb}) \verb+;+
% \\&&\quad\quad
% {\inred\newvc}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean({\inred\newvb});}
\\&&
\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\


%% for-in
\atoiS\lbr  \verb+for (+ \lhs\ \verb+in+\ e \verb+)+\ s\rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open
{\inblue\newvar{break}} \; \verb+:+ \; \verb+{+
\\&&\qquad\qquad
\irstmt^*\verb+;+
%%%\fbox{{\inred\newva} {\tt =} \irexpr}
\\&&\qquad\qquad
  {\inblue\newvar{obj}} \ \verb+=+\ {\sf \ensuremath{\diamond}toObject}\verb+(+\irexpr\verb+)+\verb+;+\\
&&\qquad\qquad
  {\inblue\newvar{iterator}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorInit(}{\inred\newvar{obj}}{\sf)}\verb+;+
\\&&\qquad\qquad
  {\inblue\newvar{cond_1}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorHasNext(}{\inred\newvar{obj}}\verb+,+ {\inred\newvar{iterator}}{\sf)}\verb+;+
\\
&&\qquad\qquad
  {\sf while} \ \verb+(+{\inred\newvar{cond_1}}\verb+) {+\\
&&\qquad\qquad\quad
    {\inblue\newvar{key}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorNext(}{\inred\newvar{obj}}\verb+,+ {\inred\newvar{iterator}}{\sf)}\verb+;+
\\&&\qquad\qquad\quad
      \atoiLVALf{\lhs}{\env}(;\ {\inred\newvar{key}})(\false).\_1\verb+;+\\
&&\qquad\qquad\quad
      {\inblue\newvar{continue}}\verb+:{+ \atoiSf{\stmt}{\env;{\inred\newvar{break}};{\inred\newvar{continue}}} \verb+};+\\
&&\qquad\qquad\quad
  {\inred\newvar{cond_1}} \ \verb+=+ \ {\sf \ensuremath{\diamond}iteratorHasNext(}{\inred\newvar{obj}}\verb+,+ {\inred\newvar{iterator}}{\sf)}\verb+;+
\\
&&\qquad\qquad
\verb+}+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}\open}
\verb+}+\close
\\


% 
% \atoiS\lbr  \verb+for (var+ \ (vd,)^*\verb+,+e_1^? \verb+,+e_2^? \verb+)+\ s\rbr(\env)
% &=&
% 
% \langle
% (\atoiVDfd{vd})^*\verb+;+\
% \atoiS\lbr  \verb+for (+ \verb+,+e_1^? \verb+,+e_2^? \verb+)+\ s\rbr(\env)
% \rangle
% \\


% \atoiS\lbr
% \verb+for (var+ \ x \ \verb+in+ \ \expr \verb+)+ \ \stmt
% \rbr(\env)
% &=&
% \atoiS\lbr
% \verb+for (+ x \ \verb+in+ \ \expr \verb+)+ \ \stmt
% \rbr(\env)
% \\

% \atoiS\lbr
% \verb+for (var+ \ x \ \verb+=+ \ \expr \ \verb+in+ \ \expr' \verb+)+ \ \stmt
% \rbr(\env)
% &=&
% \atoiS\lbr
% \verb+{+ \
% x \ \verb+=+ \ \expr \verb+;+ \
% \verb+for (+ x \ \verb+in+ \ \expr' \verb+)+ \ \stmt
% \ \verb+}+
% \rbr(\env)
% \\


% continue 1
\atoiS\lbr  \verb+continue;+ \rbr(\env)
&=&\open
{\sf break}\ \env(\newvar{continue})
\close\\


% continue 2
\atoiS\lbr  \verb+continue+ \ l\verb+;+ \rbr(\env)
&=&\open
%{\sf break}\ \env(\newvar{continue})
{\sf break}\ \ir{l}
\close\\


%% break 1
\atoiS\lbr  \verb+break;+\rbr(\env)
&=&\open
{\sf break}\ \env(\newvar{break})
\close\\


%% break 2
\atoiS\lbr  \verb+break+ \ l\verb+;+ \rbr(\env)
&=&\open
{\sf break}\ \ir{l}
\close\\


%% return 1
\atoiS\lbr  \verb+return;+ \rbr(\env)
&=&\open
{\sf return}
\close\\


%% return 2
\atoiS\lbr  \verb+return+ \ e \verb+;+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\langle\irstmt^*\verb+;+\
{\sf return}\ \irexpr
\close\\

%
% \atoiS\lbr  \verb+with(+ e \verb+)+\ s \rbr(\env)
% &=&\langle
% \atoiEfd{e}(\newva) \verb+;+
% \\&&
% \phantom{\langle}
% \newvb\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(\newva);}
% \\&&
% \phantom{\langle}
% \atoiS\lbr s\rbr(\env\verb+;+\;\newvb)\rangle
% \\


\end{array}
\]

\[
\begin{array}{l@{~}l@{~}l}


%% with
\atoiS\lbr  \verb+with (+ e \verb+)+\ s \rbr(\env)
&=& \mbox{LET\ } (\ir\stmt^*, \ir\expr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open\ir\stmt^*\verb+;+\
\\&& \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue\newvb}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr{\sf);}
\\&& \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\sf with\ (}{\inred\newvb}{\sf)}\
\atoiS\lbr s\rbr(\env)
\close
\\

%% labelled statement
\atoiS\lbr  l\ \verb+:+\ s \rbr(\env)
&=& \open
\ir{l}\ \verb+:+\ \verb+{+\ \atoiSfd{s} \ \verb+}+\close
\\

%% throw
\atoiS\lbr \verb+throw+\ e \verb+;+ \rbr(\env)
&=& \mbox{LET\ } (\irstmt^*, \ir\expr) = \atoiEfd{e}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
\open\ir\stmt^*\verb+;+\
{\sf throw}\ \irexpr
\close
\\

%% try
\atoiS\lbr \verb+try {+s_1^* \verb+}+\
  (\verb+catch(+x \verb+){+s_2^* \verb+}+)^?
  (\verb+finally {+s_3^* \verb+}+)^? \rbr(\env)
&=&\open
{\sf try} \ \verb+{+ (\atoiSfd{s_1})^* \verb+}+
\\&&\phantom{\langle}
(\verb+catch(+\ir{x} \verb+){+ (\atoiSfd{s_2})^* \verb+}+)^?
\\&&\phantom{\langle}
(\verb+finally {+ (\atoiSfd{s_3})^* \verb+}+)^?
\close
\\

\atoiS\lbr \verb+debugger;+ \rbr(\env)
&=&\langle\rangle
\\[1em]

\atoiLVAL\lbr \verb+(+\expr\verb+)+\rbr(\env)(\ir{\stmt}^*; \ir{\expr}')(\kold)
&=&
\atoiLVAL\lbr \expr\rbr(\env)(\ir{\stmt}^*; \ir{\expr}')(\kold)
\\

\atoiLVAL\lbr x \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
&=&\mbox{IF keepOld THEN\ }
(\langle
{\inblue\newvar{old}}\ \verb+=+\ \ir{x}\verb+;+\
\ir{\stmt}^*\verb+;+\
\ir{x}\ \verb+=+\ \ir{\expr}
\rangle, \ir{x})
\\
&&\mbox{ELSE\ }
\langle
\ir{\stmt}^*\verb+;+\
\ir{x}\ \verb+=+\ \ir{\expr}
\rangle
\\

\atoiLVAL\lbr \lhs\verb+.+x \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
&=&
\atoiLVAL\lbr \lhs\verb+["+x\verb+"]+ \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
\\

\atoiLVAL\lbr \lhs\verb+[+\expr\verb+]+ \rbr(\env)(\ir{\stmt}^*; \ir{\expr}')(\kold)
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e}({\inblue\newvar{field_1}})\\
& & \mbox{IN}\hspace*{1.2em}
\mbox{IF keepOld}\\
& & \mbox{IN}\hspace*{1.2em}
\mbox{THEN\ }
(\langle
\irstmt_1^*\verb+;+{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
 \irstmt_2^*\verb+;+{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)} \verb+;+
\\&& \phantom{\mbox{IN}\hspace*{1.2em}\mbox{THEN\ }\langle}
%%{\inblue\newvar{val}}\ \verb+=+\ \ir{\expr}'\verb+;+\
 {\inblue{\newvar{old}}}\ \verb+=+\ {\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+];+
\ir{\stmt}^*\verb+;+
{\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+] =+\ \ir{\expr}'
\rangle, {\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+]+)
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{ELSE\ }
(\langle
\irstmt_1^*\verb+;+{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+\
 \irstmt_2^*\verb+;+{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)} \verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\mbox{ELSE\ }\langle}
\ir{\stmt}^*\verb+;+
{\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+] =+\ \ir{\expr}'
\rangle,
 {\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+]+)
\\

\atoiLVAL\lbr \expr \rbr(\env)(\ir{\stmt}^*; \ir{\expr})(\kold)
&=& \mbox{\inred Warning: ReferenceError!}
\\[1em]




\atoiE\lbr e_1\verb+,+\ e_2 \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inred\newvar{\_}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+\irstmt_2^*, \irexpr_2)

%\open\ir\stmt^*\verb+;+\ \fbox{{\inred\newvar{\_}}\ {\tt =} \ \irexpr}\close
\\

%% ternary
\atoiE\lbr e_a \verb+&&+ e_b\ \verb+?+\ e_2\ \verb+:+\ e_3\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_a^*, \irexpr_a) = \atoiEfd{e_a}({\inblue\newvar{new_a}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_b^*, \irexpr_b) = \atoiEfd{e_b}({\inblue\newvar{new_b}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \phantom{\mbox{LET\ }} (\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_a^*\verb+;+\ \irstmt_b^*\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\sf if\ (} {\irexpr_a} {\sf )\ then\ }
{\sf if\ (} {\irexpr_b} {\sf )\ then\ }
\verb+{+\irstmt_2^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_2$}\verb+;+\
{\sf break}\ {\inred\newvar{label}}\verb+};+
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
\irstmt_3^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_3$} \verb+}+,\ir{x})
\\

\atoiE\lbr e_a \verb+||+ e_b\ \verb+?+\ e_2\ \verb+:+\ e_3\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_a^*, \irexpr_a) = \atoiEfd{e_a}({\inblue\newvar{new_a}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_b^*, \irexpr_b) = \atoiEfd{e_b}({\inblue\newvar{new_b}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \phantom{\mbox{LET\ }} (\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_a^*\verb+;+\ \irstmt_b^*\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}
{\inblue \newvar{label_2}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
{\inblue \newvar{label_1}} \; \verb+:+ \; \verb+{+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (} {\irexpr_a} {\sf )\ then\ } {\sf break}\ {\inred\newvar{label_1}}\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
{\sf if\ (} {\irexpr_b} {\sf )\ then\ } {\sf break}\ {\inred\newvar{label_1}}\verb+;+\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad\quad
\irstmt_3^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_3$}\verb+;+\
{\sf break}\ {\inred\newvar{label_2}}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}\open}\quad
\verb+};+\ \irstmt_2^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_2$}\verb+}+,\ir{x})\\


\atoiE\lbr e_1\ \verb+?+\ e_2\ \verb+:+\ e_3\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newva})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}(\ir{x})\\
& & \phantom{\mbox{LET\ }} (\irstmt_3^*, \irexpr_3) = \atoiEfd{e_3}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\sf if} \ \verb+(+{\irexpr_1}\verb+)+ \
{\sf then} \ \verb+{+\irstmt_2^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_2$} \verb+}+\
{\sf else} \ \verb+{+\irstmt_3^*\verb+;+ \ \fbox{\ir{x} {\tt =} $\irexpr_3$} \verb+}+,
\ir{x})
\\

\end{array}
\]


\[
\begin{array}{l@{~}l@{~}l}


\atoiE\lbr\lhs\ \verb+=+\ \expr\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}(\ir{x})\\
& & \mbox{IN}\hspace*{1.2em}
\mbox{IF\ $\irexpr$ contains $\lhs$}\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{THEN\ }
    \atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ \irexpr \ )(\false)
\\
& & \phantom{\mbox{IN}\hspace*{1.2em}}
\mbox{ELSE\ }
    (\atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ \irexpr \ )(\false).\_1, \irexpr)
\\

\atoiE\lbr{\lhs \aop\verb+=+\ \expr}\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{y}})\\
% & & \mbox{IN}\hspace*{1.2em}
%     (\atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ {\inblue{\newvar{new}}}\ \verb+=+\ {\inred{\newvar{old}}} \inop \irexpr;\ {\inred\newvar{new}})\verb+;+
%      \ir{x} \; {\tt =} \; {\inred\newvar{new}}, \ir{x})
% \\
& & \mbox{IN}\hspace*{1.2em}
    (\atoiLVALf{\lhs}{\env}(\ \irstmt^*;\ {\inred{\newvar{old}}} \aop \irexpr)(\true).\_1,
{\inred{\newvar{old}}} \aop \irexpr)
\\


\atoiE\lbr{\verb!++! \expr}\rbr(\env)(\ir{x})
% &=&
% (\atoiLVAL\lbr \expr \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new_2}}, \ir{x})
% \\
&=&
(\atoiLVAL\lbr \expr \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1})(\true).\_1,
{\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1})
\\


\atoiE\lbr{\verb!--! \expr}\rbr(\env)(\ir{x})
&=& (\atoiLVAL\lbr \expr \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1})(\true).\_1,
{\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1})
\\
% &=& (\atoiLVAL\lbr \expr \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new_2}}, \ir{x})
% \\


\atoiE\lbr{\sf delete}\ x\rbr(\env)(\ir{y})
&=&(\langle\ir{y}\ \verb+= + {\sf delete}\ x\rangle, \ir{y})\\

\atoiE\lbr{\sf delete}\ \lhs\verb+.+x\rbr(\env)(\ir{y})
&=& \atoiE\lbr{\sf delete}\ \lhs\verb+["+x\verb+"]+\rbr(\env)(\ir{y})
\\

\atoiE\lbr{\sf delete}\ \lhs\verb+[+e\verb+]+\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e}({\inblue\newvar{field_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
 \irstmt_2^*\verb+;+{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)} \verb+;+
 \ir{x}\ \verb+= + {\sf delete}\ {\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+]+, \ir{x})
\\

\atoiE\lbr{\sf delete}\ e\rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{y}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*, {\sf true})
\\

\atoiEfd{\preop e}(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{y}})\\
& & \mbox{IN}\hspace*{1.2em}
% (\irstmt^*\verb+;+\ \ir{x} \ \verb+=+ \ \preop \irexpr, \ir{x})
(\irstmt^*, \preop \irexpr)
\\

\atoiE\lbr \lhs \verb!++!\rbr(\env)(\ir{x})
&=&
(\atoiLVAL\lbr \lhs \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1})(\true).\_1,
{\inred\newvar{new}})
\\
% (\atoiLVAL\lbr \lhs \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!+! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new}}, \ir{x})
% \\

\atoiE\lbr \lhs \verb!--!\rbr(\env)(\ir{x})
&=&
(\atoiLVAL\lbr \lhs \rbr(\env)(
{\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
{\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1})(\true).\_1,
{\inred\newvar{new}})
\\
% (\atoiLVAL\lbr \lhs \rbr(\env)(
% {\inblue\newvar{new}}\ \verb+=+\ {\sf \ensuremath{\diamond}toNumber(}{\inred\newvar{old}}{\sf)};\
% {\inblue\newvar{new_2}}\ \verb+=+\ {\inred{\newvar{new}}}\ \verb!-! {\sf\ingreen 1};\ {\inred\newvar{new_2}})\verb+;+
% \ir{x} \; {\tt =} \; {\inred\newvar{new}}, \ir{x})
% \\

% \atoiE\lbr{e_1 \verb+&&+ e_2}\rbr(\env)(\ir{x})
% &=& \langle
% \atoiEfd{e_1}({\inblue\ir{y}})\verb+;+\\
% &&\phantom{\langle}
% {\inblue\newvar{y_1}}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean(}{\inred\ir{y}}{\sf)}\verb+;+\\
% &&\phantom{\langle}
% {\sf if\ ({\inred{\newvar{y_1}}})\ then}\ \atoiEfd{e_2}({\ir{x}})\
% {\sf else\ IRSeq(}\langle\ \ir{x}\ \verb+=+\ {\inred{\ir{y}}}\verb+;+ \rangle{\sf)}\rangle\\

% \atoiE\lbr{e_1 \verb+||+ e_2}\rbr(\env)(\ir{x})
% &=& \langle
% \atoiEfd{e_1}({\inblue\ir{y}})\verb+;+\\
% &&\phantom{\langle}
% {\inblue\newvar{y_1}}\ \verb+=+\ {\sf \ensuremath{\diamond}toBoolean(}{\inred\ir{y}}{\sf)}\verb+;+\\
% &&\phantom{\langle}
% {\sf if\ ({\inred{\newvar{y_1}}})\ then}\
% {\sf IRSeq(}\langle\ \ir{x}\ \verb+=+\ {\inred\ir{y}}\verb+;+ \rangle{\sf)}\
% {\sf else}\
% \atoiEfd{e_2}({\ir{x}})\rangle\\



% ast2ir_e[e1&&e2])(sigma)(x) = <ast2ir_e[e1](sigma)(y); y1=\ensuremath{\diamond}toBoolean(y); if y1 then x=y else ast2ir_e[e2](sigma)(x)>
% ast2ir_e[e1||e2])(sigma)(x) = <ast2ir_e[e1](sigma)(y); y1=\ensuremath{\diamond}toBoolean(y); if y1 then ast2ir_e[e2](sigma)(x) else x=y >

\atoiEfd{e_1 \inop e_2}(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiEfd{e_1}({\inblue\newvar{y}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{e_2}({\inblue\newvar{z}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+\irstmt_2^*, \irexpr_1 \inop \irexpr_2)
\\



\atoiEfd{\lhs}(\ir{x})
&=& \atoiLHSfd{\lhs}(\ir{x})
\\[1em]


\end{array}
\]

\[
\begin{array}{l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l@{\;}l}
\aop &::=&
\verb+*+ & \mid &
\verb+/+ & \mid &
\verb+%+ & \mid &
\verb!+! & \mid &
\verb+-+ & \mid &
\verb+<<+ & \mid &
\verb+>>+ & \mid &
\verb+>>>+ & \mid &
\verb+&+ & \mid &
\verb+^+ & \mid &
\verb+|+
\\

\preop &::=& \verb+~+ & \mid & \verb+!+ & \mid & \verb!+! & \mid & \verb+-+ & \mid &
\lefteqn{
 {\tt delete} \ \mid \ {\tt void} \ \mid \ {\tt typeof} }\\

\inop &::=& \verb+|+ & \mid & \verb+&+ & \mid & \verb+^+ & \mid & \verb+<<+ & \mid & \verb+>>+ & \mid & \verb+>>>+ 
 & \mid & \verb!+! & \mid & \verb+-+ & \mid & \verb+*+ & \mid & \verb+/+ & \mid & \verb+%+
 &\mid& \verb+==+ & \mid & \verb+!=+ & \mid & \verb+===+ & \mid & \verb+!==+ & \mid & \verb+<+ & \mid & \verb+>+ & \mid & \verb+<=+
 & \mid & \verb+>=+ & \mid & {\tt instanceof} & \mid & {\tt in}\\[1em]
\end{array}
\]


\[
\begin{array}{l@{~}l@{~}l}


\atoiLHSfd{lit}(\ir{x})
&=& \atoiLITfd{lit}(\ir{x})
\\

\atoiLHS\lbr\verb+arguments+\rbr(\env)(\ir{x})
&=& (\emptyenv, \env(\newvar{arguments}))
\\

\atoiLHSfd{x}(\ir{y})
&=& (\langle\rangle, \ir{x})\\

\atoiLHS \lbr \verb+[+(e^?\verb+,+)^* \verb+]+ \rbr(\env)(\ir{x})
&=&
\mbox{LET\ } ((\irstmt^*, \irexpr) = \atoiEfd{e}({\inblue\newvar{elem}}))^*
\\
& & \mbox{IN}\hspace*{1.2em}
((\ir{s}^*)^* \verb+;+\
\irid \ \verb+=+ \ \verb+[+ (\irexpr\verb+,+)^* \verb+]+, \ir{x})
\\

%% object expressions
\atoiLHS \lbr \verb+{+(m\verb+,+)^* \verb+}+ \rbr(\env)(\ir{x})
&=&
\mbox{LET\ } ((\irstmt^*, \ir{\emph mem}) = \atoiMfd{m}({\inblue\newvar{member}}))^*
\\
& & \mbox{IN}\hspace*{1.2em}
((\ir{s}^*)^* \verb+;+\
\irid \ \verb+=+ \ \verb+{+ (\ir{\emph mem}\verb+,+)^* \verb+}+, \ir{x})
\\

\atoiLHS \lbr \verb+(+e \verb+)+ \rbr(\env)(\ir{x})
&=& \atoiEfd{e}(\ir{x})
\\


\atoiLHS\lbr{ {\tt function} \ f^? \verb+(+(x\verb+,+)^*\verb+)+ \ \verb+{+ \fd^* \vd^* \stmt^* \verb+}+}\rbr(\env)(\ir{y})
&=&
(\langle\ir{y}\ \verb+=+\
{\sf function} \ \ir{f}^? \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad\quad\quad
(\ir{x_i} = {\inred\newvar{arguments}}\verb+["i"]+)^*\\
&&\quad\quad\quad(\atoiFDfd{\fd})^*\\
&&\quad\quad\quad(\atoiVDf{\vd}\env)^*\\
&&\quad\quad\quad(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+\rangle,
\ir{y})
\\

\atoiLHS \lbr \lhs\verb+.+x \rbr(\env)(\ir{y})
&=& \atoiLHS \lbr \lhs\verb+["+x\verb+"]+ \rbr(\env)(\ir{y})
\\


%% property access
\atoiLHS \lbr \lhs\verb+[+e \verb+]+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_1^*, \irexpr_1) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt_2^*, \irexpr_2) = \atoiEfd{\expr}({\inblue\newvar{field_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_1^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_1{\sf)} \verb+;+
\irstmt_2^*\verb+;+
{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr_2{\sf)},
{\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+]+)
\\


\end{array}
\]


\[
\begin{array}{l@{~}l@{~}l}
%% new fun app
\atoiLHS \lbr \verb+new+\ \lhs\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_l^*, \irexpr_l) = \atoiLHSfd{\lhs}({\inblue\newvar{fun_1}})\\
& & \phantom{\mbox{LET\ }} ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_l^*\verb+;+
{\inblue\newvar{fun}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_l{\sf)} \verb+;+
(\irstmt^*)^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+(\irexpr_i\verb+,+)^*\verb+];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
% %%%%%%%
% % proto = fun["prototype"]
{\inblue\newvar{proto}} = {\inred\newvar{fun}}\verb+["prototype"];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{obj}}\ \verb+= {[[Prototype]] = +{\inred\newvar{proto}}\verb+};+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{newObj}}\ \verb+=+\ {\inred\newvar{fun}}\verb+(+{\inred\newvar{obj}}\verb+, + {\inred\newvar{arguments}}\verb+);+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{cond}}\ \verb+=+\ {\sf \ensuremath{\diamond}isObject({\inred\newvar{newObj}})}\verb+;+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\sf if (} {\inred\newvar{cond}} {\sf )\ then}\
\ir{x}\ \verb+=+\ {\inred\newvar{newObj}}\ {\sf \ else}\
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}, \ir{x})
\\





%% new
\atoiLHS \lbr \verb+new+\ \lhs \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiLHSfd{\lhs}({\inblue\newvar{fun_1}})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*\verb+;+
{\inblue\newvar{fun}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr{\sf)} \verb+;+\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
% %%%%%%%
% % proto = fun["prototype"]
{\inblue\newvar{proto}} = {\inred\newvar{fun}}\verb+["prototype"];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{obj}}\ \verb+= {[[Prototype]] = +{\inred\newvar{proto}}\verb+};+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{newObj}}\ \verb+=+\ {\inred\newvar{fun}}\verb+(+{\inred\newvar{obj}}\verb+, + {\inred\newvar{arguments}}\verb+);+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{cond}}\ \verb+=+\ {\sf \ensuremath{\diamond}isObject({\inred\newvar{newObj}})}\verb+;+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\sf if (} {\inred\newvar{cond}} {\sf )\ then}\
\ir{x}\ \verb+=+\ {\inred\newvar{newObj}}\ {\sf \ else}\
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}, \ir{x})
\\

%% eval
\atoiLHS \lbr {\emph eval} \verb+(+e \verb+)+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newva})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*\verb+;+
\irid \ \verb+=+ \ {\sf eval}\verb+(+\irexpr\verb+)+, \irid)
\\
\atoiLHS \lbr \verb+(+f \verb+)(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=&
\atoiLHS \lbr f \verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
\\

%% function id call
\atoiLHS \lbr f \verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
({\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\ir{f}{\sf)} \verb+;+
(\irstmt^*)^*\verb+;+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+(\irexpr_i\verb+,+)^*\verb+];+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{fun}}\ \verb+=+\ \newvar{getBase}\verb+(+\ir{f}\verb+);+
\\&&\phantom{\mbox{IN}\hspace*{1.2em}(}
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}\verb+(+{\inred\newvar{fun}}, {\inred\newvar{arguments}}\verb+)+,
\ir{x})
\\

%% property access call
\atoiLHS \lbr \verb+(+\lhs\verb+.+x \verb+)(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
&=& \atoiLHS \lbr \lhs\verb+["+x\verb+"]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
\\

\atoiLHS \lbr \lhs\verb+.+x \verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
&=& \atoiLHS \lbr \lhs\verb+["+x\verb+"]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{y})
\\


% \atoiLHSfd{\lhs}(\newvar{constr}) \verb+;+
% \\
% &&\phantom{\langle}
% (\atoiEfd{\expr}(\ir{y}))^*
% \\
% &&\phantom{\langle}
% \newvar{arguments}\ \verb+= {+(\verb+"i" : +\ir{y_i})^*\verb+};+
% \\
% &&\phantom{\langle}
% \newvar{obj}\ \verb+= {+ \newvar{proto}\verb+:+ \newvar{constr}\verb+["prototype"]}+
% \\
% &&\phantom{\langle}
% \ir{x}\ \verb+=+\ \newvar{constr}\verb+(+\newvar{obj}\verb+, + \newvar{arguments}\verb+);+
% \\
% &&\phantom{\langle}
% \newvar{obj}
% \\

\atoiLHS \lbr \verb+(+\lhs\verb+[+e' \verb+])+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=&
\atoiLHS \lbr \lhs\verb+[+e' \verb+]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
\\



\atoiLHS \lbr \lhs\verb+[+e' \verb+]+\verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_l^*, \irexpr_l) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} (\irstmt'^*, \irexpr') = \atoiEfd{\expr'}({\inblue\newvar{field_1}})\\
& & \phantom{\mbox{LET\ }} ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_l^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_l{\sf)} \verb+;+
\irstmt'^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{field}}\ \verb+=+\ {\sf \ensuremath{\diamond}toString(}\irexpr'{)} \verb+;+
(\irstmt^*)^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+(\irexpr_i\verb+,+)^*\verb+];+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{fun}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}{\inred\newvar{obj}}\verb+[+{\inred\newvar{field}}\verb+]+{\sf)} \verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
\ir{x}\ \verb+=+\ {\inred\newvar{fun}}\verb+(+{\inred\newvar{obj}}\verb+, + {\inred\newvar{arguments}}\verb+)+,
\ir{x})
\\



%% function call
\atoiLHS \lbr \lhs \verb+(+(e,)^* \verb+)+ \rbr(\env)(\ir{x})
&=& \mbox{LET\ } (\irstmt_l^*, \irexpr_l) = \atoiLHSfd{\lhs}({\inblue\newvar{obj_1}})\\
& & \phantom{\mbox{LET\ }} ((\irstmt^*, \irexpr) = \atoiEfd{\expr}({\inblue\newvar{y}}))^*\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt_l^*\verb+;+
{\inblue\newvar{obj}}\ \verb+=+\ {\sf \ensuremath{\diamond}toObject(}\irexpr_l{\sf)} \verb+;+
(\irstmt^*)^*\verb+;+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
{\inblue\newvar{arguments}}\ \verb+= [+(\irexpr_i\verb+,+)^*\verb+];+
\\
&&\phantom{\mbox{IN}\hspace*{1.2em}(}
\ir{x}\ \verb+=+\ {\inred\newvar{obj}}\verb+(+\newvar{global}\verb+, + {\inred\newvar{arguments}}\verb+)+, \ir{x})
\\[1em]



\atoiLITfd {{\tt this}}(\ir{x})
&=&
(\emptyenv, \env(\newvar{this}))\\

\atoiLITfd{{\tt null}}(\ir{x})
&=& 
(\emptyenv, {\sf null})\\
\atoiLITfd{{\tt true}}(\ir{x})
&=& 
(\emptyenv, {\sf true})\\
\atoiLITfd{{\tt false}}(\ir{x})
&=& 
(\emptyenv, {\sf false})\\
\atoiLITfd{num}(\ir{x})
&=& 
(\emptyenv, \ir\num)\\

\atoiLITfd {str}(\ir{x})
&=& 
(\emptyenv, \ir\str)\\

\inred\atoiLITfd { reg }
&=&

\\[1em]
\atoiM\lbr {\prop \ \verb+:+ \ \expr}  \rbr(\env)(\ir{y})
&=& \mbox{LET\ } (\irstmt^*, \irexpr) = \atoiEfd{\expr}(\ir{y})\\
& & \mbox{IN}\hspace*{1.2em}
(\irstmt^*, \atoiPRfd{\prop} \ \verb+:+ \ \irexpr)
\\


\atoiM\lbr {\tt get} \ \prop \verb+(){+ \fd^* \vd^* \stmt^* \verb+}+  \rbr(\env)(\ir{x})
&=& (
\langle\rangle,

{\sf get} \ \atoiPRfd{\prop} \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad\quad\quad(\atoiFDfd{\fd})^*\\
&&\quad\quad\quad(\atoiVDf{\vd}\env)^*\\
&&\quad\quad\quad(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+
)
\\

\atoiM\lbr {\tt set} \ \prop \verb+(+x \verb+){+ \fd^* \vd^* \stmt^* \verb+}+  \rbr(\env)(\ir{y})
&=& (
\langle\rangle,

{\sf set} \ \atoiPRfd{\prop} \verb+(+{\inblue\newvar{this}}\verb+,+\ {\inblue\newvar{arguments}}\verb+)+
\verb+{+\\
&&\quad\quad\quad
\ir{x} = {\inred\newvar{arguments}}\verb+["0"];+\\
&&\quad\quad\quad(\atoiFDfd{\fd})^*\\
&&\quad\quad\quad(\atoiVDf{\vd}\env)^*\\
&&\quad\quad\quad(\atoiSf{\stmt}{\env; {\inred\newvar{this}}; {\inred\newvar{arguments}}})^*
\verb+}+
)
\end{array}
\]

\end{document}
