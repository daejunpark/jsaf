\documentclass{article}

\usepackage{amsmath,amssymb,color,stmaryrd,a4wide,galois,tikz}
\usepackage{graphicx}

\title{Flow Graph for JavaScript}
\newcommand{\safe}{{\sf SAFE}}

\newcommand{\newvar}[1]{\ensuremath{\underline{\sf \diamond{#1}}}}
\newcommand{\newva}{\newvar{new_1}}
\newcommand{\newvb}{\newvar{new_2}}
\newcommand{\newvc}{\newvar{new_3}}
\newcommand{\rulesep}{\quad\quad}

\newcommand{\kold}{{\rm keepOld}}
\newcommand{\myid}{x}
\newcommand{\myfn}{f}
\newcommand{\name}{\alpha}
\newcommand{\env}{\Sigma}
\newcommand{\wenv}{\Gamma}
\newcommand{\open}{{\ingreen\langle}}
\newcommand{\close}{{\ingreen\rangle}}
%\newcommand{\emptyenv}{\langle\rangle, \langle\rangle}
\newcommand{\emptyenv}{\langle\rangle}
% added commands by changhee
\newcommand{\nestedname}{\beta}
\newcommand{\listname}{\phi\;\alpha}
\newcommand{\namelist}{\phi}
\newcommand{\emptylist}{\epsilon}
\newcommand{\emptyval}{{\ingreen\mbox{\tt empty}}}
\newcommand{\listscope}{\varphi}
\newcommand{\flag}{{\emph{IsNested}}}
\newcommand{\trueflag}{{\bold{True}}}
\newcommand{\falseflag}{{\bold{False}}}
\newcommand{\argmk}[3]{\langle#1, #2, #3\rangle}
\newcommand{\rewritearg}{\langle\listname, \listscope, \flag\rangle}
%\newcommand{\isshadowed}[2]{\ensuremath{\emph{IsShadowed}\lbr#1\mid#2\rbr}}
\newcommand{\isshadowed}[2]{\ensuremath{#1\in#2}}
\newcommand{\mylet}{\bold{Let}\ }
\newcommand{\myif}{\bold{If}\ }
\newcommand{\mythen}{\bold{Then}\ }
\newcommand{\myelse}{\bold{Else}\ }
\newcommand{\myifend}{\bold{EndIf}}
\newcommand{\myelseend}{\bold{EndElse}}
\newcommand{\namecheck}[2]{\ensuremath{#1 \equiv #2}}
\newcommand{\getlocaldecls}{\ensuremath{\emph{LocalDecls}}}
\newcommand{\pgm}{p}
\newcommand{\stmt}{s}
\newcommand{\expr}{e}
\newcommand{\exprs}{e^+}
%\newcommand{\topl}{t}
\newcommand{\fd}{\emph{fd}}
\newcommand{\vd}{\emph{vd}}
\newcommand{\cc}{\emph{cc}}
\newcommand{\me}{\emph{me}}
\newcommand{\ce}{\emph{ce}}
\newcommand{\lhs}{\emph{lhs}}
\newcommand{\lval}{\emph{lval}}
\newcommand{\prop}{\emph{pr}}
\newcommand{\lit}{\emph{lit}}
\newcommand{\num}{\emph{num}}
\newcommand{\str}{\emph{str}}
\newcommand{\reg}{\emph{reg}}
\newcommand{\member}{\emph{m}}
\newcommand{\aop}{\ensuremath{\odot}}
\newcommand{\inop}{\ensuremath{\otimes}}
\newcommand{\preop}{\ensuremath{\ominus}}
\newcommand{\postop}{\ensuremath{\oslash}}
\newcommand{\atoi}{\ensuremath{\emph{ast2ir}}}
% p::=t*
\newcommand{\atoiP}{\ensuremath{\atoi_p}}
\newcommand{\atoiPf}[1]{\ensuremath{\atoiP\lbr#1\rbr}}
% t::= s | ...
% \newcommand{\atoiT}{\ensuremath{\atoi_t}}
% \newcommand{\atoiTf}[2]{\ensuremath{\atoiT\lbr{#1}\rbr(#2)}}
% \newcommand{\atoiTfd}[1]{\ensuremath\atoiTf{#1}{\env}}
% s::= {s*} | ...
\newcommand{\atoiS}{\ensuremath{\atoi_s}}
\newcommand{\atoiSf}[2]{\ensuremath{\atoiS\lbr#1\rbr(#2)}}
\newcommand{\atoiSfd}[1]{\atoiSf{#1}{\env}}

\newcommand{\atoiN}{\ensuremath{\atoi_n}}
\newcommand{\atoiNf}[2]{\ensuremath{\atoiN\lbr#1\rbr(#2)}}
\newcommand{\atoiNfd}[1]{\atoiNf{#1}{\env}}
% vd::= id(=e)?
\newcommand{\atoiVD}{\ensuremath{\atoi_{\emph{vd}}}}
\newcommand{\atoiVDf}[2]{\ensuremath{\atoiVD\lbr#1\rbr(#2)}}
% fd
\newcommand{\atoiFD}{\ensuremath{\atoi_{\emph{fd}}}}
\newcommand{\atoiFDf}[2]{\ensuremath{\atoiFD\lbr#1\rbr(#2)}}
\newcommand{\atoiFDfd}[1]{\atoiFDf{#1}{\env}}
% cc::= case e:s*
\newcommand{\atoiCC}{\ensuremath{\atoi_{\emph{cc}}}}
\newcommand{\atoiCCf}[2]{\ensuremath{\atoiCC\lbr#1\rbr(#2)}}
\newcommand{\atoiCCfd}[1]{\atoiCCf{#1}{\env}}
% e::= e,e | ...
\newcommand{\atoiE}{\ensuremath{\atoi_e}}
\newcommand{\atoiEf}[2]{\ensuremath{\atoiE\lbr#1\rbr(#2)}}
\newcommand{\atoiEfd}[1]{\atoiEf{#1}{\env}}
% lhs ::= lit | id | ...
\newcommand{\atoiLHS}{\ensuremath{\atoi_{\emph{lhs}}}}
\newcommand{\atoiLHSf}[2]{\ensuremath{\atoiLHS\lbr#1\rbr(#2)}}
\newcommand{\atoiLHSfd}[1]{\atoiLHSf{#1}{\env}}
% lval
\newcommand{\atoiLVAL}{\ensuremath{\atoi_{\emph{lval}}}}
\newcommand{\atoiLVALf}[2]{\ensuremath{\atoiLVAL\lbr#1\rbr(#2)}}
\newcommand{\atoiLVALfd}[1]{\atoiLVALf{#1}{\env}}
% lit ::= this|null|...
\newcommand{\atoiLIT}{\ensuremath{\atoi_{\emph{lit}}}}
\newcommand{\atoiLITf}[2]{\ensuremath{\atoiLIT\lbr#1\rbr(#2)}}
\newcommand{\atoiLITfd}[1]{\atoiLITf{#1}{\env}}
% m ::= pr:e | get/set
\newcommand{\atoiM}{\ensuremath{\atoi_m}}
\newcommand{\atoiMf}[2]{\ensuremath{\atoiM\lbr#1\rbr(#2)}}
\newcommand{\atoiMfd}[1]{\atoiMf{#1}{\env}}
% pr ::= id | str | num
\newcommand{\atoiPR}{\ensuremath{\atoi_{\emph{pr}}}}
\newcommand{\atoiPRf}[1]{\ensuremath{\atoiPR\lbr#1\rbr}}
\newcommand{\atoiPRfd}[1]{\atoiPRf{#1}}

\newcommand{\atoiL}{\ensuremath{\atoi_l}}
\newcommand{\atoiLf}[1]{\ensuremath{\atoiL\lbr#1\rbr}}
\newcommand{\collectLV}[1]{\ensuremath{\emph{collectLV}(#1)}}

% Add Ast2IR Lit???
\newcommand{\Field}{\emph{Field}}


\newcommand{\atoiLit}{\ensuremath{\atoi_{\emph{lit}}}}
% \newcommand{\atoiM}{\ensuremath{\atoi_m}}
\newcommand{\atoiPr}{\ensuremath{\atoi_{\emph{pr}}}}
\newcommand{\atoiC}{\ensuremath{\atoi_}\emph{case}}
\newcommand{\atoiSC}{\ensuremath{\atoi_}\emph{scond}}
\newcommand{\lbr}{\ensuremath{\llbracket}}
\newcommand{\rbr}{\ensuremath{\rrbracket}}
\newcommand{\note}[1]{~~~~{\color{blue}{\emph{#1}}}}

\newcommand{\ir}[1]{\ensuremath{\underline{#1}}}
\newcommand{\irid}{\ir{x}}
\newcommand{\irstmt}{\ir{\stmt}}
\newcommand{\irexpr}{\ir{\expr}}

\newcommand{\mkst}[2]{#1::#2}
\newcommand{\reject}{\inblue\mbox{if \strict}\ {\tt Throw}(\te)\ \mbox{else}\ {\tt Normal}(v_3)}
\newcommand{\rejectb}{\inblue\mbox{if}\ b\ \te\ \mbox{else}\ \false}
\newcommand{\rejectbb}{\inblue\mbox{if}\ b'\ \te\ \mbox{else}\ \false}

\newcommand{\strict}{{\inred\tt strict}}
\newcommand{\eval}{{\inred\tt eval}}
\newcommand{\UndefVB}{\emph{UndefVB}}
\newcommand{\stuck}{{\tt stuck}}
\newcommand{\nullK}{{\tt null}}
\newcommand{\nullL}{{\tt \#Null}}
\newcommand{\undef}{{\tt undefined}}
\newcommand{\false}{{\tt false}}
\newcommand{\true}{{\tt true}}
\newcommand{\er}{\ensuremath{\sigma}}
\newcommand{\erg}{\ensuremath{\sigma_g}}
\newcommand{\var}{\emph{Var}}
\newcommand{\sv}{\emph{StoreValue}}
\newcommand{\Bool}{\emph{Bool}}
\newcommand{\tb}{\emph{tb}}
\newcommand{\ve}{\emph{ValError}}
\newcommand{\ValError}{\emph{ValError}}
\newcommand{\Error}{\emph{Error}}
\newcommand{\err}{\emph{err}}
\newcommand{\te}{{\tt TypeError}}
\newcommand{\re}{{\tt ReferenceError}}
\newcommand{\pval}{\emph{PVal}}
\newcommand{\pv}{\emph{pv}}
\newcommand{\pname}{\emph{PName}}
\newcommand{\pn}{\emph{p}}
\newcommand{\Type}{\emph{Type}}
\newcommand{\Val}{\emph{Val}}
\newcommand{\FVal}{\emph{FVal}}
\newcommand{\Loc}{\emph{Loc}}
\newcommand{\Obj}{\emph{Object}}
\newcommand{\ObjV}{\emph{ObjectValue}}
\newcommand{\Str}{\emph{Str}}
\newcommand{\Num}{\emph{Num}}
\newcommand{\Dom}{\emph{Dom}}
\newcommand{\Heap}{\emph{Heap}}
\newcommand{\Prop}{\emph{PName}}
\newcommand{\State}{\emph{State}}
\newcommand{\Value}{\emph{Value}}
\newcommand{\Var}{\emph{Var}}
\newcommand{\Env}{\emph{Env}}
\newcommand{\EnvRec}{\emph{EnvRec}}
\renewcommand{\lg}{{\tt \#Global}}
\newcommand{\vorempty}{\emph{vt}}
\newcommand{\ct}{\emph{ct}}
\newcommand{\ac}{\emph{ac}}
\newcommand{\nc}{\emph{nc}}
\newcommand{\dquote}[1]{\text{``}#1\text{''}}
\newcommand{\squote}[1]{\text{`}#1\text{'}}
\newcommand{\Label}{\emph{Label}}
\newcommand{\hf}[1]{\emph{#1}}
\newcommand{\chf}[1]{\underline{\sf #1}}
\newcommand{\ifc}[1]{{\rm if}\begin{array}[t]{l}#1\end{array}}
\newcommand{\none}{\ensuremath{\epsilon}}
\newcommand{\void}{{\tt Normal}({\tt empty})}
\newcommand{\nv}[1]{{\tt Normal}(#1)}
\newcommand{\newl}{\emph{newLocation}}
\newcommand{\ov}{\emph{ov}}
\newcommand{\error}{\ensuremath{{\tt Throw}(\err)}}
\newcommand{\thte}{\ensuremath{{\tt Throw}(\te)}}


\newcommand{\state}{\ensuremath{(H,A,\tb)}}
\newcommand{\statep}{\ensuremath{(H',A',\tb)}}
\newcommand{\statepp}{\ensuremath{(H'',A'',\tb)}}
\newcommand{\statel}{\ensuremath{(H,A,\tb)}}
\newcommand{\statepl}{\ensuremath{(H',A',\tb)}}
\newcommand{\res}{\ensuremath{(H,A)}}
\newcommand{\resp}{\ensuremath{(H',A')}}
\newcommand{\respp}{\ensuremath{(H'',A'')}}
\newcommand{\resppp}{\ensuremath{(H''',A''')}}
\newcommand{\evale}{\ensuremath{(H,A,\tb)}}


\newcommand{\irif}{\ensuremath{{\sf if} \ {\tt(}\irexpr{\tt)}\ {\sf then} \ \ir{\stmt_1} \ ({\sf else} \ \ir{\stmt_2})^?}}
\newcommand{\irbin}{\ensuremath{\irid \ {\tt =} \ \ir{y} \ \inop \ir{z}}}
\newcommand{\irun}{\ensuremath{\irid \ {\tt =} \ \preop \ir\expr}}
\newcommand{\irdel}{\ensuremath{\irid \ {\tt =} \ {\sf delete}\ \ir{y}}}
\newcommand{\irdelprop}{\ensuremath{\irid \ {\tt =} \ {\sf delete}\ \ir{y}{\tt[}\ir{z}{\tt]}}}
\newcommand{\irobj}{\ensuremath{\irid \ {\tt =} \ {\tt\{} (\ir\member{\tt,})^* {\tt\}}}}
\newcommand{\irarr}{\ensuremath{\irid \ {\tt =} \ {\tt[} (\ir
{e}{\tt,})^* {\tt]}}}
\newcommand{\ircall}{\ensuremath{\irid \ {\tt =} \ \ir{y}{\tt(}\ir{z_1}{\tt,}\ir{z_2}{\tt)}}}
\newcommand{\irnew}{\ensuremath{\irid \ {\tt =} \ {\sf new} \ \ir\expr}}
\newcommand{\irfv}{\ensuremath{{\sf function} \ \ir{f} {\tt(}\ir{\emph{this}}{\tt,}\ir{\emph{arguments}}{\tt) \{} \ir\stmt {\tt\}}}}
\newcommand{\irfunexpr}{\ensuremath{\irid \ {\tt =} \ \irfv}}
\newcommand{\ireval}{\ensuremath{\irid \ {\tt =} \ {\sf eval}{\tt(}\ir\expr{\tt)}}}
\newcommand{\irbreak}{\ensuremath{{\sf break} \ \irid}}
\newcommand{\irreturn}{\ensuremath{{\sf return} \ \irid^?}}
\newcommand{\irwith}{\ensuremath{{\sf with} \ {\tt(}\irid{\tt)} \ \ir\stmt}}
\newcommand{\irlab}{\ensuremath{\ir{x} {\tt: \{} \ir\stmt {\tt\}}}}
\newcommand{\irwhile}{\ensuremath{{\sf while} \ {\tt(}\irexpr{\tt)}\ \ir\stmt}}
\newcommand{\irtry}{\ensuremath{{\sf try} \ {\tt\{} \ir\stmt {\tt\}} \
({\sf catch} \ {\tt(}\irid{\tt)\{} \ir\stmt {\tt\}})^? \
({\sf finally} \ {\tt\{} \ir\stmt {\tt\}})^?}}
\newcommand{\irfield}{\ensuremath{\irid \ {\tt:} \ \ir{y}}}
% \newcommand{\irget}{\ensuremath{{\tt get}\ \ir{f} {\tt(}\ir{\emph{this}}{\tt,}\ir{\emph{arguments}}{\tt) \{} \ir\stmt\ \ir\stmt\ \ir\stmt\ \ir\stmt {\tt\}}}}

\newcommand{\irget}{\ensuremath{{\tt get}\ \ir{f} {\tt(}\ir{\emph{this}}{\tt,}\ir{\emph{arguments}}{\tt) \{} \ir\stmt {\tt\}}}}
\newcommand{\irset}{\ensuremath{{\tt set}\ \ir{f} {\tt(}\ir{\emph{this}}{\tt,}\ir{\emph{arguments}}{\tt) \{} \ir\stmt {\tt\}}}}
\newcommand{\irfndecl}{\ensuremath{{\sf function} \ \ir{f} {\tt(}\ir{\emph{this}}{\tt,}\ir{\emph{arguments}}{\tt) \{} \ir\stmt {\tt\}}}}

\newcommand{\irtryall}{\ensuremath{{\sf try} \ {\tt\{} \ir{\stmt_1} {\tt\}} \
({\sf catch} \ {\tt(}\irid{\tt)\{} \ir{\stmt_2} {\tt\}})^? \
({\sf finally} \ {\tt\{} \ir{\stmt_3} {\tt\}})^?}}

\newcommand{\irtrycat}{\ensuremath{{\sf try} \ {\tt\{} \ir{\stmt_1} {\tt\}} \
{\sf catch} \ {\tt(}\irid{\tt)\{} \ir{\stmt_2} {\tt\}}}}

\newcommand{\irtryfin}{\ensuremath{{\sf try} \ {\tt\{} \ir{\stmt_1} {\tt\}} \
{\sf finally} \ {\tt\{} \ir{\stmt_2} {\tt\}}}}

\newcommand{\irtrycatfin}{\ensuremath{{\sf try} \ {\tt\{} \ir{\stmt_1} {\tt\}} \
{\sf catch} \ {\tt(}\irid{\tt)\{} \ir{\stmt_2} {\tt\}} \
{\sf finally} \ {\tt\{} \ir{\stmt_3} {\tt\}}}}

\def\inred{\color{red}}
\def\inblue{\color{blue}}
\def\ingreen{\color{green}}
\def\inblack{\color{black}}


\definecolor{orange}{rgb}{0.9,0.45,0}
\definecolor{purple}{rgb}{0.5,0,0.5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\SF}[1]{\mbox{\textsf{#1}}}
\newcommand{\RM}[1]{\mbox{\textrm{#1}}}
\newcommand{\TT}[1]{\mbox{\texttt{#1}}}
\newcommand{\Command}{\SF{Command}}
\newcommand{\Instruction}{\SF{Instruction}}
\newcommand{\Entry}{\TT{entry}}
\newcommand{\Exit}{\TT{exit}}
\newcommand{\Exite}{\TT{exit-exc}~}
\newcommand{\Expression}{\SF{Expression}}
\newcommand{\Binop}{\SF{Binop}}
\newcommand{\Unop}{\SF{Unop}}
\newcommand{\single}{\textsf{single}}
\newcommand{\ainop}{\hat{\ensuremath{\otimes}}}
\newcommand{\apreop}{\hat{\ensuremath{\ominus}}}
\newcommand{\mtt}[1]{\mbox{\tt\footnotesize #1}}
\newcommand{\cfgnext}{\hookrightarrow}
\newcommand{\excnext}{\stackrel{\mathsf{exc}}{\hookrightarrow}}
\newcommand{\ipnext}{\stackrel{\mathsf{ip}}{\hookrightarrow}}
\newcommand{\comment}[1]{\textit{#1}}
\newcommand{\wherec}[1]{{\rm where}\begin{array}[t]{l}#1\end{array}}
\newcommand{\iffc}[1]{{\rm iff}\begin{array}[t]{l}#1\end{array}}
\newcommand{\owc}{{\rm otherwise}}
\newcommand{\listd}{\ \SF{list}}

\newcommand{\evalcfg}[1]{\llbracket #1 \rrbracket}
\newcommand{\Heapcfg}{\SF{Heap}}
\newcommand{\Loccfg}{\SF{Loc}}
\newcommand{\Propcfg}{\SF{Prop}}
\newcommand{\Objcfg}{\SF{Obj}}
\newcommand{\Statecfg}{\SF{State}}
\newcommand{\Valuecfg}{\SF{Value}}
\newcommand{\pgmcfg}{\SF{Program}}


\newcommand{\abs}[1]{\widehat{\SF{#1}}}
\newcommand{\aHeap}{\abs{Heap}}
\newcommand{\aLoc}{\abs{Loc}}
\newcommand{\aObj}{\abs{Obj}}
\newcommand{\aState}{\abs{State}}
\newcommand{\aValue}{\abs{Value}}
\newcommand{\aAttr}{\abs{aAttr}}
\newcommand{\finto}{\stackrel{\tiny \SF{fin}}{\rightarrow}}
\newcommand{\defi}{\stackrel{\tiny \SF{def}}{=}}
\newcommand{\N}{\mathcal{C}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\aE}{\hat{\mathcal{E}}}
\newcommand{\aN}{\hat{\mathcal{C}}}
\newcommand{\aB}{\hat{\mathcal{B}}}
\newcommand{\aI}{\hat{\mathcal{I}}}
\newcommand{\aV}{\hat{\mathcal{V}}}
\newcommand{\set}[1]{\left\{\begin{array}{l}#1\end{array}\right\}}
\newcommand{\cfg}{\langle\mathbb{N},\cfgnext,\excnext\rangle}
\newcommand{\globalfid}{\SF{@globalfid}}
\newcommand{\powerset}[1]{\wp(#1)}
\newcommand{\fid}{\SF{FunctionId}}
\newcommand{\graph}{\SF{Graph}}
\newcommand{\args}{\SF{ArgVars}}
\newcommand{\vars}{\SF{LocalVars}}
\newcommand{\Edge}{\SF{Edge}}
\newcommand{\node}{\mathbb{N}}
\newcommand{\controlpoint}{\mathbb{C}}
\newcommand{\chfi}[1]{\chf{\ensuremath{\diamond}#1}}
\newcommand{\ahf}[1]{\widehat{\underline{\sf #1}}}
\newcommand{\ahfi}[1]{\ahf{\ensuremath{\diamond}#1}}
\newcommand{\exc}[1]{{\sf #1}}
\newcommand{\varloc}[1]{\##1}
\newcommand{\varprop}[1]{@#1}
\newcommand{\avarloc}[1]{\hat{\##1}}
\newcommand{\avarprop}[1]{\hat{@#1}}
\newcommand{\vtrue}{\SF{true}}
\newcommand{\vfalse}{\SF{false}}
\newcommand{\rwith}{~{\sf with}~}
\newcommand{\atrue}{\hat{\SF{true}}}
\newcommand{\afalse}{\hat{\SF{false}}}
\newcommand{\aundef}{\hat{\SF{undefined}}}
\newcommand{\anull}{\hat{\SF{null}}}

%% from ir2cfg.tex
\newcommand{\transfun}[1]{\ensuremath{\lbr #1 \rbr}}
\newcommand{\irseq}[1]{\textsf{IRSeq}(#1)}
\newcommand{\irstmtunit}[1]{\textsf{IRStmtUnit}(#1)}
\newcommand{\irvar}[1]{\textsf{var} \ #1}
\newcommand{\irfundecl}[7]{\textsf{function}\ #1(#2,#3)\{#4,#5,#6,#7\}}
\newcommand{\irfundeclsmall}[7]{
	\begin{smallmatrix}
	\textsf{function}\ #1(#2,#3)\\ 
	\{#4,#5,#6,#7\}
	\end{smallmatrix}}

%\newcommand{\irfunexpr}[8]{#1 = \textsf{function}\ #2(#3,#4)\{#5,#6,#7,#8\}}
\newcommand{\irfunexprsmall}[8]{
	\begin{smallmatrix}
	#1 = \textsf{function}\ #2(#3,#4)\\ 
	\{#5,#6,#7,#8\}
	\end{smallmatrix}}
\newcommand{\irobject}[2]{#1 = \textsf{\{}#2\textsf{\}}}
\newcommand{\ircfgfield}[2]{#1 : #2}
\newcommand{\irarray}[2]{#1 = \textsf{[}#2\textsf{]}}
\newcommand{\ircfgcall}[3]{#1 = #2\textsf{(}#3\textsf{)}}
\newcommand{\ircfgnew}[3]{#1 = #2\textsf{(}#3\textsf{)}}
\newcommand{\ircfgwith}[2]{\textsf{with(}#1\textsf{)} \ #2}
\newcommand{\ircfgbreak}[1]{\textsf{break} \ #1}
\newcommand{\irthrow}[1]{\textsf{throw} \ #1}
\newcommand{\ircfgreturn}[1]{\textsf{return} \ #1}
\newcommand{\irlabel}[2]{#1:\textsf{\{} #2 \textsf{\}}}
\newcommand{\irifelse}[3]{\textsf{if(} #1 \textsf{)}\ #2\ \textsf{else}\ #3}
\newcommand{\ircfgif}[2]{\textsf{if(} #1 \textsf{)}\ #2}
\newcommand{\ircfgwhile}[2]{\textsf{while(} #1 \textsf{)} \ #2}
%\newcommand{\irtry}[1]{\textsf{try\{} #1 \textsf{\}}}
\newcommand{\ircfgtrycat}[3]{\textsf{try\{} #1 \textsf{\} catch(} #2 \textsf{)}\ \{#3\}}
\newcommand{\ircfgtryfin}[2]{\textsf{try\{} #1 \textsf{\}\ finally}\ \{#2\}}
\newcommand{\irtryfull}[4]{
	\begin{smallmatrix}
	\textsf{try\{} #1 \textsf{\}\ catch(} #2 \textsf{)}\ \{#3\} \\ 
	\textsf{finally}\ \{#4\}
	\end{smallmatrix}}
\newcommand{\ircfgexpr}[2]{#1 = #2}
\newcommand{\irdelete}[2]{#1 = \textsf{delete}\ #2}
\newcommand{\irdeleteobj}[3]{#1 = \textsf{delete}\ #2[#3]}
\newcommand{\irassign}[2]{#1 = #2}
\newcommand{\irunop}[2]{#1 = \preop\ #2}
\newcommand{\irbiop}[3]{#1 = #2 \inop #3}
\newcommand{\irstore}[3]{#1[#2] = #3}
\newcommand{\irload}[3]{#1 = #2[#3]}

\newcommand{\instlist}[1]{\langle #1 \rangle}
\newcommand{\letval}{\overset{\emph{let}}{=}}

\newcommand{\FunctionId}{\TT{FunctionId}}
\newcommand{\ArgVars}{\TT{ArgVars}}
\newcommand{\LocalVars}{\TT{LocalVars}}
\newcommand{\argVars}{\emph{argVars}}
\newcommand{\localVars}{\emph{localVars}}
\newcommand{\Node}{\TT{Node}}
\newcommand{\BlockNode}{\TT{BlockNode}}
\newcommand{\Nodelist}{\TT{Node list}}
\newcommand{\Nodeset}{\TT{Node set}}
\newcommand{\Unit}{\TT{Unit}}
\newcommand{\ControlPoint}{\TT{ControlPoint}}
%\newcommand{\Label}{\TT{Label}}
\newcommand{\LEntry}{\SF{LEntry}}
\newcommand{\LExit}{\SF{LExit}}
\newcommand{\LExitExc}{\SF{LExitExc}}
\newcommand{\CFG}{\SF{CFG}}
\newcommand{\Length}{\emph{Length}}
\newcommand{\TailOf}{\emph{TailOf}}
\newcommand{\HeadOf}{\emph{HeadOf}}
\newcommand{\Fold}{\emph{Fold}}
\newcommand{\Iter}{\emph{Iter}}
\newcommand{\GetTail}{\emph{GetTail}}
\newcommand{\ToString}{\emph{ToString}}
%\newcommand{\nullK}{{\inred\emph{null}}}
%\newcommand{\}{\emph{}}

\newcommand{\rel}{\S}


\def\inred{\color{red}}
\def\inblue{\color{blue}}
\def\inblack{\color{black}}

\begin{document}
\section{Assert}
\subsection{IR2CFG Translation Rules}
\[
\begin{array}{l@{}l@{~}l}
\transfun{\irifelse{e}{s_{\emph{true}}}{s_{\emph{false}}}}_{\emph{stmt}}(G,N,L)(fid) & = &
	n_1 \letval G.\emph{NewBlock}(fid)\\
	& & n_2 \letval G.\emph{NewBlock}(fid)\\
	& & G.\emph{AddEdge}(N,n_1)\\
	& & G.\emph{AddEdge}(N,n_2)\\
	& & G.AddInst(n_1, \TT{assert}(e))\\
	& & G.AddInst(n_2, \TT{assert}(\neg e))\\
	& & (N_1,L_1) \letval \transfun{s_{\emph{true}}}_{\emph{stmt}}(G,[n_1],L)(fid)\\
	& & (N_2,L_2) \letval \transfun{s_{\emph{false}}}_{\emph{stmt}}(G,[n_2],L_1)(fid)\\
	& & (N_1@N_2,L_2[\#throw \mapsto n_1::n_2::L_2(\#throw)])\\
	& & \\
\end{array}
\]
\[
\begin{array}{l@{}l@{~}l}
\transfun{\ircfgif{e}{s_{\emph{true}}}{}}_{\emph{stmt}}(G,N,L)(fid) & = &
	n_1 \letval G.\emph{NewBlock}(fid)\\
	& & n_2 \letval G.\emph{NewBlock}(fid)\\
	& & G.\emph{AddEdge}(N,n_1)\\
	& & G.\emph{AddEdge}(N,n_2)\\
	& & G.AddInst(n_1, \TT{assert}(e))\\
	& & G.AddInst(n_2, \TT{assert}(\neg e))\\
	& & (N_1,L_1) \letval \transfun{s_{\emph{true}}}_{\emph{stmt}}(G,[n_1],L)(fid)\\
	& & (N_1@[n_2],L_1[\#throw \mapsto n_1::n_2::L_1(\#throw)])\\
	& & \\
	
\end{array}
\]
\[
\begin{array}{l@{}l@{~}l}
\transfun{\ircfgwhile{e}{s}}_{\emph{stmt}}(G,N,L)(fid) & = &
	n_1 \letval \GetTail(G,N)(fid)\\
	& & n_{head} \letval G.\emph{NewBlock}(fid)\\
	& & n_2 \letval G.\emph{NewBlock}(fid)\\
	%& & G.\emph{AddInst}(n_2,\TT{assert}({\inred x??}))\\
	& & n_3 \letval G.\emph{NewBlock}(fid)\\
	%& & G.\emph{AddInst}(n_3,\TT{assert}({\inred \neg x??}))\\
	& & G.\emph{AddEdge}(n_1,n_{head})\\
	& & G.\emph{AddEdge}(n_{head},n_2)\\
	& & G.\emph{AddEdge}(n_{head},n_3)\\
	& & G.AddInst(n_2, \TT{assert}(e))\\
	& & G.AddInst(n_3, \TT{assert}(\neg e))\\
	& & (N_1,L_1) \letval \transfun{s}_{\emph{stmt}}(G,[n_2],L)(fid)\\
	& & G.\emph{AddEdge}(N_1,n_{head})\\
	& & ([n_3],L_1[\#throw \mapsto n_2::n_3::L_1(\#throw)) \\
	& & \\
\end{array}
\]

\newpage
\subsection{Collecting Semantics}
\[
\begin{array}{ll}

\B_{cp} \lbr e \rbr(H,A)
 = S \\
\quad\wherec{
  \V \lbr e \rbr(H, A) = v\\
  S=\left\{
    \begin{array}{ll}
      (H, A) & \chf{toBoolean}(v) = \vtrue \\
      {\sf stuck} & \chf{toBoolean}(v) = \vfalse \\
    \end{array}
  \right.
}
\\
\B_{cp} \lbr e \rbr(H,A) 
 = (H_1[\#temp \mapsto H_1(\#temp)[@exception \mapsto l_e]], A) \\
\quad\wherec{
   \V \lbr e \rbr(H, A) = exc\\
   l_e = \chf{newLocation}() \\
   H_1=H[l_e\mapsto\chf{NewExceptionObject}(exc)] \\
}

\end{array}
\]
\newpage
\subsection{Abstract Semantics}
\[
\begin{array}{rlcl}
pe \in & \SF{PrunExpression} & = & \{x, e_1[ e_2 ]\}\\
re \in & \SF{RelExpr} & = & \SF{Expression} ~\rel ~ \SF{Expression} \\
\rel \in & \SF{IROP} & = & \SF{IRRelOP} \cup \SF{IRObjOP} \\
& \SF{IRRelOP} & = &  == ~\mid~ != ~\mid~ === ~\mid~ !== ~\mid~ > ~\mid~ >= ~\mid~ < ~\mid~ <= ~\mid\\
& \SF{IRObjOP} & = & \TT{in} ~\mid~ \TT{notIn} ~\mid~ \TT{instanceof} ~\mid~ \TT{notInstanceof}\\
\end{array}
\]
\[
\begin{array}{ll}
\rel^t &: \SF{IRRelOP} \rightarrow \SF{IRRelOP}\\
& \rel^ t = \left\{
  \begin{array}{ll}
    < & \ifc{ \rel ~=~ >}\\
    <= & \ifc{ \rel ~=~ >=}\\
    > & \ifc{ \rel ~=~ <}\\
    >= & \ifc{ \rel ~=~ <=}\\
    \rel & \owc \\
  \end{array}
\right.\\
\\\\
  \end{array}
\]
\[
\begin{array}{lll}
\hat\B &: \SF{ControlPoint} \rightarrow \SF{Expression} \rightarrow \aState \times \aState \rightarrow \aState \times \aState \\

&\aB_{cp} \lbr e \rbr \left( (\hat{H},\hat{C}), \hat{S} \right) =  \left( (\hat{H}_1, \hat{C}_1), \hat{S}_1 \right)\\
&\quad\wherec{
  relSet = \left\{
    \begin{array}{ll}
      \ahf{getRel}(e_1 \rel e_2, (\hat{H}, \hat{C}))\cup \ahf{getRel}(e_2 \rel^t e_1, (\hat{H}, \hat{C})) & \ifc{ e_1 \rel e_2 = e \land \rel \in \SF{IRRelOP}}\\
      \{ e \} & \ifc{ e_1 \rel e_2 = e \land \rel \in \SF{IRObjOP}}\\
      \O & \owc
    \end{array}
  \right.\\
  (\hat{v}, \hat{es}) = \hat{\V} \lbr e \rbr(\hat{H},\hat{C})\\
  \hat{S}_1 = \hat{S} \sqcup \ahf{RaiseException}(\hat{H}, \hat{C}, \hat{es})\\
  (\hat{H}_1, \hat{C}_1) =
    \left\{
      \begin{array}{ll}
        \bigsqcap_{re \in relSet} \ahf{X} \lbr re \rbr (\hat{H},\hat{C}) & 
          \ifc{ relSet \not= \O \land \hat\vtrue \sqsubseteq \ahf{toBoolean}(\hat{v}).1.3}\\
        (\hat{H}, \hat{C}) & 
          \ifc{ relSet = \O \land \hat\vtrue \sqsubseteq \ahf{toBoolean}(\hat{v}).1.3}\\
         (\bot_{Heap}, \bot_{Context}) & 
          \owc
      \end{array}
    \right.\\
}
\\\\

\ahf{X} & : \SF{RelExpr} \rightarrow \aState \rightarrow \aState\\
& \ahf{X} \lbr re \rbr (\hat{H}, \hat{C}) = (\hat{H}_1, \hat{C}_1)\\
& \quad\wherec{
  e_1 ~ \rel ~ e_2 = re\\
  \hat{v}_1 = (\aV \lbr e_1 \rbr (\hat{H}, \hat{C})).1\\
  \hat{v}_2 = (\aV \lbr e_2 \rbr (\hat{H}, \hat{C})).1\\
  (\hat{H}_1, \hat{C}_1) = 
    \left\{ 
      \begin{array}{ll}
        \ahf {Pruning}_1 (e_1, \hat{v}_1, \rel, \hat{v}_2, (\hat{H}, \hat{C})) & 
          \ifc{\rel \in \SF{IRRelOP} \land e_1 \in \SF{PrunExpression}}\\
        \ahf {Pruning}_2 ( re, (\hat{H}, \hat{C})) & 
          \ifc{\rel \in \SF{IRObjOP}}\\
        (\hat{H}, \hat{C}) & \owc\\
      \end{array}
    \right.\\
}\\
\\\\
%
%\ahf{X} & : \powerset{\abs{RelExpr}} \rightarrow \aState \times \aState \rightarrow \aState \times \aState\\
%& \ahf{X} \lbr relSet \rbr \left( (\hat{H}, \hat{C}), \hat{S} \right) = \left( (\hat{H}_1, \hat{C}_1), \hat{S}_1 \right)\\
%& \quad\wherec{
%  (\hat{H}_1, \hat{C}_1) = 
%    \left\{ 
%      \begin{array}{ll}
%        \left( \bigsqcap_{\hat{re} \in relSet} \ahf {Pruning}_1(\$e_1,\hat{v}_1, \rel, \hat{v}_2, (\hat{H}, \hat{C}))\right) & 
%          \ifc{ relSet \not= \O \land \rel \in \abs{IRRelOP}}\\
%          & \wherec{ \$e_1 \rel e_2 = \hat{re}\\
%              (\hat{v}_1, \hat{es}_1) = \hat{\V}_{cp} \lbr \$e_1 \rbr (\hat{H}, \hat{C})\\
%              (\hat{v}_2, \hat{es}_2) = \hat{\V}_{cp} \lbr e_2 \rbr (\hat{H}, \hat{C}) }\\
%        \left( (\hat{H}, \hat{C}), \hat{S} \right) & \owc\\
%      \end{array}
%    \right.\\
%  \hat{S}_1 = 
%    \hat{S} \sqcup \left( \bigsqcup_{\hat{re} \in relSet} (\ahf{RaiseException} (\hat{H}, \hat{C}, \hat{es}_1) \sqcup \ahf{RaiseException} (\hat{H}, \hat{C}, \hat{es}_2)) \right)\\
%      \quad \wherec{ \$e_1 \rel e_2 = \hat{re} \\
%         (\hat{v}_1, \hat{es}_1) = \aV_{cp} \lbr \$e_1 \rbr (\hat{H}, \hat{C})\\
%         (\hat{v}_2, \hat{es}_2) = \aV_{cp} \lbr e_2 \rbr (\hat{H}, \hat{C})}\\
%}\\
%\\\\
\ahf {inheritProto}_1 &:  \aHeap \times \aLoc \times \aLoc \times \abs{Bool} \rightarrow \powerset{\aLoc}\\
& \ahf {inheritProto}_1 (\hat{H}, \hat{l}_1, \hat{l}_2, \hat{b}) = \hat{L}\\
& \quad \wherec{
  \hat{L} = \left\{
    \begin{array}{ll}
      \{ \hat{l}_1 \} & \ifc{ \hat{b} \sqsubseteq \ahf{inherit}(\hat{H}, \hat{l}_1, \hat{l}_2)}\\
      \{ \} & \owc\\
    \end{array}
  \right.\\
}
\\\\
\ahf {inheritProto}_2 &:  \aHeap \times \aLoc \times \aLoc \times \abs{Bool} \rightarrow \powerset{\aLoc}\\
& \ahf {inheritProto}_2 (\hat{H}, \hat{l}_1, \hat{l}_2, \hat{b}) = \hat{L}\\
& \quad \wherec{
  \hat{L} = \left\{
    \begin{array}{ll}
      \{ \hat{l}_2 \} & \ifc{ \hat{b} \sqsubseteq \ahf{inherit}(\hat{H}, \hat{l}_1, \hat{l}_2)}\\
      \{ \} & \owc\\
    \end{array}
  \right.\\
}
\\\\
 \end{array}
\]
\[
\begin{array}{ll}
%\ahf {PrunProto} &:  \aLoc \times \aLoc \times \abs{Bool} \times \aHeap \rightarrow \aHeap\\
%& \ahf {PrunProto} (\hat{l}_1, \hat{l}_2, \hat{b}, \hat{H}) = \hat{H}_1\\
%& \quad \wherec{
%  \hat{L}_{proto} = \bigsqcup_{\hat{l} \in \hat{H}(\hat{l}_1)(@proto).1.1.1.2} \ahf{inheritProto}_1(\hat{H}, \hat{l}, \hat{l}_2, \hat{b})\\
%  \hat{H}_2 = \hat{H}[\hat{l}_1 \mapsto \hat{H}(\hat{l}_1)[@proto \mapsto \langle \langle \bot_{PValue}, \hat{L}_{proto} \rangle, \afalse, \afalse, \afalse \rangle]]\\
%  \hat{H}_1 = \left\{
%    \begin{array}{ll}
%      \bigsqcap_{\hat{l} \in (\hat{L}_{proto} - \hat{l}_2)} \ahf{PrunProto}(\hat{l}, \hat{l}_2, \hat{b}, \hat{H}_2) & \ifc{ \hat{L}_{proto} \not= \O}\\
%      \hat{H} & \owc\\
%    \end{array}        
%  \right.\\
%}
%\\\\
%\ahf {PrunProto}_2 &:  \aLoc \times \aLoc \times \abs{Bool} \times \aHeap \rightarrow \aHeap\\
%& \ahf {PrunProto} (\hat{l}_1, \hat{l}_2, \hat{b}, \hat{H}) = \hat{H}_1\\
%& \quad \wherec{
%  \hat{L}_{proto} = \bigsqcup_{\hat{l} \in \hat{H}(\hat{l}_2)(@proto).1.1.1.2} \ahf{inheritProto}_2(\hat{H}, \hat{l}_1, \hat{l}, \hat{b})\\
%  \hat{H}_2 = \hat{H}[\hat{l}_2 \mapsto \hat{H}(\hat{l}_2)[@proto \mapsto \langle \langle \bot_{PValue}, \hat{L}_{proto} \rangle, \afalse, \afalse, \afalse \rangle]]\\
%  \hat{H}_1 = \left\{
%    \begin{array}{ll}
%      \bigsqcap_{\hat{l} \in \hat{L}_{proto}} \ahf{PrunProto}(\hat{l}_1, \hat{l}, \hat{b}, \hat{H}_2) & \ifc{ \hat{L}_{proto} \not= \O}\\
%      \hat{H} & \owc\\
%    \end{array}        
%  \right.\\
%}
\\\\
\ahf {PrunInstanceof} &:  \aLoc \times \aLoc \times \abs{Bool} \times \aHeap \rightarrow \aHeap\\
& \ahf {PrunInstanceof} (\hat{l}_{obj}, \hat{l}_{fun}, \hat{b}, \hat{H}) = \hat{H}_1 \sqcap \hat{H}_2\\
& \quad\wherec{
  \hat{L}_{prototype} = \hat{H}(\hat{l}_{fun})(``prototype").1.1.1.2\\
  \hat{L}_{proto} = \hat{H}(\hat{l}_{obj})(@proto).1.1.1.2\\
  \hat{L}_1 = 
      \bigsqcup_{\hat{l}_1 \in \hat{L}_{proto}} \bigsqcup_{\hat{l}_2 \in \hat{L}_{prototype}} \ahf{inheritProto}_2(\hat{H}, \hat{l}_1, \hat{l}_2, \hat{b})\\
%  \left\{
%    \begin{array}{ll}
%      \bigsqcup_{\hat{l}_2 \in \hat{L}_{prototype}} \ahf{inheritProto}_2(\hat{H}, \hat{l}_1, \hat{l}_2, \hat{b}) & \ifc{ \hat{L}_{proto} = \{ \hat{l}_1 \} }\\
%      \{\} & \owc
%    \end{array}
%  \right.\\
  \hat{L}_2 = 
      \bigsqcup_{\hat{l}_1 \in \hat{L}_{proto}} \bigsqcup_{\hat{l}_2 \in \hat{L}_{prototype}} \ahf{inheritProto}_1(\hat{H}, \hat{l}_1, \hat{l}_2, \hat{b})\\
%  \left\{
%    \begin{array}{ll}
%      \bigsqcup_{\hat{l}_1 \in \hat{L}_{proto}} \ahf{inheritProto}_1(\hat{H}, \hat{l}_1, \hat{l}_2, \hat{b}) & \ifc{ \hat{L}_{prototype} = \{ \hat{l}_2 \} }\\
%      \{\} & \owc
%    \end{array}
%  \right.\\
  \hat{H}_1 = 
%  \left\{
%    \begin{array}{ll}
      \hat{H} \left[ \hat{l}_{obj} \mapsto \hat{H}(\hat{l}_{obj}) \left[ @proto \mapsto 
        \left\langle 
        \begin{array}{l}
        \langle \bot_{PValue}, \hat{L}_1 \rangle,\\
        \afalse,\\
        \afalse,\\
        \afalse\\
        \end{array}
        \right\rangle      
      \right]\right]\\
%         & \ifc{\ahf{size}(\hat{L}_{prototype}) = 1}\\
%      \hat{H} & \owc
%    \end{array}
%  \right.\\
  \hat{H}_2 = 
%  \left\{
%    \begin{array}{ll}
      \hat{H} \left[ \hat{l}_{fun} \mapsto \hat{H}(\hat{l}_{fun}) \left[ ``prototype" \mapsto 
        \left\langle 
        \begin{array}{l}
        \langle \bot_{PValue}, \hat{L}_2 \rangle,\\
        \afalse,\\
        \afalse,\\
        \afalse\\
        \end{array}
        \right\rangle      
      \right]\right]\\
%         & \ifc{\ahf{size}(\hat{L}_{proto}) = 1}\\
%      \hat{H} & \owc
%    \end{array}
%  \right.\\
%  \hat{H}_3 = \left\{
%    \begin{array}{ll}
%      \bigsqcap_{\hat{l}_2 \in (\hat{L}_{prototype} - \hat{l}_1)} \ahf{PrunProto}_2(\hat{l}_1, \hat{l}_2, \hat{b}, \hat{H}) & \ifc{ \hat{L}_{proto} = \{ \hat{l}_1 \} }\\
%      \hat{H} & \owc\\
%    \end{array}
%  \right.\\
}

\\\\
\ahf {DeleteAll} &: \aHeap \times \aLoc \times \abs{String} \rightarrow \aHeap\\
& \ahf{DeleteAll} (\hat{H}, \hat{l}, \hat{s}) = \hat{H}_1\\
& \quad\wherec{
  \hat{H}_2 = \ahf{Delete}(\hat{H}, \hat{l}, \hat{s}).1\\
  \hat{H}_1 = \left\{
    \begin{array}{ll}
      \ahf{DeleteAll}(\hat{H}_2, \hat{l}_1, \hat{s}) & \ifc{\hat{H}(\hat{l})(@proto).1.1.1.1.2 \sqsubseteq \bot_{Null} \\ \land \hat{H}(\hat{l})(@proto).1.1.1.2 = \{ \hat{l}_1\}}\\
      \hat{H}_2 & \owc
    \end{array}
  \right.
}


\\\\
\ahf {Pruning}_2 &: \SF{RelExpr} \times \aState \rightarrow \aState\\
& \ahf{Pruning}_2( re, (\hat{H}, \hat{C})) = (\hat{H}_1, \hat{C}_1)\\
& \quad\wherec {
  e_1 ~ \rel ~ e_2 = re\\
  \hat{v}_1 = (\aV \lbr e_1 \rbr (\hat{H}, \hat{C})).1\\
  \hat{v}_2 = (\aV \lbr e_2 \rbr (\hat{H}, \hat{C})).1\\
  \hat{s} = \ahf{toString}(\ahf{toPrimitive}(\hat{v}_1))\\

  \hat{L}_{base} = \left\{
    \begin{array}{ll}
      \bigsqcup_{\hat{l} \in \hat{v}_2.2} \ahf{ProtoBase}(\hat{H}, \hat{l}, \hat{s})  & \ifc{ \rel = \TT{in}}\\
      \hat{v}_2.2  & \owc \\
    \end{array}
  \right.\\
  (\hat{H}_1, \hat{C}_1) = \left\{
    \begin{array}{ll}
      (\hat{H}[\hat{l} \mapsto \hat{H}(\hat{l})[\hat{s} \mapsto (\hat{H}(\hat{l})(\hat{s})).1]], \hat{C}) & \ifc{\{\hat{l} \} = \hat{L}_{base} \land \{x\} = \gamma (\hat{s}) \land \rel = \TT{in}}\\
      (\ahf{DeleteAll}(\hat{H}, \hat{l}, \hat{s}), \hat{C}) & \ifc{ \{\hat{l} \} = \hat{L}_{base} \land \{x\} = \gamma (\hat{s}) \land \rel = \TT{notIn}}\\
%      ((\bigsqcap_{\hat{l}_1 \in \hat{L}_{base}} \ahf{Delete}(\hat{H}, \hat{l}_1, \hat{s})), \hat{C}) & \ifc{ \{\hat{l} \} = \hat{v}_1.2 \land \{x\} = \gamma (\hat{s}) \land \rel = \TT{notIn}}\\
      (\ahf{PrunInstanceof}(\hat{l}_1, \hat{l}, \atrue, \hat{H}), \hat{C}) & \ifc{ \{\hat{l} \} = \hat{L}_{base}  \land \{\hat{l}_1 \} = \hat{v}_1.2  \\ \land \rel = \TT{instanceof}}\\
      (\ahf{PrunInstanceof}(\hat{l}_1, \hat{l}, \afalse, \hat{H}), \hat{C}) & \ifc{ \{\hat{l} \} = \hat{L}_{base} \land \{\hat{l}_1 \} = \hat{v}_1.2 \\ \land \rel = \TT{notInstanceof}}\\
      (\bot_{Heap}, \bot_{Context}) & \ifc{ \ahf{size}(\hat{L}_{base}) = 0}\\
      (\hat{H}, \hat{C}) & \owc\\
    \end{array}
  \right.
}


\\\\
 \end{array}
\]
\[
\begin{array}{ll}
\ahf {Pruning}_1 &: \SF{PrunExpr} \times \aValue \times \SF{IRRelOP} \times \aValue \times \aState \rightarrow \aState\\
& \ahf{Pruning}_1(pe, \hat{v}_1, \rel, \hat{v}_2, (\hat{H}, \hat{C})) = (\hat{H}_1, \hat{C}_1)\\
& \quad\wherec {
%  \hat{abs} = \hat{abs}_1 \sqcap \hat{H}(\hat{l})(\hat{s}).2\\
%  \hat{L} = 
%    \left\{
%      \begin{array}{ll}
%        \{ \#\hat{Global}_{R}, \#\hat{PureLocal}_{R} \} & \ifc{ \$e = x}\\
%        (\hat{V}_{cp} \lbr e_1 \rbr (\hat{H}, \hat{C})).1.2 & \ifc{ \$e = e_1[e_2] }\\
%      \end{array}
%    \right.\\
  (\hat{v}, \hat{abs}) = \ahf{K}_\rel (\hat{v}_2)\\
  \hat{s} = 
    \left\{
      \begin{array}{ll}
        ``\hat{x}" & \ifc{ pe = x}\\
        \ahf{toString}(\hat{pv}) &
          \ifc{ pe = e_1[e_2]}\\
          & \wherec{\hat{pv} = \ahf{toPrimitive}((\aV \lbr e_2 \rbr (\hat{H}, \hat{C})).1) }
      \end{array}
    \right.\\
  \hat{L}_{base} = \left\{
    \begin{array}{ll}
      \ahf{LookupBase}(\hat{H}, \hat{C}.1, ``x") & \ifc{ pe = x }\\
      \bigsqcup_{\hat{l} \in (\aV \lbr e_1 \rbr (\hat{H}, \hat{C})).1.2 } \ahf{ProtoBase}(\hat{H}, \hat{l}, \hat{s}) & \ifc{ pe = e_1[e_2] }\\
    \end{array}
  \right.\\
  \hat{propv} = \left\{
    \begin{array}{ll}
      \langle \langle \hat{v} \sqcap \hat{v}_1, \hat{ov}.2, \hat{ov}.3, \hat{ov}.4 \rangle, \bot_{Value}, \bot_{FunctionId} \rangle & \ifc {\ahf{size}(\hat{L}_{base}) = 1}\\
        &\wherec{
          \hat{l} \in \hat{L}_{base}\\
          \hat{ov} = \hat{H}(\hat{l})(\hat{s}).1.1\\
          }\\
      \bot_{PropValue} & \owc\\
    \end{array}
  \right.\\
  (\hat{H}_1, \hat{C}_1) = 
    \left\{
      \begin{array}{ll}
      (\hat{H}[\hat{l} \mapsto \hat{H} (\hat{l})[ \hat{s} \mapsto \langle \hat{propv},  \hat{abs} \sqcap \hat{H}(\hat{l})(\hat{s}).2 \rangle]], \hat{C}) &
         \ifc{\ahf{size}(\hat{L}_{base}) = 1\land \{x\} = \gamma(\hat{s})}\\
         & \wherec{ \hat{l} \in \hat{L}_{base} }\\
        (\bot_{Heap}, \bot_{Context}) &
          \ifc{ \ahf{size}(\hat{L}_{base}) = 0} \\
        (\hat{H}, \hat{C}) &
          \owc \\
      \end{array}
    \right.
}\\
\\\\
%
%\ahf{GetPropLoc} & : \aHeap \times \aLoc \times \abs{String} \rightarrow \powerset{\aLoc}\\
%& \ahf{GetPropLoc} (\hat{H}, \hat{l}, \hat{s}) = \hat{L}_1 \sqcup \hat{L}_2\\
%&  \quad\wherec{
%    \hat{L}_{proto} = \hat{H}(\hat{l})(@proto).1.1.1.2\\
%    \hat{L}_1 = \left\{
%      \begin{array}{ll}
%        \{\hat{l}\} & 
%        \ifc{ \atrue \sqsubseteq \ahf{HasOwnProperty}(\hat{H}, \hat{l}, \hat{s}) }\\
%        \{\} & \owc\\
%      \end{array}
%    \right.\\
%    \hat{L}_2 = \left\{
%      \begin{array}{ll}
%        \bigsqcup_{\hat{l}_{proto} \in \hat{L}_{proto}} \ahf{GetPropLoc}(\hat{H}, \hat{l}_{proto}, \hat{s}) & 
%        \ifc{ \afalse \sqsubseteq \ahf{HasOwnProperty}(\hat{H}, \hat{l}, \hat{s}) }\\
%        \{\} & \owc\\
%      \end{array}
%    \right.
%  }
\ahf{K} & : \SF{IRRelOP} \rightarrow \aValue \rightarrow \aValue \times \abs{Absent}\\
& \ahf{K}_{!==} \hat{v}_1 = (\top_{Value}, \hat{\SF{absent}})\\
& \ahf{K}_{===} \hat{v}_1 = (\hat{v}_1, \hat{abs})\\
& \quad \wherec{ 
  \hat{abs} = \left\{
    \begin{array}{ll}
      \hat{\SF{absent}} & \ifc{ \aundef \sqsubseteq \hat{v}_1.1.1}\\
      \bot_{Absent} & \owc\\
    \end{array}
  \right.\\
}\\
& \ahf{K}_{!=} \hat{v}_1 = (\top_{Value}, \hat{\SF{absent}})\\
& \ahf{K}_{==} \hat{v}_1 = (\langle \langle \hat{v}_1.1.1 \sqcup \hat{pv}_1,\hat{v}_1.1.2 \sqcup \hat{pv}_2, \hat{v}_1.1.3 \sqcup \hat{pv}_3, \hat{v}_1.1.4 \sqcup \hat{pv}_4, \top_{String} \rangle, \top_{\aLoc}  \rangle, \hat{abs})\\ 
%\end{array}\\
& \quad\wherec{
  \hat{abs} = \left\{
    \begin{array}{ll}
      \hat{\SF{absent}} & \ifc{ \aundef \sqsubseteq \hat{v}_1.1.1 \lor \anull \sqsubseteq \hat{v}_1.1.2}\\
      \bot_{Absent} & \owc\\
    \end{array}
  \right.\\
  n_1 = \left\{
    \begin{array}{ll}
      \hat{1} & \ifc{ \atrue \sqsubseteq \hat{v}_1.1.3}\\
      \bot_{Number} & \owc\\
    \end{array}
  \right.\\
  n_2 = \left\{
    \begin{array}{ll}
      \hat{0} & \ifc{ \afalse \sqsubseteq \hat{v}_1.1.3}\\
      \bot_{Number} & \owc\\
    \end{array}
  \right.\\
  n_3 = \ahf{Str2Num} ((\hat{v}_1.1.5)_{\hat{PValue}})\\
  n_4 = \left\{
    \begin{array}{ll}
      \bot_{Number} & \ifc{ \hat{v}_1.1.4 \sqsubseteq \hat{NaN}}\\
      \hat{v}_1.1.4 & \owc\\
    \end{array}
  \right.\\
%  \hat{L}_{loc} = \ahf{getLoc}(\hat{H}, \hat{v}.2)\\
  \hat{pv}_1 = \left\{
    \begin{array}{ll}
      \aundef & \ifc {\anull \sqsubseteq \hat{v}_1.1.2}\\
      \bot_{Undef} & \owc\\
    \end{array}
  \right.\\
  \hat{pv}_2 = \left\{
    \begin{array}{ll}
      \anull & \ifc {\aundef \sqsubseteq \hat{v}_1.1.1}\\
      \bot_{Null} & \owc\\
    \end{array}
  \right.\\
  \hat{pv}_3 = \left\{
    \begin{array}{ll}
      \top_{Bool} & \ifc{ \hat{\sf{UINT}} \sqsubseteq \hat{v}_1.1.4 \lor \hat{v}_1.2 \not= \O }\\
      \atrue & \ifc{ \hat{v}_1.2 = \O \land (\hat{1} \sqsubseteq \hat{v}_1.1.4 \lor \hat{1} \sqsubseteq \ahf{Str2Num}((\hat{v}_1.1.5)_{\hat{PValue}}))}\\
      \afalse & \ifc{ \hat{v}_1.2 = \O \land (\hat{0} \sqsubseteq \hat{v}_1.1.4 \lor \hat{0} \sqsubseteq \ahf{Str2Num}((\hat{v}_1.1.5)_{\hat{PValue}}))}\\
      \bot_{Bool} & \owc\\
    \end{array}
  \right.\\
  \hat{pv}_4 = \left\{
    \begin{array}{ll}
      n_1 \sqcup n_2 \sqcup n_3 \sqcup n_4  & \ifc{ \hat{v}_1.2 = \O} \\
      \top_{Number} & \owc
    \end{array}
  \right.\\
}\\
%\\\\
%\ahf{getLoc} & : \aHeap \times \aLoc \rightarrow \powerset{\aLoc}\\
%& \begin{array}{ll}
%  \ahf{getLoc}(\hat{H}, \hat{l}) = \{\hat{l}\} \cup (\bigcup_{\hat{l}_1 \in \hat{v}.2} \ahf{getLoc}(\hat{l}_1))\\
%  \quad\wherec{
%    \hat{v} = \hat{H}(\hat{l})\\
%  }
%\end{array}\\
\\\\
\end{array}
\]
\[
\begin{array}{ll}
\ahf{size} & : \powerset{\aLoc} \rightarrow {\sf Number}\\
& \begin{array}{llll}
  \ahf{size}(\{\}) & = & {\sf 0}\\
  \ahf{size}( \hat{L} ) & = & {\sf 1} + \ahf{size}(\hat{L}_1) & \wherec { \hat{l} \in \hat{L}\\ \hat{L}_1 = \hat{L} - \{\hat{l}\}}\\
\end{array}\\
\\\\

\ahf{getRel} & : \SF{RelExpr} \rightarrow \aState \rightarrow \powerset{\SF{RelExpr}}\\
%& \ahf{getRel}(\hat{re}, \hat{S}) = \hat{re}_1 \sqcup \hat{re}_2 \sqcup \hat{re}_3\\
%& \quad\wherec{
%  (\hat{H}, \hat{C}) = \hat{S}\\
%  e_1 \rel e_2 = \hat{re}\\
%  b = \ahf{validity}(\aV \lbr e_2 \rbr (\hat{H}, \hat{C}).1) \land b_1\\
%  b_1 = \left\{
%    \begin{array}{ll}
%      \ahf{validity}(\aV \lbr e_3 \rbr (\hat{H}, \hat{C}).1) \land \ahf{validity}(\aV \lbr e_4 \rbr (\hat{H}, \hat{C}).1) & \ifc { e_3 \otimes e_4 = e_1}\\
%      \vfalse & \owc\\
%    \end{array}
%  \right.\\
%  \hat{re}_1 = \left\{
%    \begin{array}{ll}
%      \{\hat{re}\} &  \ifc{ e_1 \in \$\sf{Expression}}\\
%      \{\} & \owc
%    \end{array}
%   \right.\\
%  \hat{re}_2 = \left\{
%    \begin{array}{ll}
%      \ahf{getRel}(e_3 \rel ( e_2 - e_4 ), \hat{S} ) \sqcup \ahf{getRel}(e_4 \rel ( e_2 - e_3 ), \hat{S} ) &  \ifc{ e_3 + e_4 = e_1 \land b}\\
%      \ahf{getRel}(e_3 \rel ( e_2 + e_4 ), \hat{S} ) \sqcup \ahf{getRel}(e_4 \rel^t ( e_2 - e_3 ), \hat{S} ) &  \ifc{ e_3 - e_4 = e_1 \land b}\\
%      \{\} & \owc
%    \end{array}
%   \right.\\
%  \hat{re}_3 = \left\{
%    \begin{array}{ll}
%      \ahf{getRel}((e_3 * n ) \rel e_2, \hat{S} ) &  \ifc{ n * e_3 = e_1 \land b}\\
%      \ahf{getRel}(e_3 \rel ( e_2 / n), \hat{S} ) &  \ifc{ e_3 * n = e_1 \land b \land n > 0}\\
%      \ahf{getRel}(e_3 \rel ( e_2 * n), \hat{S} ) &  \ifc{ e_3 / n = e_1 \land b \land n > 0}\\
%      \ahf{getRel}(e_3 \rel^t ( e_2 / n), \hat{S} ) &  \ifc{ e_3 * n = e_1 \land b \land n < 0}\\
%      \ahf{getRel}(e_3 \rel^t ( e_2 * n), \hat{S} ) &  \ifc{ e_3 / n = e_1 \land b \land n < 0}\\
%      \{\} & \owc
%    \end{array}
%   \right.\\
%}\\
& \begin{array}{lll}
  \ahf{getRel}(pe \rel e, \hat{S}) &=& \{pe \rel e\}\\
  \ahf{getRel}((e_1 + e_2) \rel e_3, \, \hat{S})  &=& \ahf{getRel} (e_1 \rel (e_3 - e_2), \hat{S}) \cup \ahf{getRel} (e_2 \rel (e_3 - e_1), \hat{S}) \quad \ifc{\ahf{validity}_3(e_1, e_2, e_3, \hat{S})}\\
  \ahf{getRel}((e_1 - e_2) \rel e_3, \hat{S})  &=& \ahf{getRel} (e_1 \rel (e_3 + e_2), \hat{S}) \cup \ahf{getRel} (e_2 \rel^t (e_1 - e_3), \hat{S})\quad \ifc{\ahf{validity}_3(e_1, e_2, e_3, \hat{S})}\\
  \ahf{getRel} ((n * e_1) \rel e_2, \hat{S})  &=& \ahf{getRel} ((e_1  * n) \rel e_2, \hat{S}) \quad \ifc{\ahf{validity}_2(e_1, e_2, \hat{S})}\\
  \ahf{getRel} ((e_1  * n) \rel e_2, \hat{S}) &=& \ahf{getRel} (e_1 \rel (e_2/n), \hat{S}) \quad \ifc {n>0 \land \ahf{validity}_2(e_1, e_2, \hat{S})}\\
  \ahf{getRel} ((e_1  * n) \rel e_2, \hat{S}) &=& \ahf{getRel} (e_1 \rel^t (e_2/n), \hat{S}) \quad \ifc {n<0 \land \ahf{validity}_2(e_1, e_2, \hat{S})}\\
  \ahf{getRel} ((e_1  / n) \rel e_2, \hat{S}) &=& \ahf{getRel} (e_1 \rel (e_2*n), \hat{S}) \quad \ifc {n>0 \land \ahf{validity}_2(e_1, e_2, \hat{S})}\\
  \ahf{getRel} ((e_1  / n) \rel e_2, \hat{S}) &=& \ahf{getRel} (e_1 \rel^t (e_2*n), \hat{S}) \quad \ifc {n<0 \land \ahf{validity}_2(e_1, e_2, \hat{S})}\\
\end{array}\\
%& \quad \wherec{
%  (\hat{H}, \hat{C}) = \hat{S}\\
%  (\hat{v}_1, \hat{es}_1) = \hat{\V}_{cp} \lbr e_1 \rbr (\hat{H}, \hat{C})\\
%  (\hat{v}_2, \hat{es}_2) = \hat{\V}_{cp} \lbr e_2 \rbr (\hat{H}, \hat{C})\\
%  (\hat{v}_3, \hat{es}_3) = \hat{\V}_{cp} \lbr e_3 \rbr (\hat{H}, \hat{C})\\
%  \vtrue = \ahf{validity}(\hat{v}_1)\\
%  \vtrue = \ahf{validity}(\hat{v}_2)\\
%  \vtrue = \ahf{validity}(\hat{v}_3)\\
%}\\

& \begin{array}{lll}
  \ahf{getRel}(re) &=& \O \quad\owc
\end{array}\\\\

\end{array}
\]
\[
\begin{array}{ll}

\ahf{validity}_1 & : \sf{Expression} \times \aState \rightarrow {\sf Boolean}\\
& \ahf{validity}_1(e, (\hat{H}, \hat{C})) = b\\
& \quad\wherec {
  \hat{v} = (\aV \lbr e \rbr (\hat{H}, \hat{C})).1\\
  b = \left\{
    \begin{array}{ll}
      \vtrue & 
        \ifc{ \hat{v}.1.1 \sqsubseteq \bot_{Undef} \land \hat{v}.1.2 \sqsubseteq \bot_{Null} \land (\hat{v}.1.4 \sqsubseteq \hat{\sf UInt} \lor \hat{v}.1.4 \sqsubseteq \hat{\sf NUInt})\\
           \land \hat{v}.1.5 \sqsubseteq \bot_{String} \land \hat{v}.2 = \{\} }\\
      \vfalse & \owc
    \end{array}
  \right.
}\\

\ahf{validity}_2 & : \sf{Expression} \times \sf{Expression} \times \aState \rightarrow {\sf Boolean}\\
& \ahf{validity}_2(e_1, e_2, (\hat{H}, \hat{S})) = \ahf{validity}_1(e_1, \hat{S}) \land \ahf{validity}_1(e_2, \hat{S})\\

\ahf{validity}_3 & : \sf{Expression} \times \sf{Expression} \times \sf{Expression} \times \aState \rightarrow {\sf Boolean}\\
& \ahf{validity}_3(e_1, e_2, e_3, (\hat{H}, \hat{S})) = \ahf{validity}_1(e_1, \hat{S}) \land \ahf{validity}_1(e_2, \hat{S}) \land \ahf{validity}_1(e_3, \hat{S})\\


  \end{array}
\]



\end{document}
