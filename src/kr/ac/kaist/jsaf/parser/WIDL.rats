/*******************************************************************************
    Copyright (c) 2013, KAIST, S-Core.
    All rights reserved.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.
 ******************************************************************************/

/*
 * A complete W3 Web IDL grammar.
 */
module kr.ac.kaist.jsaf.parser.WIDL;

header {
import kr.ac.kaist.jsaf.nodes.*;
import kr.ac.kaist.jsaf.nodes_util.*;
import kr.ac.kaist.jsaf.useful.Useful;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.jsaf.exceptions.JSAFError.error;
}

body {
  static {
    add(JAVASCRIPT_RESERVED, new String[] {
        "DOMString",    "Date",         "Infinity",     "NaN",
        "any",          "attribute",    "boolean",      "byte",
        "callback",     "const",        "creator",      "deleter",
        "dictionary",   "double",       "enum",         "exception",
        "false",        "float",        "getter",       "implements",
        "inherit",      "interface",    "legacycaller", "long",
        "null",         "object",       "octet",        "optional",
        "or",           "partial",      "readonly",     "sequence",
        "setter",       "short",        "static",       "stringifier",
        "true",         "typedef",      "unrestricted", "unsigned",
        "void",

        // reserved identifiers
        "prototype",    "constructor",  "toString"
    });
  }
}

option setOfString(JAVASCRIPT_RESERVED), parser(kr.ac.kaist.jsaf.parser.WIDL);

/*
 * Definitions ::= ExtendedAttributeList w Definition w Definitions
 *               | \epsilon
 */
public void WIDL =
     w EndOfFile
   / w ExtendedAttributeList? w Definition w WIDL w EndOfFile
   ;

/*
 * Definition ::= CallbackOrInterface
 *              | Partial 
 *              | Dictionary 
 *              | Exception 
 *              | Enum 
 *              | Typedef 
 *              | ImplementsStatement
 */
private void Definition =
     CallbackOrInterface
   / Partial 
   / Dictionary 
   / Exception 
   / Enum 
   / Typedef 
   / ImplementsStatement
   ;

/*
 * CallbackOrInterface ::= "callback" w CallbackRestOrInterface
 *                       | Interface
 */
private void CallbackOrInterface =
     callback w CallbackRestOrInterface 
   / Interface
   ;

/*
 * CallbackRestOrInterface ::= CallbackRest 
 *                           | Interface
 */
private void CallbackRestOrInterface =
     CallbackRest 
   / Interface
   ;

/*
 * Interface ::= "interface" w identifier w Inheritance w "{" w InterfaceMembers w "}" w ";"
 */
private void Interface =
   interface w IdText w Inheritance? w opencurly w InterfaceMembers? w closecurly w semicolon ;

/*
 * Partial ::= "partial" w PartialDefinition
 */
private void Partial =
   partial w PartialDefinition ;

/*
 * PartialDefinition ::= PartialInterface 
 *                     | PartialDictionary
 */
private void PartialDefinition =
     PartialInterface 
   / PartialDictionary
   ;

/*
 * PartialInterface ::= "interface" w identifier w "{" w InterfaceMembers w "}" w ";"
 */
private void PartialInterface =
   interface w IdText w opencurly w InterfaceMembers? w closecurly w semicolon ;

/*
 * InterfaceMembers ::= ExtendedAttributeList w InterfaceMember w InterfaceMembers 
 *                    | \epsilon
 */
private void InterfaceMembers =
   ExtendedAttributeList? w InterfaceMember w InterfaceMembers? ;

/*
 * InterfaceMember ::= Const 
 *                   | AttributeOrOperation
 */
private void InterfaceMember =
     Const 
   / AttributeOrOperation
   ;

/*
 * Dictionary ::= "dictionary" w identifier w Inheritance w "{" w DictionaryMembers w "}" w ";"
 */
private void Dictionary =
   dictionary w IdText w Inheritance? w opencurly w DictionaryMembers? w closecurly w semicolon ;

/*
 * DictionaryMembers ::= ExtendedAttributeList w DictionaryMember w DictionaryMembers 
 *                     | \epsilon
 */
private void DictionaryMembers =
   ExtendedAttributeList? w DictionaryMember w DictionaryMembers?
   ;

/*
 * DictionaryMember ::= Type w identifier w Default w ";"
 */
private void DictionaryMember =
   Type w IdText w Default? w semicolon ;

/*
 * PartialDictionary ::= "dictionary" w identifier w "{" w DictionaryMembers w "}" w ";"
 */
private void PartialDictionary =
   dictionary w IdText w opencurly w DictionaryMembers? w closecurly w semicolon ;

/*
 * Default ::= "=" w DefaultValue | \epsilon
 */
private void Default =
   equals w DefaultValue
   ;

/*
 * DefaultValue ::= ConstValue | string
 * When a default value is specified using a string token,
 * its value is a DOMString or enumeration determined as follows:
 *   1. Let S be the sequence of characters matched by the string token with
 *      its leading and trailing U+0022 QUOTATION MARK ('"') characters removed.
 *   2. The value of the string token is the sequence of 16 bit unsigned integer
 *      code units (hereafter referred to just as code units) corresponding to
 *      the UTF-16 encoding of S.
 */
private void DefaultValue =
     ConstValue 
   / string
   ;

/*
 * Exception ::= "exception" w identifier w Inheritance w "{" w ExceptionMembers w "}" w ";"
 */
private void Exception =
   exception w IdText w Inheritance? w opencurly w ExceptionMembers? w closecurly w semicolon ;

/*
 * ExceptionMembers ::= ExtendedAttributeList w ExceptionMember w ExceptionMembers 
 *                    | \epsilon
 */
private void ExceptionMembers =
   ExtendedAttributeList? w ExceptionMember w ExceptionMembers?
   ;

/*
 * Inheritance ::= ":" w identifier | \epsilon
 */
private void Inheritance =
   colon w id
   ;

/*
 * Enum ::= "enum" w identifier w "{" w EnumValueList w "}" w ";"
 */
private void Enum =
   enum w IdText w opencurly w EnumValueList w closecurly w semicolon ;

/*
 * EnumValueList ::= string w EnumValues
 */
private void EnumValueList =
   string w EnumValues? ;

/*
 * EnumValues ::= "," w string w EnumValues | \epsilon
 */
private void EnumValues =
   comma w string w EnumValues?
   ;

/*
 * CallbackRest ::= identifier w "=" ReturnType w "(" w ArgumentList w ")" w ";"
 */
private void CallbackRest =
   IdText w equals w ReturnType w openparen w ArgumentList? w closeparen w semicolon ;

/*
 * Typedef ::= "typedef" w ExtendedAttributeList w Type w identifier w ";"
 */
private void Typedef =
   typedef w ExtendedAttributeList? w Type w IdText w semicolon ;

/*
 * ImplementsStatement ::= identifier w "implements" w identifier w ";"
 */
private void ImplementsStatement =
   IdText w implements w IdText w semicolon ;

/*
 * Const ::= "const" w ConstType w identifier w "=" w ConstValue w ";"
 */
private void Const =
   const w ConstType w IdText w equals w ConstValue w semicolon ;

/*
 * ConstValue ::= BooleanLiteral 
 *              | FloatLiteral 
 *              | integer 
 *              | "null"
 */
private void ConstValue =
     BooleanLiteral 
   / FloatLiteral 
   / integer 
   / nullK
   ;

/*
 * BooleanLiteral ::= "true" | "false"
 */
private void BooleanLiteral =
     true
   / false
   ;

/*
 * FloatLiteral ::= float 
 *                | "-" w "Infinity" 
 *                | "Infinity" 
 *                | "NaN"
 */
/*
 * Type unrestricted float, constant value Infinity:
 *   The value is the IEEE 754 single-precision positive infinity value.
 * Type unrestricted double, constant value Infinity:
 *   The value is the IEEE 754 double-precision positive infinity value.
 * Type unrestricted float, constant value -Infinity:
 *   The value is the IEEE 754 single-precision negative infinity value.
 * Type unrestricted double, constant value -Infinity:
 *   The value is the IEEE 754 double-precision negative infinity value.
 * Type unrestricted float, constant value NaN:
 *   The value is the IEEE 754 single-precision NaN value with the bit pattern 0x7fc00000.
 * Type unrestricted double, constant value NaN:
 *   The value is the IEEE 754 double-precision NaN value with the bit pattern 0x7ff8000000000000.
 */
private void FloatLiteral =
     float
   / minus w Infinity
   / Infinity
   / NaN
   ;

/*
 * AttributeOrOperation ::= "stringifier" w StringifierAttributeOrOperation 
 *                        | Attribute 
 *                        | Operation
 */
private void AttributeOrOperation =
     stringifier w StringifierAttributeOrOperation 
   / Attribute 
   / Operation
   ;

/*
 * StringifierAttributeOrOperation ::= Attribute 
 *                                   | OperationRest 
 *                                   | ";"
 *
 * If an operation used to declare a stringifier does not have an identifier,
 * then prose accompanying the interface must define the stringification behavior
 * of the interface. If the operation does have an identifier, then the object is
 * converted to a string by invoking the operation to obtain the string.
 *
 * Stringifiers declared with operations must be declared to take zero arguments
 * and return a DOMString.
 *
 * As a shorthand, if the stringifier keyword is declared using an operation with
 * no identifier, then the operation’s return type and argument list can be omitted.
 *
 * The stringifier keyword must not be placed on an attribute unless it is declared
 * to be of type DOMString.
 */
private void StringifierAttributeOrOperation =
     Attribute 
   / OperationRest 
   / semicolon
   ;

/*
 * Attribute ::= Inherit w ReadOnly w "attribute" w Type w identifier w ";"
 * Inherit ::= "inherit" | \epsilon
 * ReadOnly ::=	"readonly" | \epsilon
 */
private void Attribute =
   inherit? w readonly? w attribute w Type a4:id w semicolon ;

/*
 * Operation ::= Qualifiers w OperationRest
 */
private void Operation =
   Qualifiers w OperationRest ;

/*
 * Qualifiers ::= "static" | Specials
 */
private void Qualifiers =
     static
   / Specials?
   ;

/*
 * Specials ::=	Special w Specials | \epsilon
 * A given special keyword must not appear twice on an operation.
 */
private void Specials =
   Special w Specials?
   ;

/*
 * Special ::= "getter" | "setter" | "creator" | "deleter" | "legacycaller"
 */
private void Special =
     getter
   / setter
   / creator
   / deleter
   / legacycaller
   ;

/*
 * OperationRest ::= ReturnType w OptionalIdentifier w "(" w ArgumentList w ")" w ";"
 * OptionalIdentifier ::= identifier | \epsilon
 * If an operation has no identifier, then it must be declared to be
 * a special operation using one of the special keywords.
 */
private void OperationRest =
   ReturnType w id? w openparen w ArgumentList? w closeparen w semicolon ;

/*
 * ArgumentList ::= Argument w Arguments 
 *                | \epsilon
 * An argument must not be declared with the ... token unless it is the final
 * argument in the operation’s argument list.
 */
private void ArgumentList =
   Argument w Arguments?
   ;

/*
 * Arguments ::= "," w Argument w Arguments 
 *             | \epsilon
 */
private void Arguments =
   comma w Argument w Arguments? 
   ;

/*
 * Argument ::=	ExtendedAttributeList w OptionalOrRequiredArgument
 */
private void Argument =
   ExtendedAttributeList? w OptionalOrRequiredArgument ;

/*
 * OptionalOrRequiredArgument ::= "optional" w Type w ArgumentName w Default
 *                              | Type w Ellipsis w ArgumentName
 * Ellipsis ::= "..." | \epsilon
 */
private void OptionalOrRequiredArgument =
     optional w Type w ArgumentName w Default? 
   / Type w ellipsis? w ArgumentName
   ;

/*
 * ArgumentName ::= ArgumentNameKeyword 
 *                | identifier
 */
private String ArgumentName =
     ArgumentNameKeyword 
   / id
   ;

/*
 * ExceptionMember ::= Const | ExceptionField
 */
private void ExceptionMember =
     Const 
   / ExceptionField
   ;

/*
 * ExceptionField ::= Type w identifier w ";"
 */
private void ExceptionField =
   Type w IdText w semicolon ;

/*
 * ExtendedAttributeList ::= "[" w ExtendedAttribute w ExtendedAttributes w "]"
 *                         | \epsilon
 */
private void ExtendedAttributeList =
   opensquare w ExtendedAttribute w ExtendedAttributes? w closesquare
   ;

/*
 * ExtendedAttributes ::= "," w ExtendedAttribute w ExtendedAttributes
 *                      | \epsilon
 */
private void ExtendedAttributes =
   comma w ExtendedAttribute w ExtendedAttributes?
   ;

/*
 * ExtendedAttribute ::= "(" w ExtendedAttributeInner w ")" w ExtendedAttributeRest
 *                     | "[" w ExtendedAttributeInner w "]" w ExtendedAttributeRest
 *                     | "{" w ExtendedAttributeInner w "}" w ExtendedAttributeRest
 *                     | Other w ExtendedAttributeRest
 */
private void ExtendedAttribute =
     openparen w ExtendedAttributeInner? w closeparen w ExtendedAttributeRest? 
   / opensquare w ExtendedAttributeInner? w closesquare w ExtendedAttributeRest? 
   / opencurly w ExtendedAttributeInner? w closecurly w ExtendedAttributeRest? 
   / Other w ExtendedAttributeRest?
   ;

/*
 * ExtendedAttributeRest ::= ExtendedAttribute | \epsilon
 */
private void ExtendedAttributeRest =
   ExtendedAttribute 
   ;

/*
 * ExtendedAttributeInner ::= "(" w ExtendedAttributeInner w ")" w ExtendedAttributeInner
 *                          | "[" w ExtendedAttributeInner w "]" w ExtendedAttributeInner
 *                          | "{" w ExtendedAttributeInner w "}" w ExtendedAttributeInner
 *                          | OtherOrComma w ExtendedAttributeInner 
 *                          | \epsilon
 */
private void ExtendedAttributeInner =
     openparen w ExtendedAttributeInner? w closeparen w ExtendedAttributeInner?
   / opensquare w ExtendedAttributeInner? w closesquare w ExtendedAttributeInner?
   / opencurly w ExtendedAttributeInner? w closecurly w ExtendedAttributeInner?
   / OtherOrComma w ExtendedAttributeInner?
   ;

/*
 * Other ::= integer | float | identifier | string | other
 *         | "-" | "." | "..." | ":" | ";" | "<" | "=" | ">" | "?" 
 *         | "Date" | "DOMString" | "Infinity" | "NaN"
 *         | "any" | "boolean" | "byte" | "double" | "false" | "float"
 *         | "long" | "null" | "object" | "octet" | "or" | "optional"
 *         | "sequence" | "short" | "true" | "unsigned" | "void" 
 *         | ArgumentNameKeyword
 */
private void Other =
     integer 
   / float
   / string 
   / other 
   / minus
   / dot
   / ellipsis
   / colon
   / semicolon
   / "<"
   / equals
   / ">"
   / question
   / Date
   / DOMString
   / Infinity
   / NaN
   / any
   / boolean
   / byte
   / double
   / false
   / floatK
   / long
   / nullK
   / object
   / octet
   / or
   / optional
   / sequence
   / short
   / true
   / unsigned
   / voidK
   / ArgumentNameKeyword
   / id
   ;

/*
 * ArgumentNameKeyword ::= "attribute" | "callback" | "const" | "creator"
 *                       | "deleter" | "dictionary" | "enum" | "exception"
 *                       | "getter" | "implements" | "inherit" | "interface"
 *                       | "legacycaller" | "partial" | "setter" | "static" 
 *                       | "stringifier" | "typedef" | "unrestricted"
 */
private String ArgumentNameKeyword =
     attribute
   / callback
   / const
   / creator
   / deleter
   / dictionary
   / enum
   / exception
   / getter
   / implements
   / inherit
   / interface
   / legacycaller
   / partial
   / setter
   / static
   / stringifier
   / typedef
   / unrestricted
   ;

/*
 * OtherOrComma = Other | ","
 */
private void OtherOrComma =
     comma
   / Other
   ;

/*
 * Type ::= SingleType
 *        | UnionType w TypeSuffix
 */
private void Type =
     SingleType 
   / UnionType w TypeSuffix?
   ;

/*
 * SingleType ::= NonAnyType
 *              | "any" w TypeSuffixStartingWithArray
 */
private void SingleType =
     NonAnyType
   / any w TypeSuffixStartingWithArray?
   ;

/*
 * UnionType ::= "(" w UnionMemberType w "or" w UnionMemberType w UnionMemberTypes w ")"
 */
private void UnionType =
   openparen w UnionMemberType w or w UnionMemberType w UnionMemberTypes? w closeparen ;

/*
 * UnionMemberType ::= NonAnyType
 *                   | UnionType w TypeSuffix
 *                   | "any" w "[" w "]" w TypeSuffix
 */
private void UnionMemberType =
     NonAnyType 
   / UnionType w TypeSuffix?
   / any w opensquare w closesquare w TypeSuffix?
   ;

/*
 * UnionMemberTypes ::= "or" w UnionMemberType w UnionMemberTypes
 *                    | \epsilon
 */
private void UnionMemberTypes =
   or w UnionMemberType w UnionMemberTypes? 
   ;

/*
 * NonAnyType ::= PrimitiveType w TypeSuffix
 *              | DOMString w TypeSuffix
 *              | identifier w TypeSuffix
 *              | sequence w "<" w Type w ">" w Null
 *              | "object" w TypeSuffix
 *              | "Date" w TypeSuffix
 */
private void NonAnyType =
     PrimitiveType w TypeSuffix? 
   / DOMString w TypeSuffix?
   / IdText w TypeSuffix?
   / sequence w "<" w Type w ">" w Null 
   / object w TypeSuffix?
   / Date w TypeSuffix?
   ;

/*
 * ConstType ::= PrimitiveType w Null
 *             | identifier w Null
 */
private void ConstType =
     PrimitiveType w Null 
   / IdText w Null
   ;

/*
 * PrimitiveType ::= UnsignedIntegerType 
 *                 | UnrestrictedFloatType 
 *                 | "boolean" 
 *                 | "byte" 
 *                 | "octet"
 */
private void PrimitiveType =
     UnsignedIntegerType
   / UnrestrictedFloatType
   / boolean
   / byte
   / octet
   ;

/*
 * UnrestrictedFloatType ::= "unrestricted" w FloatType
 *                         | FloatType
 */
private void UnrestrictedFloatType =
     unrestricted w FloatType
   / FloatType
   ;

/*
 * FloatType ::= "float" | "double"
 */
private void FloatType = floatK / double ;

/*
 * UnsignedIntegerType ::= "unsigned" w IntegerType 
 *                       | IntegerType
 */
private void UnsignedIntegerType =
     unsigned w IntegerType 
   / IntegerType
   ;

/*
 * IntegerType ::= "short"
 *               | "long" w OptionalLong
 * OptionalLong ::= "long" | \epsilon
 */
private void IntegerType =
     short
   / long w long?
   ;

/*
 * TypeSuffix ::= "[" w "]" w TypeSuffix
 *              | "?" w TypeSuffixStartingWithArray?
 *              | \epsilon
 */
private void TypeSuffix =
     opensquare w closesquare w TypeSuffix?
   / question w TypeSuffixStartingWithArray?
   ;

/*
 * TypeSuffixStartingWithArray ::= "[" w "]" w TypeSuffix | \epsilon
 */
private void TypeSuffixStartingWithArray =
   opensquare w closesquare w TypeSuffix?
   ;

/*
 * Null ::= "?" | \epsilon
 */
private void Null = question? ;

/*
 * ReturnType ::= Type | "void"
 */
private void ReturnType =
     Type
   / voidK
   ;

/*
 * ExtendedAttributeNoArgs ::= identifier
 */
private void ExtendedAttributeNoArgs = IdText ;

/*
 * ExtendedAttributeArgList ::= identifier w "(" w ArgumentList w ")"
 */
private void ExtendedAttributeArgList =
   IdText w openparen w ArgumentList? w closeparen ;

/*
 * ExtendedAttributeIdent ::= identifier w "=" w identifier
 */
private void ExtendedAttributeIdent =
   IdText w equals w IdText ;

/*
 * ExtendedAttributeNamedArgList ::= identifier w "=" w identifier w "(" w ArgumentList w ")"
 */
private void ExtendedAttributeNamedArgList =
   IdText w equals w IdText w openparen w ArgumentList? w closeparen ;

/*
 * identifier = [A-Z_a-z][0-9A-Z_a-z]*
 *
 * Any single leading U+005F LOW LINE ("_") character (underscore) is removed.
 * A leading "_" is used to escape an identifier from looking like a reserved word
 * so that, for example, an interface named “interface” can be defined. The leading
 * "_" is dropped to unescape the identifier.
 */
transient String id      = s:(idstart idrest*) &{ !JAVASCRIPT_RESERVED.contains(s) &&
                                                  !s.startsWith("__") };
transient String idname  = s:(idstart idrest*);
transient String idstart = [a-zA-Z] ;
transient String idrest  = idstart / [0-9] / [_];
private String IdText =
   a1:id
   { yyValue = NodeUtil.dropAnySingleLeadingUnderscore(a1); };

/*
 * integer ::= -?(0([0-7]*|[Xx][0-9A-Fa-f]+)|[1-9][0-9]*)
 */
transient void integer =
     minus? "0" [Xx] [0-9A-Fa-f]+
   / minus? "0" [0-7]*
   / minus? [1-9] [0-9]*
   ;

/*
 * float ::= -?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)
 */
transient void float =
     minus? floatfront floatback
   / minus? floatfront
   / minus? [0-9]+ floatback
   ;
transient void floatfront =
     [0-9]+ dot [0-9]*
   / [0-9]* dot [0-9]+
   ;
transient void floatback =
     [Ee] ("+"/"-")? [0-9]+ ;

/*
 * string = "[^"]*"
 */
transient void string =
     ["] StringChar* ["] ;
transient void StringChar =
     (!["] _) ; // " ;

/*
 * other = [^\t\n\r 0-9A-Z_a-z]
 */
transient void other =
     (!NotOther _) ;
transient void NotOther =
     [\t\n\r0-9A-Z_a-z] ;

/* If a MultiLineComment contains one or more line terminators,
 * then it is replaced by a single line terminator */
/* LineTerminator ::= <LF> | <CR> | <LS> | <PS> */
transient String LineTerminator =
     ([\u000a] / [\u000d] / [\u2028] / [\u2029])
     { yyValue = ""+a1; }
   / MultiLineCommentWLB ;

transient String MultiLineCommentWLB =
     "/*" a1s:MultiLineCommentCharNoLB* a2:LineTerminator a3s:MultiLineCommentCharWLB* "*/"
     { StringBuilder buf = new StringBuilder();
       buf.append("/*");
       for (String s : a1s.list()) buf.append(s);
       buf.append(a2);
       for (String s : a3s.list()) buf.append(s);
       buf.append("*/");
       yyValue = buf.toString();
     };

transient private String MultiLineCommentCharNoLB =
     !("*/" / LineTerminator) _ { yyValue = a1+""; } ;

transient private String MultiLineCommentCharWLB =
     !("*/") _ ;

transient void w = Space*; // whitespace optional
transient private void Space =
     void:"\t"
   / [\u000B]
   / void:"\f"
   / void:" "
   / [\u00A0]
   / [\uFEFF] ;

transient void EndOfFile  = "\u001a"? w !_ ;

transient void openparen = "(";
transient void closeparen = ")";
transient void opencurly = "{";
transient void closecurly = "}";
transient void opensquare = "[";
transient void closesquare = "]";
transient void semicolon = ";";
transient void colon = ":";
transient void equals = "=" !("=");
transient String comma = ",";
transient String minus = "-" !("-" / "=");
transient String ellipsis = "...";
transient String dot   = "." !(".");
transient void question = "?";

transient void DOMString = "DOMString" !(idrest);
transient void Date = "Date" !(idrest);
transient void Infinity = "Infinity" !(idrest);
transient void NaN= "NaN" !(idrest);
transient void any = "any" !(idrest);
transient void boolean = "boolean" !(idrest);
transient void byte = "byte" !(idrest);
transient void double = "double" !(idrest);
transient void false = "false" !(idrest);
transient void floatK = "float" !(idrest);
transient void long = "long" !(idrest);
transient void nullK = "null" !(idrest);
transient void object = "object" !(idrest);
transient void octet = "octet" !(idrest);
transient void optional = "optional" !(idrest);
transient void or = "or" !(idrest);
transient void readonly = "readonly" !(idrest);
transient void sequence = "sequence" !(idrest);
transient void short = "short" !(idrest);
transient void true = "true" !(idrest);
transient void unsigned = "unsigned" !(idrest);
transient void voidK = "void" !(idrest);

transient String attribute = "attribute" !(idrest);
transient String callback = "callback" !(idrest);
transient String const = "const" !(idrest);
transient String creator = "creator" !(idrest);
transient String deleter = "deleter" !(idrest);
transient String dictionary = "dictionary" !(idrest);
transient String enum = "enum" !(idrest);
transient String exception = "exception" !(idrest);
transient String getter = "getter" !(idrest);
transient String implements = "implements" !(idrest);
transient String inherit = "inherit" !(idrest);
transient String interface = "interface" !(idrest);
transient String legacycaller = "legacycaller" !(idrest);
transient String partial = "partial" !(idrest);
transient String setter = "setter" !(idrest);
transient String static = "static" !(idrest);
transient String stringifier = "stringifier" !(idrest);
transient String typedef = "typedef" !(idrest);
transient String unrestricted = "unrestricted" !(idrest);

transient void epsilon = "epsilon";

        /*
Static checks
1. Within the set of IDL fragments that a given implementation supports, the identifier of every interface, dictionary, exception, enumeration, callback function and typedef must not be the same as the identifier of any other interface, dictionary, exception, enumeration, callback function or typedef
2. The inheritance hierarchy should be acyclic.
3. Callback interfaces must not inherit from any non-callback interfaces, and all of a callback interface’s inherited interfaces must not have any consequential interfaces.
4. Also, Infinity, -Infinity and NaN must not be used as the value of a float or double.
5. If VT is the type of the value assigned to a constant, and DT is the type of the constant, dictionary member or optional argument itself, then these types must be compatible, which is the case if DT and VT are identical, or DT is a nullable type whose inner type is VT.
6. The identifier of an attribute must not be the same as the identifier of another interface member defined on the same interface.
7. If the Type is an identifier or an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef.
8. The type of the attribute must not be a sequence type or nullable sequence type, and it must not be a union type if one of its member types (or one of its member types’s member types, and so on) is a sequence type or nullable sequence type.
9. The attribute whose getter is being inherited must be of the same type as the inheriting attribute, and inherit must not appear on a read only attribute.
10. The identifier of a regular operation or static operation must not be the same as the identifier of a constant or attribute defined on the same interface.
The identifier can be the same as that of another operation on the interface, however.
The identifier of a static operation also must not be the same as the identifier of a regular operation defined on the same interface.
11. If the return type is an identifier or an identifier followed by ?, then the identifier must identify an interface, dictionary, enumeration, callback function or typedef.
12. If the Type of an operation argument is an identifier or an identifier followed by ?, then the identifier must identify an interface, dictionary, enumeration, callback function or typedef.
13. The identifier of each argument must not be the same as the identifier of another argument in the same operation declaration.
14. Extended attributes that take an argument list ([Constructor] and [NamedConstructor], of those defined in this specification) and callback functions are also considered to be variadic when the ... token is used in their argument lists.
15. An argument must not be declared to be optional unless all subsequent arguments to the operation are also optional. Also, the final argument in an operation must not be declared to be optional if the operation is variadic.
16. The implicitly optional final argument of a variadic operation must not have a default value specified.
17. If an optional argument has a default value, then all following arguments (except for the final argument if the operation is variadic) must also have a default value.
18. If the type of the optional argument is an enumeration, then its default value if specified must be one of the enumeration’s values.
19. The following extended attributes are applicable to operations: [TreatNullAs], [TreatUndefinedAs].
20. The following extended attributes are applicable to operation arguments: [Clamp], [EnforceRange], [TreatNullAs], [TreatUndefinedAs].
21. Getters, setters, creators and deleters come in two varieties: ones that take a DOMString as a property name, known as named property getters, named property setters, named property creators and named property deleters, and ones that take an unsigned long as a property index, known as indexed property getters, indexed property setters, indexed property creators and indexed property deleters.
22. On a given interface, there must exist at most one stringifier and at most one of each variety of getter, setter, creator and deleter. Multiple legacy callers can exist on an interface to specify overloaded calling behavior.
Indexed property getters and deleters must be declared to take a single unsigned long argument. Indexed property setters and creators must be declared to take two arguments, where the first is an unsigned long.
Named property getters and deleters must be declared to take a single DOMString argument. Named property setters and creators must be declared to take two arguments, where the first is a DOMString.
23. Special operations declared using operations must not be variadic nor have any optional arguments.
24. Special operations must not be declared on callback interfaces.
25. If an object implements more than one interface that defines a given special operation, then it is undefined which (if any) special operation is invoked for that operation.
26. Static operations must not be declared on callback interfaces.
         */

        /*
Identifier scopes
1. Within an IDL fragment, a reference to a definition need not appear after the declaration of the referenced definition. References can also be made across IDL fragments.
         */

        /*
Constants
1. The identifier of a constant must not be the same as the identifier of another interface member defined on the same interface or another exception member defined on the same exception.
2. If an identifier is used for the type of a constant (matching ConstType), it must reference a typedef whose type is a primitive type or a nullable primitive type.
         */

        /*
Extended attributes
1. The following extended attributes must not be specified on partial interface definitions: [ArrayClass], [Constructor], [ImplicitThis], [NamedConstructor], [NoInterfaceObject].
2. The following extended attributes are applicable to interfaces: [ArrayClass], [Constructor], [ImplicitThis], [NamedConstructor], [NamedPropertiesObject], [NoInterfaceObject], [OverrideBuiltins].
3. The following extended attributes are applicable to attributes: [Clamp], [EnforceRange], [LenientThis], [PutForwards], [Replaceable], [TreatNullAs], [TreatUndefinedAs], [Unforgeable].
        */

        /*
Web API static restrictions
1. If an interface supports indexed properties, then the interface definition must be accompanied by a description of what indices the object can be indexed with at any given time.
         */

        /*
3.2.6 Overloading Checks (To Include from the specification)
1. Operations and legacy callers must not be overloaded across interface and partial interface definitions.
        */
