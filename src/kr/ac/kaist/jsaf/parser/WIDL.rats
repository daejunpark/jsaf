/*******************************************************************************
    Copyright (c) 2013, KAIST, S-Core.
    All rights reserved.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.
 ******************************************************************************/

/*
 * A complete W3 Web IDL grammar.
 */
module kr.ac.kaist.jsaf.parser.WIDL;

header {
import kr.ac.kaist.jsaf.nodes.*;
import kr.ac.kaist.jsaf.nodes_util.*;
import kr.ac.kaist.jsaf.useful.Useful;
import kr.ac.kaist.jsaf.widl.*;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.jsaf.exceptions.JSAFError.error;

@SuppressWarnings("unchecked")
}

body {
  static WEAttribute eaNoInterfaceObject = WIDLFactory.eaNoInterfaceObject();
  static WEAttribute eaCallbackFunctionOnly = WIDLFactory.eaCallbackFunctionOnly();
  static {
    add(JAVASCRIPT_RESERVED, new String[] {
        "DOMString",    "Date",         "Infinity",     "NaN",
        "any",          "attribute",    "boolean",      "byte",
        "callback",     "const",        "creator",      "deleter",
        "dictionary",   "double",       "enum",         "exception",
        "false",        "float",        "getter",       "implements",
        "inherit",      "interface",    "legacycaller", "long",
        "null",         "object",       "octet",        "optional",
        "or",           "partial",      "readonly",     "sequence",
        "setter",       "short",        "static",       "stringifier",
        "true",         "typedef",      "unrestricted", "unsigned",
        "void",

        // reserved identifiers
        /*
        "prototype",    "constructor",  "toString",
        */

        // for WebKitIDL
        "module",       "in",           "raises",        "getraises",
        "setraises"
    });
  }

  Span createSpan(int start, int end) {
      int i = end;
      while ( i >= 0 && yyData.length > i && yyData[i] == ' ' ) { i--; }
      if ( i-1 >= start )
          end = i-1;
      else
          end = start;
      Column s = column(start);
      Column e = column(end);
      SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column, start);
      SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column, end);
      return new Span(slStart, slEnd);
  }

  private SpanInfo makeSpanInfo(int start, int end) {
      return NodeFactory.makeOnlySpanInfo(createSpan(start, end));
  }
}

option setOfString(JAVASCRIPT_RESERVED), parser(kr.ac.kaist.jsaf.parser.WIDL);

public List<WDefinition> WIDL =
     EndOfFile
     { yyValue = Collections.<WDefinition>emptyList(); }
   / yyVaue:Definitions w EndOfFile;

/*
 * Definitions ::= ExtendedAttributeList w Definition w Definitions
 *               | \epsilon
 */
public List<WDefinition> Definitions =
     a1:(w ExtendedAttributeList)? w a2:Definition a3:(w Definitions)?
     { if (a1 == null && a3 == null) yyValue = Useful.list(a2);
       else if (a1 == null) yyValue = Useful.list(a2, a3);
       else {
           // Rewrite [Callback=FunctionOnly, NoInterfaceObject] interfaces.
           // For example, rewrite the following:
           //
           // [Callback=FunctionOnly, NoInterfaceObject] interface ServiceProviderCreateSuccessCallback {
           //     void onsuccess(in ServiceProvider serviceProvider);
           // };
           //
           // as follows:
           //
           // callback ServiceProviderCreateSuccessCallback = void (ServiceProvider serviceProvider);
           WDefinition def = WIDLFactory.addAttrs(a1, a2);
           if (a1.contains(eaNoInterfaceObject) && a1.contains(eaCallbackFunctionOnly) &&
               a2 instanceof WInterface && ((WInterface)a2).getMembers().size() == 1) {
               WInterface interf = ((WInterface)a2);
               WInterfaceMember member = interf.getMembers().get(0);
               if (member instanceof WOperation) {
                   WOperation op = (WOperation)member;
                   def = WIDLFactory.mkCallback(a2.getInfo().getSpan(), interf.getName(),
                                                op.getTyp(), op.getArgs());
               }
           }
           if (a3 == null) yyValue = Useful.list(def);
           else yyValue = Useful.list(def, a3);
       }
     };

/*
 * Definition ::= Module              // WebKitIDL
 *              | CallbackOrInterface
 *              | Partial
 *              | Dictionary
 *              | Exception 
 *              | Enum 
 *              | Typedef 
 *              | ImplementsStatement
 */
private WDefinition Definition =
     Module              // WebKitIDL
   / CallbackOrInterface
   / Partial 
   / Dictionary 
   / Exception 
   / Enum 
   / Typedef 
   / ImplementsStatement
   ;

/*
 * Module ::= "module" w identifier w "{" w Definitions w "}" w ";"?
 */
private WDefinition Module =
     module w a1:IdText w opencurly w a2:Definitions w closecurly (w semicolon)?
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkModule(span, a1, a2);
     };

/*
 * CallbackOrInterface ::= "callback" w CallbackRestOrInterface
 *                       | Interface
 */
private WDefinition CallbackOrInterface =
     callback w a1:CallbackRestOrInterface 
     { yyValue = WIDLFactory.addCallback(a1); }
   / Interface
   ;

/*
 * CallbackRestOrInterface ::= CallbackRest 
 *                           | Interface
 */
private WDefinition CallbackRestOrInterface =
     CallbackRest
   / Interface
   ;

/*
 * Interface ::= "interface" w identifier w Inheritance w "{" w InterfaceMembers w "}" w ";"
 * // WebKitIDL
 * Interface ::= "interface" w ExtendedAttributeList w identifier w Inheritance w "{" w InterfaceMembers w "}" w ";"
 */
private WInterface Interface =
   interface a1:(w ExtendedAttributeList)? w a2:IdText a3:(w Inheritance)? w opencurly a4:(w InterfaceMembers)? w closecurly w semicolon?
     { Span span = createSpan(yyStart,yyCount);
       if (a3 == null && a4 == null) yyValue = WIDLFactory.mkInterface(span, a2);
       else if (a3 == null) yyValue = WIDLFactory.mkInterface(span, a2, a4);
       else if (a4 == null) yyValue = WIDLFactory.mkInterface(span, a2, a3);
       else yyValue = WIDLFactory.mkInterface(span, a2, a3, a4);
       if (a1 != null)
           yyValue = (WInterface)WIDLFactory.addAttrs(a1, yyValue);
     };

/*
 * Partial ::= "partial" w PartialDefinition
 */
private WDefinition Partial =
     partial w a1:PartialDefinition
     { yyValue = WIDLFactory.addPartial(a1); };

/*
 * PartialDefinition ::= PartialInterface 
 *                     | PartialDictionary
 */
private WDefinition PartialDefinition =
     PartialInterface 
   / PartialDictionary
   ;

/*
 * PartialInterface ::= "interface" w identifier w "{" w InterfaceMembers w "}" w ";"
 */
private WInterface PartialInterface =
     interface w a1:IdText w opencurly a2:(w InterfaceMembers)? w closecurly w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = WIDLFactory.mkInterface(span, a1);
       else yyValue = WIDLFactory.mkInterface(span, a1, a2);
     };

/*
 * InterfaceMembers ::= ExtendedAttributeList w InterfaceMember w InterfaceMembers 
 *                    | \epsilon
 */
private List<WInterfaceMember> InterfaceMembers =
     a1:ExtendedAttributeList? w a2:InterfaceMember a3:(w InterfaceMembers)?
     { if (a1 == null && a3 == null) yyValue = Useful.list(a2);
       else if (a1 == null) yyValue = Useful.list(a2, a3);
       else if (a3 == null) yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2));
       else yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2), a3);
     };

/*
 * InterfaceMember ::= Const 
 *                   | AttributeOrOperation
 */
private WInterfaceMember InterfaceMember =
     Const 
   / AttributeOrOperation
   ;

/*
 * Dictionary ::= "dictionary" w identifier w Inheritance w "{" w DictionaryMembers w "}" w ";"
 */
private WDictionary Dictionary =
     dictionary w a1:IdText a2:(w Inheritance)? w opencurly a3:(w DictionaryMembers)? w closecurly w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null && a3 == null) yyValue = WIDLFactory.mkDictionary(span, a1);
       else if (a2 == null) yyValue = WIDLFactory.mkDictionary(span, a1, a3);
       else if (a3 == null) yyValue = WIDLFactory.mkDictionary(span, a1, a2);
       else yyValue = WIDLFactory.mkDictionary(span, a1, a2, a3);
     };

/*
 * DictionaryMembers ::= ExtendedAttributeList w DictionaryMember w DictionaryMembers 
 *                     | \epsilon
 */
private List<WDictionaryMember> DictionaryMembers =
     a1:ExtendedAttributeList? w a2:DictionaryMember a3:(w DictionaryMembers)?
     { if (a1 == null && a3 == null) yyValue = Useful.list(a2);
       else if (a1 == null) yyValue = Useful.list(a2, a3);
       else if (a3 == null) yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2));
       else yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2), a3);
     };

/*
 * DictionaryMember ::= Type w identifier w Default w ";"
 */
private WDictionaryMember DictionaryMember =
     a1:Type w a2:IdText a3:(w Default)? w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a3 == null) yyValue = WIDLFactory.mkDictionaryMember(span, a1, a2);
       else yyValue = WIDLFactory.mkDictionaryMember(span, a1, a2, a3);
     };

/*
 * PartialDictionary ::= "dictionary" w identifier w "{" w DictionaryMembers w "}" w ";"
 */
private WDictionary PartialDictionary =
     dictionary w a1:IdText w opencurly a2:(w DictionaryMembers)? w closecurly w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = WIDLFactory.mkDictionary(span, a1);
       else yyValue = WIDLFactory.mkDictionary(span, a1, a2);
     };

/*
 * Default ::= "=" w DefaultValue | \epsilon
 */
private WLiteral Default =
     equals w yyValue:DefaultValue ;

/*
 * DefaultValue ::= ConstValue | string
 * When a default value is specified using a string token,
 * its value is a DOMString or enumeration determined as follows:
 *   1. Let S be the sequence of characters matched by the string token with
 *      its leading and trailing U+0022 QUOTATION MARK ('"') characters removed.
 *   2. The value of the string token is the sequence of 16 bit unsigned integer
 *      code units (hereafter referred to just as code units) corresponding to
 *      the UTF-16 encoding of S.
 */
private WLiteral DefaultValue =
     ConstValue 
   / string
   ;

/*
 * Exception ::= "exception" w identifier w Inheritance w "{" w ExceptionMembers w "}" w ";"
 */
private WException Exception =
     exception w a1:IdText a2:(w Inheritance)? w opencurly a3:(w ExceptionMembers)? w closecurly w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null && a3 == null) yyValue = WIDLFactory.mkException(span, a1);
       else if (a2 == null) yyValue = WIDLFactory.mkException(span, a1, a3);
       else if (a3 == null) yyValue = WIDLFactory.mkException(span, a1, a2);
       else yyValue = WIDLFactory.mkException(span, a1, a2, a3);
     };

/*
 * ExceptionMembers ::= ExtendedAttributeList w ExceptionMember w ExceptionMembers 
 *                    | \epsilon
 */
private List<WExceptionMember> ExceptionMembers =
     a1:ExtendedAttributeList? w a2:ExceptionMember a3:(w ExceptionMembers)?
     { if (a1 == null && a3 == null) yyValue = Useful.list(a2);
       else if (a1 == null) yyValue = Useful.list(a2, a3);
       else if (a3 == null) yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2));
       else yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2), a3);
     };

/*
 * Inheritance ::= ":" w identifier | \epsilon
 */
private WId Inheritance = colon w yyValue:Id ;

/*
 * Enum ::= "enum" w identifier w "{" w EnumValueList w "}" w ";"
 */
private WEnum Enum =
     enum w a1:IdText w opencurly w a2:EnumValueList w closecurly w semicolon
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkEnum(span, a1, a2);
     };

/*
 * EnumValueList ::= string w EnumValues
 */
private List<WString> EnumValueList =
     a1:string a2:(w EnumValues)?
     { if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * EnumValues ::= "," w string w EnumValues | \epsilon
 */
private List<WString> EnumValues =
     comma w a1:string a2:(w EnumValues)?
     { if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * CallbackRest ::= identifier w "=" ReturnType w "(" w ArgumentList w ")" w ";"
 */
private WCallback CallbackRest =
     a1:IdText w equals w a2:ReturnType w openparen a3:(w ArgumentList)? w closeparen w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a3 == null) yyValue = WIDLFactory.mkCallback(span, a1, a2);
       else yyValue = WIDLFactory.mkCallback(span, a1, a2, a3);
     };

/*
 * Typedef ::= "typedef" w ExtendedAttributeList w Type w identifier w ";"
 */
private WTypedef Typedef =
     typedef a1:(w ExtendedAttributeList)? w a2:Type w a3:IdText w semicolon
     { Span span = createSpan(yyStart,yyCount);
       if (a1 == null) yyValue = WIDLFactory.mkTypedef(span, a2, a3);
       else yyValue = WIDLFactory.mkTypedef(span, a1, a2, a3);
     };

/*
 * ImplementsStatement ::= identifier w "implements" w identifier w ";"
 */
private WImplementsStatement ImplementsStatement =
     a1:IdText w implements w a2:IdText w semicolon
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkImplementsStatement(span, a1, a2);
     };

/*
 * Const ::= "const" w ConstType w identifier w "=" w ConstValue w ";"
 * // WebKitIDL
 * Const ::= "const" w ExtendedAttributeList w ConstType w identifier w "=" w ConstValue w ";"
 */
private WConst Const =
     const a1:(w ExtendedAttributeList)? w a2:ConstType w a3:IdText w equals w a4:ConstValue w semicolon
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkConst(span, a2, a3, a4);
       if (a1 != null) yyValue = WIDLFactory.addAttrs(a1, yyValue);
     };

/*
 * ConstValue ::= BooleanLiteral 
 *              | FloatLiteral 
 *              | integer 
 *              | "null"
 */
private WLiteral ConstValue =
     BooleanLiteral 
   / FloatLiteral 
   / a1:integer
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkInteger(span, a1);
     }
   / nullK { yyValue = WIDLFactory.nullL(); };

/*
 * BooleanLiteral ::= "true" | "false"
 */
private WBoolean BooleanLiteral =
     true  { yyValue = WIDLFactory.trueL(); }
   / false { yyValue = WIDLFactory.falseL(); };

/*
 * FloatLiteral ::= float 
 *                | "-" w "Infinity" 
 *                | "Infinity" 
 *                | "NaN"
 */
/*
 * Type unrestricted float, constant value Infinity:
 *   The value is the IEEE 754 single-precision positive infinity value.
 * Type unrestricted double, constant value Infinity:
 *   The value is the IEEE 754 double-precision positive infinity value.
 * Type unrestricted float, constant value -Infinity:
 *   The value is the IEEE 754 single-precision negative infinity value.
 * Type unrestricted double, constant value -Infinity:
 *   The value is the IEEE 754 double-precision negative infinity value.
 * Type unrestricted float, constant value NaN:
 *   The value is the IEEE 754 single-precision NaN value with the bit pattern 0x7fc00000.
 * Type unrestricted double, constant value NaN:
 *   The value is the IEEE 754 double-precision NaN value with the bit pattern 0x7ff8000000000000.
 */
private WFloat FloatLiteral =
     a1:floatL
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkFloat(span, a1);
     }
   / minus w Infinity { yyValue = WIDLFactory.minusInfinity(); }
   / Infinity { yyValue = WIDLFactory.infinity(); }
   / NaN { yyValue = WIDLFactory.nan(); };

/*
 * AttributeOrOperation ::= "stringifier" w StringifierAttributeOrOperation 
 *                        | Attribute 
 *                        | Operation
 * Operation ::= Qualifiers w OperationRest
 * OperationRest ::= ReturnType w OptionalIdentifier w "(" w ArgumentList w ")" w ";"
 * // WebKitIDL
 * OperationRest ::= ReturnType w OptionalIdentifier w "(" w ArgumentList w ")" (w raises w ExceptionList)? w ";"
 * OptionalIdentifier ::= identifier | \epsilon
 * StringifierAttributeOrOperation ::= Attribute 
 *                                   | OperationRest 
 *                                   | ";"
 *
 * If an operation used to declare a stringifier does not have an identifier,
 * then prose accompanying the interface must define the stringification behavior
 * of the interface. If the operation does have an identifier, then the object is
 * converted to a string by invoking the operation to obtain the string.
 *
 * Stringifiers declared with operations must be declared to take zero arguments
 * and return a DOMString.
 *
 * As a shorthand, if the stringifier keyword is declared using an operation with
 * no identifier, then the operation's return type and argument list can be omitted.
 *
 * The stringifier keyword must not be placed on an attribute unless it is declared
 * to be of type DOMString.
 *
 * OperationRest ::= ReturnType w OptionalIdentifier w "(" w ArgumentList w ")" w ";"
 * // WebKitIDL
 * OperationRest ::= ReturnType w OptionalIdentifier w "(" w ArgumentList w ")" (w raises w ExceptionList)? w ";"
 * OptionalIdentifier ::= identifier | \epsilon
 *
 * If an operation has no identifier, then it must be declared to be
 * a special operation using one of the special keywords.
 */
private WInterfaceMember AttributeOrOperation =
     stringifier w a1:Attribute
     { yyValue = WIDLFactory.addStringifier(a1); }
   / stringifier w a1:ReturnType a2:(w id)? w openparen a3:(w ArgumentList)? w closeparen a4:(w raises w ExceptionList)? w semicolon
     { Span span = createSpan(yyStart,yyCount);
       List<WEAttribute> attrs = new ArrayList<WEAttribute>();
       attrs.add(WIDLFactory.eaStringifier());
       List<WQualifier> quals = new ArrayList();
       if (a3 == null) a3 = Collections.<WArgument>emptyList();
       if (a2 == null && a4 == null) yyValue = WIDLFactory.mkOperation(span, attrs, quals, a1, a3);
       else if (a2 == null) yyValue = WIDLFactory.mkOperationExn(span, attrs, quals, a1, a3, a4);
       else if (a4 == null) yyValue = WIDLFactory.mkOperation(span, attrs, quals, a1, a2, a3);
       else yyValue = WIDLFactory.mkOperationExn(span, attrs, quals, a1, a2, a3, a4);
     }
   / stringifier w semicolon
     { Span span = createSpan(yyStart,yyCount);
       List<WEAttribute> attrs = new ArrayList<WEAttribute>();
       attrs.add(WIDLFactory.eaStringifier());
       List<WQualifier> quals = new ArrayList();
       yyValue = WIDLFactory.mkOperation(span, attrs, quals, WIDLFactory.domstringType(),
                                         Collections.<WArgument>emptyList());
     }
   / Attribute 
   / a1:Qualifiers w a2:ReturnType a3:(w id)? w openparen a4:(w ArgumentList)? w closeparen a5:(w raises w ExceptionList)? w semicolon
     { Span span = createSpan(yyStart,yyCount);
       List<WEAttribute> attrs = new ArrayList<WEAttribute>();
       if (a4 == null) a4 = Collections.<WArgument>emptyList();
       if (a3 == null && a5 == null) yyValue = WIDLFactory.mkOperation(span, attrs, a1, a2, a4);
       else if (a3 == null) yyValue = WIDLFactory.mkOperationExn(span, attrs, a1, a2, a4, a5);
       else if (a5 == null) yyValue = WIDLFactory.mkOperation(span, attrs, a1, a2, a3, a4);
       else yyValue = WIDLFactory.mkOperationExn(span, attrs, a1, a2, a3, a4, a5);
     };

/*
 * // WebKitIDL
 * ExceptionList ::= "(" w ScopedName w ScopedNames w ")"
 */
private List<WQId> ExceptionList =
     openparen w a1:ScopedName a2:(w ScopedNames)? w closeparen
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * // WebKitIDL
 * ScopedNames ::= "," w ScopedName w ScopedNames
 *             | \epsilon
 */
private List<WQId> ScopedNames =
     comma w a1:ScopedName a2:(w ScopedNames)?
     { if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * // WebKitIDL
 * ScopedName ::= identifier w ScopedNameParts
 * ScopedNameParts ::= "::" identifier w ScopedNameParts
 *                 | \epsilon
 */
private WQId ScopedName =
     a1:id a2s:(scope id)*
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkQId(span, Useful.cons(a1, a2s.list()));
     };

/*
 * Attribute ::= Inherit w ReadOnly w "attribute" w Type w identifier w ";"
 * // WebKitIDL
 * Attribute ::= Inherit w ReadOnly w "attribute" w ExtendedAttributeList w Type w identifier w AttributeRaises w ";"
 * Inherit ::= "inherit" | \epsilon
 * ReadOnly ::=	"readonly" | \epsilon
 */
private WAttribute Attribute =
     a1:inherit? a2:(w readonly)? w attribute a3:(w ExtendedAttributeList)? w a4:Type w a5:id
     a6:(w AttributeRaises)? w semicolon
     { Span span = createSpan(yyStart,yyCount);
       List<WEAttribute> attrs = new ArrayList<WEAttribute>();
       if (a1 != null && a2 != null) {
           attrs.add(WIDLFactory.eaInherit());
           attrs.add(WIDLFactory.eaReadonly());
       } else if (a1 != null) attrs.add(WIDLFactory.eaInherit());
       else if (a2 != null) attrs.add(WIDLFactory.eaReadonly());
       if (a6 == null) yyValue = WIDLFactory.mkAttribute(span, attrs, a4, a5);
       else yyValue = WIDLFactory.mkAttribute(span, attrs, a4, a5, a6);
     };

/*
 * // WebKitIDL
 * AttributeRaises ::= ("getraises" w ExceptionList)? ("setraises" w ExceptionList)?
 *                   | GetterRaises
 *                   | SetterRaises
 *                   | GetterRaises w "," w SetterRaises
 *                   | SetterRaises w "," w GetterRaises
 * GetterRaises ::= "getter" w "raises" w ExceptionList
 * SetterRaises ::= "setter" w "raises" w ExceptionList
 */
private List<WQId> AttributeRaises =
     getraises w a1:ExceptionList w setraises w a2:ExceptionList
     { yyValue = a1;
       yyValue.addAll(a2);
     }
   / getraises w yyValue:ExceptionList
   / setraises w yyValue:ExceptionList
   / GetterRaises
   / SetterRaises
   / a1:GetterRaises w comma w a2:SetterRaises
     { yyValue = a1;
       yyValue.addAll(a2);
     }
   / a1:SetterRaises w comma w a2:GetterRaises
     { yyValue = a1;
       yyValue.addAll(a2);
     };
private List<WQId> GetterRaises = getter w raises w yyValue:ExceptionList ;
private List<WQId> SetterRaises = setter w raises w yyValue:ExceptionList ;

/*
 * Qualifiers ::= "static" | Specials
 */
private List<WQualifier> Qualifiers =
     static
     { yyValue = Useful.list(WIDLFactory.qStatic()); }
   / a1:Specials?
     { if (a1 == null) yyValue = Collections.<WQualifier>emptyList();
       else yyValue = a1;
     };

/*
 * Specials ::=	Special w Specials | \epsilon
 * A given special keyword must not appear twice on an operation.
 */
private List<WQualifier> Specials =
     a1:Special a2:(w Specials)?
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * Special ::= "getter" | "setter" | "creator" | "deleter" | "legacycaller"
 */
private WQualifier Special =
     getter  { yyValue = WIDLFactory.qGetter(); }
   / setter  { yyValue = WIDLFactory.qSetter(); }
   / creator { yyValue = WIDLFactory.qCreator(); }
   / deleter { yyValue = WIDLFactory.qDeleter(); }
   / legacycaller { yyValue = WIDLFactory.qLegacycaller(); }
   ;

/*
 * ArgumentList ::= Argument w Arguments 
 *                | \epsilon
 * An argument must not be declared with the ... token unless it is the final
 * argument in the operation's argument list.
 */
private List<WArgument> ArgumentList =
     a1:Argument a2:(w Arguments)?
     { if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * Arguments ::= "," w Argument w Arguments 
 *             | \epsilon
 */
private List<WArgument> Arguments =
     comma w a1:Argument a2:(w Arguments)?
     { if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * Argument ::=	ExtendedAttributeList w OptionalOrRequiredArgument
 * // WebKitIDL
 * Argument ::=	ExtendedAttributeList w in w OptionalOrRequiredArgument
 */
private WArgument Argument =
     a1:ExtendedAttributeList? (w in)? w a2:OptionalOrRequiredArgument
     { if (a1 == null) yyValue = a2;
       else yyValue = WIDLFactory.addAttrs(a1, a2);
     };

/*
 * OptionalOrRequiredArgument ::= "optional" w Type w ArgumentName w Default
 *                              | Type w Ellipsis w ArgumentName
 * // WebKitIDL
 * OptionalOrRequiredArgument ::= "optional" w ExtendedAttributeList w Type w ArgumentName w Default
 *                              | ExtendedAttributeList w Type w Ellipsis w ArgumentName
 * Ellipsis ::= "..." | \epsilon
 */
private WArgument OptionalOrRequiredArgument =
     optional a1:(w ExtendedAttributeList)? w a2:Type w a3:ArgumentName a4:(w Default)?
     { Span span = createSpan(yyStart,yyCount);
       List<WEAttribute> attrs = Useful.list(WIDLFactory.eaOptional());
       if (a4 == null) yyValue = WIDLFactory.mkArgument(span, attrs, a2, a3);
       else yyValue = WIDLFactory.mkArgument(span, attrs, a2, a3, a4);
       if (a1 != null) yyValue = WIDLFactory.addAttrs(a1, yyValue);
     }
   / a1:(ExtendedAttributeList w)? a2:Type a3:(w ellipsis)? w a4:ArgumentName
     { Span span = createSpan(yyStart,yyCount);
       if (a3 == null)
         yyValue = WIDLFactory.mkArgument(span, Collections.<WEAttribute>emptyList(), a2, a4);
       else
         yyValue = WIDLFactory.mkArgument(span, Useful.list(WIDLFactory.eaEllipsis()), a2, a4);
       if (a1 != null) yyValue = WIDLFactory.addAttrs(a1, yyValue);
     };

/*
 * ArgumentName ::= ArgumentNameKeyword 
 *                | identifier
 */
private String ArgumentName =
     ArgumentNameKeyword 
   / id
   ;

/*
 * ExceptionMember ::= Const | ExceptionField
 */
private WExceptionMember ExceptionMember =
     Const
   / ExceptionField
   ;

/*
 * ExceptionField ::= Type w identifier w ";"
 */
private WExceptionField ExceptionField =
     a1:Type w a2:IdText w semicolon
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkExceptionField(span, a1, a2);
     };

/*
 * ExtendedAttributeList ::= "[" w ExtendedAttribute w ExtendedAttributes w "]"
 *                         | \epsilon
 */
private List<WEAttribute> ExtendedAttributeList =
     opensquare w a1:ExtendedAttribute a2:(w ExtendedAttributes)? w closesquare
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.concat(a1, a2);
     };

/*
 * ExtendedAttributes ::= "," w ExtendedAttribute w ExtendedAttributes
 *                      | \epsilon
 */
private List<WEAttribute> ExtendedAttributes =
     comma w a1:ExtendedAttribute a2:(w ExtendedAttributes)?
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = a1;
       else yyValue = Useful.concat(a1, a2);
     };

/*
 * ExtendedAttribute ::= "(" w ExtendedAttributeInner w ")" w ExtendedAttributeRest
 *                     | "[" w ExtendedAttributeInner w "]" w ExtendedAttributeRest
 *                     | "{" w ExtendedAttributeInner w "}" w ExtendedAttributeRest
 *                     | Other w ExtendedAttributeRest
 * Extension: "Constructor" w "(" (w ArgumentList)? w ")" w ExtendedAttributeRest
 *          | "Constructor"
 * ExtendedAttributeRest ::= ExtendedAttribute | \epsilon
 */
private List<WEAttribute> ExtendedAttribute =
     a1:ExtendedAttributeFront w a2:ExtendedAttribute
     { yyValue = Useful.concat(a1, a2); }
   / ExtendedAttributeFront
   ;

private List<WEAttribute> ExtendedAttributeFront =
     "Constructor" w openparen a1:(w ArgumentList)? w closeparen
     { if (a1 == null) a1 = Collections.<WArgument>emptyList();
       yyValue = Useful.list(WIDLFactory.mkEAConstructor(a1));
     }
   / "Constructor"
     { yyValue = Useful.list(WIDLFactory.mkEAConstructor(Collections.<WArgument>emptyList())); }
   / openparen a1:(w ExtendedAttributeInner)? w closeparen
     { if (a1 == null) yyValue = Collections.<WEAttribute>emptyList();
       else yyValue = a1;
     }
   / opensquare a1:(w ExtendedAttributeInner)? w closesquare
     { if (a1 == null) yyValue = Collections.<WEAttribute>emptyList();
       else yyValue = a1;
     }
   / opencurly a1:(w ExtendedAttributeInner)? w closecurly
     { if (a1 == null) yyValue = Collections.<WEAttribute>emptyList();
       else yyValue = a1;
     }
   / a1:Other
     { yyValue = Useful.list(a1); };

/*
 * ExtendedAttributeInner ::= "(" w ExtendedAttributeInner w ")" w ExtendedAttributeInner
 *                          | "[" w ExtendedAttributeInner w "]" w ExtendedAttributeInner
 *                          | "{" w ExtendedAttributeInner w "}" w ExtendedAttributeInner
 *                          | OtherOrComma w ExtendedAttributeInner 
 *                          | \epsilon
 * OtherOrComma = Other | ","
 */
private List<WEAttribute> ExtendedAttributeInner =
     openparen a1:(w ExtendedAttributeInner)? w closeparen a2:(w ExtendedAttributeInner)?
     { if (a1 == null && a2 == null) yyValue = Collections.<WEAttribute>emptyList();
       else if (a1 == null) yyValue = a2;
       else if (a2 == null) yyValue = a1;
       else yyValue = Useful.concat(a1, a2);
     }
   / opensquare a1:(w ExtendedAttributeInner)? w closesquare a2:(w ExtendedAttributeInner)?
     { if (a1 == null && a2 == null) yyValue = Collections.<WEAttribute>emptyList();
       else if (a1 == null) yyValue = a2;
       else if (a2 == null) yyValue = a1;
       else yyValue = Useful.concat(a1, a2);
     }
   / opencurly a1:(w ExtendedAttributeInner)? w closecurly a2:(w ExtendedAttributeInner)?
     { if (a1 == null && a2 == null) yyValue = Collections.<WEAttribute>emptyList();
       else if (a1 == null) yyValue = a2;
       else if (a2 == null) yyValue = a1;
       else yyValue = Useful.concat(a1, a2);
     }
   / a1:Other a2:(w ExtendedAttributeInner)?
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     }
   / comma a1:(w ExtendedAttributeInner)?
     { Span span = createSpan(yyStart,yyCount);
       if (a1 != null) yyValue = Useful.list(a1);
       else yyValue = Collections.<WEAttribute>emptyList();
     };

/*
 * Other ::= integer | float | identifier | string | other
 *         | "-" | "." | "..." | ":" | ";" | "<" | "=" | ">" | "?" 
 *         | "Date" | "DOMString" | "Infinity" | "NaN"
 *         | "any" | "boolean" | "byte" | "double" | "false" | "float"
 *         | "long" | "null" | "object" | "octet" | "or" | "optional"
 *         | "sequence" | "short" | "true" | "unsigned" | "void" 
 *         | ArgumentNameKeyword
 *         | "[" w "]" | in // WebKitIDL
 * Extension: "NoInterfaceObject" | "Callback" w "=" w "FunctionOnly"
 */
private WEAttribute Other =
     opensquare w closesquare
     { yyValue = WIDLFactory.eaArray(); }
   / "NoInterfaceObject"
     { yyValue = eaNoInterfaceObject; }
   / "Callback" w equals w "FunctionOnly"
     { yyValue = eaCallbackFunctionOnly; }
   / a1:(integer / floatL / minus / dot / colon / semicolon / "<" / equals / ">" /
         Date / DOMString / Infinity / NaN / any / boolean / byte / double / false /
         floatK / long / nullK / object / octet / or / sequence / short / true /
         unsigned / voidK)
     { yyValue = WIDLFactory.mkEAString(a1); }
   / a1:string
     { yyValue = WIDLFactory.mkEAString(a1.getStr()); }
   / question
     { yyValue = WIDLFactory.eaQuestion(); }
   / ellipsis
     { yyValue = WIDLFactory.eaEllipsis(); }
   / optional
     { yyValue = WIDLFactory.eaOptional(); }
   / a1:ArgumentNameKeyword
     { yyValue = WIDLFactory.mkEAArgumentNameKeyword(a1); }
   / a1:id
     { yyValue = WIDLFactory.mkEAString(a1); }
   / a1:other
     { yyValue = WIDLFactory.mkEAString(a1); };

/*
 * ArgumentNameKeyword ::= "attribute" | "callback" | "const" | "creator"
 *                       | "deleter" | "dictionary" | "enum" | "exception"
 *                       | "getter" | "implements" | "inherit" | "interface"
 *                       | "legacycaller" | "partial" | "setter" | "static" 
 *                       | "stringifier" | "typedef" | "unrestricted"
 */
private String ArgumentNameKeyword =
     attribute
   / callback
   / const
   / creator
   / deleter
   / dictionary
   / enum
   / exception
   / getter
   / implements
   / inherit
   / interface
   / legacycaller
   / partial
   / setter
   / static
   / stringifier
   / typedef
   / unrestricted
   ;

/*
 * Type ::= SingleType
 *        | UnionType w TypeSuffix
 */
private WType Type =
     SingleType
   / UnionType
   ;

/*
 * SingleType ::= NonAnyType
 *              | "any" w TypeSuffixStartingWithArray
 * TypeSuffixStartingWithArray ::= "[" w "]" w TypeSuffix | \epsilon
 */
private WType SingleType =
     NonAnyType
   / any w opensquare w closesquare a1:(w TypeSuffix)?
     { Span span = createSpan(yyStart,yyCount);
       if (a1 == null) yyValue = WIDLFactory.anyArrayType();
       else yyValue = WIDLFactory.mkAnyArrayType(span, a1);
     }
   / any { yyValue = WIDLFactory.anyType(); };

/*
 * UnionType ::= "(" w UnionMemberType w "or" w UnionMemberType w UnionMemberTypes w ")"
 */
private WUnionType UnionType =
     openparen w a1:UnionMemberType w or w a2:UnionMemberType a3:(w UnionMemberTypes)? w closeparen a4:(w TypeSuffix)?
     { Span span = createSpan(yyStart,yyCount);
       List<WType> types = new ArrayList<WType>();
       if (a3 == null) types = Useful.list(a1, a2);
       else types = Useful.concat(Useful.list(a1, a2), a3);
       if (a4 == null) yyValue = WIDLFactory.mkUnionType(span, types);
       else yyValue = WIDLFactory.mkUnionType(span, types, a4);
     };

/*
 * UnionMemberType ::= NonAnyType
 *                   | UnionType w TypeSuffix
 *                   | "any" w "[" w "]" w TypeSuffix
 */
private WType UnionMemberType =
     NonAnyType
   / UnionType
   / any w opensquare w closesquare a1:(w TypeSuffix)?
     { Span span = createSpan(yyStart,yyCount);
       if (a1 == null) yyValue = WIDLFactory.anyArrayType();
       else yyValue = WIDLFactory.mkAnyArrayType(span, a1);
     };

/*
 * UnionMemberTypes ::= "or" w UnionMemberType w UnionMemberTypes
 *                    | \epsilon
 */
private List<WType> UnionMemberTypes =
     or w a1:UnionMemberType a2:(w UnionMemberTypes)?
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = Useful.list(a1);
       else yyValue = Useful.list(a1, a2);
     };

/*
 * NonAnyType ::= PrimitiveType w TypeSuffix
 *              | DOMString w TypeSuffix
 *              | identifier w TypeSuffix
 *              | sequence w "<" w Type w ">" w Null
 *              | "object" w TypeSuffix
 *              | "Date" w TypeSuffix
 * Null ::= "?" | \epsilon
 */
private WType NonAnyType =
     a1:PrimitiveType a2:(w TypeSuffix)?
     { if (a2 == null) yyValue = a1;
       else yyValue = WIDLFactory.addTypeSuffix(a1, a2);
     }
   / DOMString a1:(w TypeSuffix)?
     { if (a1 == null) yyValue = WIDLFactory.domstringType();
       else yyValue = WIDLFactory.addTypeSuffix(WIDLFactory.domstringType(), a1);
     }
   / a1:IdText a2:(w TypeSuffix)?
     { Span span = createSpan(yyStart,yyCount);
       if (a2 == null) yyValue = WIDLFactory.mkNamedType(span, a1);
       else yyValue = WIDLFactory.mkNamedType(span, a1, a2);
     }
   / sequence w "<" w a1:Type w ">" a2:(w question)?
     { Span span = createSpan(yyStart,yyCount);
       List<WTypeSuffix> suffix = new ArrayList<WTypeSuffix>();
       if (a2 == null) yyValue = WIDLFactory.mkSequenceType(span, a1, suffix);
       else {
         suffix.add(WIDLFactory.tsQuestion());
         yyValue = WIDLFactory.mkSequenceType(span, a1, suffix);
       }
     }
   / object a1:(w TypeSuffix)?
     { if (a1 == null) yyValue = WIDLFactory.objectType();
       else yyValue = WIDLFactory.addTypeSuffix(WIDLFactory.objectType(), a1);
     }
   / Date a1:(w TypeSuffix)?
     { if (a1 == null) yyValue = WIDLFactory.dateType();
       else yyValue = WIDLFactory.addTypeSuffix(WIDLFactory.dateType(), a1);
     };

/*
 * ConstType ::= PrimitiveType w Null
 *             | identifier w Null
 * Null ::= "?" | \epsilon
 */
private WType ConstType =
     a1:PrimitiveType w question
     { yyValue = WIDLFactory.questionType(a1); }
   / PrimitiveType
   / a1:IdText w question
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkNamedType(span, a1, WIDLFactory.tsQuestion());
     }
   / a1:IdText
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkNamedType(span, a1);
     };

/*
 * PrimitiveType ::= UnsignedIntegerType 
 *                 | UnrestrictedFloatType 
 *                 | "boolean" 
 *                 | "byte" 
 *                 | "octet"
 */
private WType PrimitiveType =
     UnsignedIntegerType
   / UnrestrictedFloatType
   / boolean
     { yyValue = WIDLFactory.booleanType(); }
   / byte
     { yyValue = WIDLFactory.byteType(); }
   / octet
     { yyValue = WIDLFactory.octetType(); };

/*
 * UnrestrictedFloatType ::= "unrestricted" w FloatType
 *                         | FloatType
 */
private WType UnrestrictedFloatType =
     unrestricted w a1:FloatType
     { yyValue = WIDLFactory.unrestricted(a1); }
   / FloatType
   ;

/*
 * FloatType ::= "float" | "double"
 */
private WType FloatType =
     floatK
     { yyValue = WIDLFactory.floatType(); }
   / double
     { yyValue = WIDLFactory.doubleType(); };

/*
 * UnsignedIntegerType ::= "unsigned" w IntegerType 
 *                       | IntegerType
 */
private WType UnsignedIntegerType =
     unsigned w a1:IntegerType 
     { yyValue = WIDLFactory.unsinged(a1); }
   / IntegerType
   ;

/*
 * IntegerType ::= "short"
 *               | "long" w OptionalLong
 * OptionalLong ::= "long" | \epsilon
 */
private WType IntegerType =
     short
     { yyValue = WIDLFactory.shortType(); }
   / long w long
     { yyValue = WIDLFactory.longLongType(); }
   / long
     { yyValue = WIDLFactory.longType(); };

/*
 * TypeSuffix ::= "[" w "]" w TypeSuffix
 *              | "?" w TypeSuffixStartingWithArray?
 *              | \epsilon
 * TypeSuffixStartingWithArray ::= "[" w "]" w TypeSuffix | \epsilon
 */
private List<WTypeSuffix> TypeSuffix =
     opensquare w closesquare w a1:TypeSuffix
     { yyValue = Useful.list(WIDLFactory.tsArray(), a1); }
   / opensquare w closesquare
     { yyValue = Useful.list(WIDLFactory.tsArray()); }
   / question w opensquare w closesquare w a1:TypeSuffix
     { yyValue = Useful.concat(Useful.list(WIDLFactory.tsQuestion(), WIDLFactory.tsArray()),
                              a1);
     }
   / question w opensquare w closesquare
     { yyValue = Useful.list(WIDLFactory.tsQuestion(), WIDLFactory.tsArray()); }
   / question
     { yyValue = Useful.list(WIDLFactory.tsQuestion()); }
   ;

/*
 * ReturnType ::= Type | "void"
 */
private WType ReturnType =
     Type
   / voidK { yyValue = WIDLFactory.voidType(); };

/*
 * ExtendedAttributeNoArgs ::= identifier
 * Never used in the WIDL grammar.
private String ExtendedAttributeNoArgs = IdText ;
 */

/*
 * ExtendedAttributeArgList ::= identifier w "(" w ArgumentList w ")"
 * Never used in the WIDL grammar.
private List<ExtendedAttributeArg> ExtendedAttributeArgList =
a1:IdText w openparen w a2:ArgumentList? w closeparen ;
 */

/*
 * ExtendedAttributeIdent ::= identifier w "=" w identifier
 * Never used in the WIDL grammar.
private ExtendedAttributeIdent ExtendedAttributeIdent =
a1:IdText w equals w a2:IdText ;
 */

/*
 * ExtendedAttributeNamedArgList ::= identifier w "=" w identifier w "(" w ArgumentList w ")"
 * Never used in the WIDL grammar.
private List<ExtendedAttributeArg> ExtendedAttributeNamedArgList =
a1:IdText w equals w a2:IdText w openparen w a3:ArgumentList? w closeparen ;
 */

/*
 * identifier = [A-Z_a-z][0-9A-Z_a-z]*
 *
 * Any single leading U+005F LOW LINE ("_") character (underscore) is removed.
 * A leading "_" is used to escape an identifier from looking like a reserved word
 * so that, for example, an interface named "interface" can be defined. The leading
 * "_" is dropped to unescape the identifier.
 */
transient String id      = s:(idstart idrest*) &{ !JAVASCRIPT_RESERVED.contains(s) &&
                                                  !s.startsWith("__") };
transient String idname  = s:(idstart idrest*);
transient String idstart = [a-z_A-Z] ;
transient String idrest  = idstart / [0-9];
private String IdText =
     a1:id
     { yyValue = NodeUtil.dropAnySingleLeadingUnderscore(a1); };
private WId Id = a1:id
     { Span span = createSpan(yyStart,yyCount);
       yyValue = WIDLFactory.mkId(span, a1);
     };

/*
 * integer ::= -?(0([0-7]*|[Xx][0-9A-Fa-f]+)|[1-9][0-9]*)
 */
transient String integer =
     a1:minus? "0" [Xx] a2:HexaDigits
     { String sign = "";
       if (a1 != null) sign = "-";
       yyValue = sign+"0x"+a2;
     }
   / a1:minus? "0" a2:OctalDigits?
     { String sign = "";
       if (a1 != null) sign = "-";
       if (a2 == null) yyValue = sign+"0";
       else yyValue = sign+"0"+a2;
     }
   / a1:minus? a2:[1-9] a3:DecimalDigits?
     { String sign = "";
       if (a1 != null) sign = "-";
       if (a3 == null) yyValue = sign+a2;
       else yyValue = sign+a2+a3;
     };

/*
 * float ::= -?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)
 */
transient String floatL =
     a1:minus? a2:floatfront a3:floatback
     { String sign = "";
       if (a1 != null) sign = "-";
       yyValue = sign+a2+a3;
     }
   / a1:minus? a2:floatfront
     { String sign = "";
       if (a1 != null) sign = "-";
       yyValue = sign+a2;
     }
   / a1:minus? a2:DecimalDigits a3:floatback
     { String sign = "";
       if (a1 != null) sign = "-";
       yyValue = sign+a2+a3;
     };
transient String floatfront =
     a1:DecimalDigits dot a2:DecimalDigits?
     { if (a2 == null) yyValue = a1;
       else yyValue = a1+"."+a2;
     }
   / a1:DecimalDigits? dot a2:DecimalDigits
     { if (a1 == null) yyValue = "0."+a2;
       else yyValue = a1+"."+a2;
     };
transient String floatback =
     [Ee] a1:("+"/"-")? a2:DecimalDigits
     { if (a1 == null) yyValue = "e"+a2;
       else            yyValue = "e"+a1+a2;
     };
private transient String DecimalDigits = [0-9]+ ;
private transient String HexaDigits = [0-9A-Fa-f]+ ;
private transient String OctalDigits = [0-7]+ ;

/*
 * string = "[^"]*"
 */
transient WString string =
     ["] a1s:StringChar* ["]
     { String str = "";
       for (String c : (List<String>)a1s.list()) str = str.concat(c);
       yyValue = WIDLFactory.mkString(createSpan(yyStart,yyCount+1), str);
     };
transient String StringChar =
     a1:(!["] _) { yyValue = a1+""; }; // " ;

/*
 * other = [^\t\n\r 0-9A-Z_a-z]
 */
transient String other =
     (!NotOther _) ;
transient String NotOther =
        [\t\n\r0-9A-Z_a-z] / ")" / "]" / "}" ;

transient void Comment =
     MultiLineComment
   / SingleLineComment ;

transient void MultiLineComment =
     "/*" a1s:MultiLineCommentChar* "*/"
     { StringBuilder buf = new StringBuilder();
       buf.append("/*");
       for (String s : a1s.list()) buf.append(s);
       buf.append("*/");
     };

transient private String MultiLineCommentChar =
     !("*/") a1:_ { yyValue = a1+""; } ;

transient String MultiLineCommentWLB =
     "/*" a1s:MultiLineCommentCharNoLB* a2:LineTerminator a3s:MultiLineCommentCharWLB* "*/"
     { StringBuilder buf = new StringBuilder();
       buf.append("/*");
       for (String s : a1s.list()) buf.append(s);
       buf.append(a2);
       for (String s : a3s.list()) buf.append(s);
       buf.append("*/");
       yyValue = buf.toString();
     };

transient private String MultiLineCommentCharWLB =
     !("*/") _ ;

transient String MultiLineCommentNoLB =
     "/*" a1s:MultiLineCommentCharNoLB* "*/"
     { StringBuilder buf = new StringBuilder();
       buf.append("/*");
       for (String s : a1s.list()) buf.append(s);
       buf.append("*/");
       yyValue = buf.toString();
     };

transient private String MultiLineCommentCharNoLB =
     !("*/" / LineTerminator) a1:_ { yyValue = a1+""; } ;

transient void SingleLineComment =
     "//" a1s:SingleLineCommentChar*
     { StringBuilder buf = new StringBuilder();
       buf.append("/*");
       for (String s : a1s.list()) buf.append(s);
       buf.append("*/");
     };

transient private String SingleLineCommentChar =
     !(LineTerminator) a1:_ { yyValue = a1+""; } ;

/* If a MultiLineComment contains one or more line terminators,
 * then it is replaced by a single line terminator */
/* LineTerminator ::= <LF> | <CR> | <LS> | <PS> */
transient String LineTerminator =
     a1:([\u000a] / [\u000d] / [\u2028] / [\u2029])
     { yyValue = ""+a1; }
   / MultiLineCommentWLB ;

transient String LineTerminatorNoMC =
     a1:([\u000a] / [\u000d] / [\u2028] / [\u2029])
     { yyValue = ""+a1; };

/* LineTerminatorSequence ::=
     <LF> | <CR>[lookahead \not\in <LF>] | <LS> | <PS> | <CR><LF>
 */
transient String LineTerminatorSequence =
     a1:([\u000a] / [\u2028] / [\u2029])
     { yyValue = ""+a1; }
   / a1:[\u000d] a2:[\u000a]
     { yyValue = ""+a1+a2; }
   / a1:[\u000d] !([\u000a])
     { yyValue = ""+a1; }
   / MultiLineCommentWLB
   ;

/* WhiteSpace ::= <TAB> | <VT> | <FF> | <SP> | <NBSP> | <BOM> | <USP> */
transient private void Space =
     void:"\t"
   / [\u000B]
   / void:"\f"
   / void:" "
   / [\u00A0]
   / [\uFEFF]
   / SingleLineComment
   / MultiLineCommentNoLB ;

transient private void Whitespace =
     Space
   / void:LineTerminatorSequence
   / MultiLineComment ;

transient void w  = Whitespace*; // whitespace optional
transient void wr = Whitespace+; // whitespace required

transient void s  = Space*;      // space optional
transient void sr = Space+;      // space required

transient void EndOfFile  = "\u001a"? w !_ ;

transient void openparen = "(";
transient void closeparen = ")";
transient void opencurly = "{";
transient void closecurly = "}";
transient void opensquare = "[";
transient void closesquare = "]";
transient void scope = "::";
transient String semicolon = ";";
transient String colon = ":" !(":");
transient String equals = "=" !("=");
transient String comma = ",";
transient String minus = "-" !("-" / "=");
transient String ellipsis = "...";
transient String dot   = "." !(".");
transient String question = "?";

transient String DOMString = "DOMString" !(idrest);
transient String Date = "Date" !(idrest);
transient String Infinity = "Infinity" !(idrest);
transient String NaN= "NaN" !(idrest);
transient String any = "any" !(idrest);
transient String boolean = "boolean" !(idrest);
transient String byte = "byte" !(idrest);
transient String double = "double" !(idrest);
transient String false = "false" !(idrest);
transient String floatK = "float" !(idrest);
transient String long = "long" !(idrest);
transient String nullK = "null" !(idrest);
transient String object = "object" !(idrest);
transient String octet = "octet" !(idrest);
transient String optional = "optional" !(idrest);
transient String or = "or" !(idrest);
transient String readonly = "readonly" !(idrest);
transient String sequence = "sequence" !(idrest);
transient String short = "short" !(idrest);
transient String true = "true" !(idrest);
transient String unsigned = "unsigned" !(idrest);
transient String voidK = "void" !(idrest);

transient String attribute = "attribute" !(idrest);
transient String callback = "callback" !(idrest);
transient String const = "const" !(idrest);
transient String creator = "creator" !(idrest);
transient String deleter = "deleter" !(idrest);
transient String dictionary = "dictionary" !(idrest);
transient String enum = "enum" !(idrest);
transient String exception = "exception" !(idrest);
transient String getter = "getter" !(idrest);
transient String implements = "implements" !(idrest);
transient String inherit = "inherit" !(idrest);
transient String interface = "interface" !(idrest);
transient String legacycaller = "legacycaller" !(idrest);
transient String partial = "partial" !(idrest);
transient String setter = "setter" !(idrest);
transient String static = "static" !(idrest);
transient String stringifier = "stringifier" !(idrest);
transient String typedef = "typedef" !(idrest);
transient String unrestricted = "unrestricted" !(idrest);

transient void epsilon = "epsilon";

// WebKit IDL
transient void module = "module" !(idrest);
transient void in = "in" !(idrest);
transient void raises = "raises" !(idrest);
transient void getraises = "getraises" !(idrest);
transient void setraises = "setraises" !(idrest);

// WebKit IDL (possible future extension)
/*
# Used in WebKitIDL Conditional attribute
literals += '&|'
# Used in WebKitIDL InterfaceUUID/ImplementationUUID attribute
literals += '-'
   'Other : ... | in'
 */
