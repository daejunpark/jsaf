/*******************************************************************************
    Copyright (c) 2012-2013, KAIST, S-Core.
    All rights reserved.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.
 ******************************************************************************/

/*
 * A.3 Expressions
 * Definition of JavaScript expressions
 */
module kr.ac.kaist.jsaf.parser.ExpressionNoIn(Declaration, Expression, Literal,
                                              Symbol, Identifier, Keyword, Spacing);

import Declaration;
import Expression;
import Literal;
import Symbol;
import Identifier;
import Keyword;
import Spacing;

/*
 * ExpressionNoIn ::= AssignmentNoIn (w , w AssignmentNoIn)*
 */
public Expr ExpressionNoIn =
     a1:AssignmentNoIn a2s:(w void:comma w AssignmentNoIn)*
     { if (a2s.list().isEmpty()) yyValue = a1;
       else yyValue = NodeFactory.makeExprList(createSpan(yyStart,yyCount),
                                               Useful.cons(a1, a2s.list()));
     };

/*
 * AssignmentNoIn ::=
 *   ConditionalNoIn
 * | LeftHandSide w = w AssignmentNoIn
 * | LeftHandSide w AssignmentOp w AssignmentNoIn
 */
Expr AssignmentNoIn =
     a1:LeftHandSide w equals w a2:AssignmentNoIn
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeAssignOpApp(span, a1,
                                             NodeFactory.makeOp(span, "="),
                                             a2);
     }
   / a1:LeftHandSide w a2:AssignmentOp w a3:AssignmentNoIn
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeAssignOpApp(span, a1, a2, a3);
     }
   / ConditionalNoIn;

/*
 * ConditionalNoIn ::=
 *   LogicalORNoIn
 * | LogicalORNoIn w ? w Assignment w : w AssignmentNoIn
 */
private transient Expr ConditionalNoIn =
     a1:LogicalORNoIn w question w a2:Assignment w colon w a3:AssignmentNoIn
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeCond(span, a1, a2, a3);
     }
   / LogicalORNoIn ;

/*
 * LogicalORNoIn ::=
 *   LogicalANDNoIn
 * | LogicalORNoIn w || w LogicalANDNoIn
 */
private transient Expr LogicalORNoIn =
     a1:LogicalANDNoIn a2s:(w bars w LogicalANDNoIn)*
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOp(span, "||");
       List<Expr> es = Useful.cons(a1, a2s.list());
       Collections.reverse(es);
       yyValue = es.remove(0);
       for (Expr e: es) yyValue = NodeFactory.makeInfixOpApp(span, e, op, yyValue);
     };

/*
 * LogicalANDNoIn ::=
 *   BitwiseORNoIn
 * | LogicalANDNoIn w && w BitwiseORNoIn
 */
private transient Expr LogicalANDNoIn =
     a1:BitwiseORNoIn a2s:(w ands w BitwiseORNoIn)*
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOp(span, "&&");
       List<Expr> es = Useful.cons(a1, a2s.list());
       Collections.reverse(es);
       yyValue = es.remove(0);
       for (Expr e: es) yyValue = NodeFactory.makeInfixOpApp(span, e, op, yyValue);
     };

/*
 * BitwiseORNoIn ::=
 *   BitwiseXORNoIn
 * | BitwiseORNoIn w | w BitwiseXORNoIn
 */
private transient Expr BitwiseORNoIn =
     a1:BitwiseXORNoIn a2s:(w bar w BitwiseXORNoIn)*
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOp(span, "|");
       List<Expr> es = Useful.cons(a1, a2s.list());
       Collections.reverse(es);
       yyValue = es.remove(0);
       for (Expr e: es) yyValue = NodeFactory.makeInfixOpApp(span, e, op, yyValue);
     };

/*
 * BitwiseXORNoIn ::=
 *   BitwiseANDNoIn
 * | BitwiseXORNoIn w ^ w BitwiseANDNoIn
 */
private transient Expr BitwiseXORNoIn =
     a1:BitwiseANDNoIn a2s:(w caret w BitwiseANDNoIn)*
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOp(span, "^");
       List<Expr> es = Useful.cons(a1, a2s.list());
       Collections.reverse(es);
       yyValue = es.remove(0);
       for (Expr e: es) yyValue = NodeFactory.makeInfixOpApp(span, e, op, yyValue);
     };

/*
 * BitwiseANDNoIn ::=
 *   EqualityNoIn
 * | BitwiseANDNoIn w & w EqualityNoIn
 */
private transient Expr BitwiseANDNoIn =
     a1:EqualityNoIn a2s:(w and w EqualityNoIn)*
     { Span span = createSpan(yyStart,yyCount);
       Op op = NodeFactory.makeOp(span, "&");
       List<Expr> es = Useful.cons(a1, a2s.list());
       Collections.reverse(es);
       yyValue = es.remove(0);
       for (Expr e: es) yyValue = NodeFactory.makeInfixOpApp(span, e, op, yyValue);
     };

/*
 * EqualityNoIn ::=
 *   RelationalNoIn
 * | EqualityNoIn w == w RelationalNoIn
 * | EqualityNoIn w != w RelationalNoIn
 * | EqualityNoIn w === w RelationalNoIn
 * | EqualityNoIn w !== w RelationalNoIn
 */
private transient Expr EqualityNoIn =
     a1s:RelationalLNoIn+ a2:RelationalNoIn
     { Span span = createSpan(yyStart,yyCount);
       yyValue = a2;
       List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       Collections.reverse(ps);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps)
           yyValue = NodeFactory.makeInfixOpApp(span, pair.getA(), pair.getB(), yyValue);
     }
   / RelationalNoIn ;

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> RelationalLNoIn =
     a1:RelationalNoIn w a2:EqualityOp w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };

/*
 * RelationalNoIn ::=
 *   Shift
 * | RelationalNoIn w < w Shift
 * | RelationalNoIn w > w Shift
 * | RelationalNoIn w <= w Shift
 * | RelationalNoIn w >= w Shift
 * | RelationalNoIn w instanceof w Shift
 */
private transient Expr RelationalNoIn =
     a1s:ShiftLNoIn* a2:Shift
     { Span span = createSpan(yyStart,yyCount);
       yyValue = a2;
       List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       Collections.reverse(ps);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps)
           yyValue = NodeFactory.makeInfixOpApp(span, pair.getA(), pair.getB(), yyValue);
     };

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> ShiftLNoIn =
     a1:Shift w a2:RelationalOpNoIn w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };
