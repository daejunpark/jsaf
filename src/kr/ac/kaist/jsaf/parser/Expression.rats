/*******************************************************************************
    Copyright (c) 2012-2013, KAIST, S-Core.
    All rights reserved.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.
 ******************************************************************************/

/*
 * A.3 Expressions
 * Definition of JavaScript expressions
 */
module kr.ac.kaist.jsaf.parser.Expression(Declaration, ExpressionNoIn, Literal,
                                          Symbol, Identifier, Keyword, Spacing);

import Declaration;
import ExpressionNoIn;
import Literal;
import Symbol;
import Identifier;
import Keyword;
import Spacing;

/*
 * Expression ::= Assignment (w , w Assignment)*
 */
public Expr Expression =
     a1:Assignment a2s:(w void:comma w Assignment)*
     { if (a2s.list().isEmpty()) yyValue = a1;
       else yyValue = NodeFactory.makeExprList(createSpan(yyStart,yyCount),
                                               Useful.cons(a1, a2s.list()));
     };

/*
 * Assignment ::=
 *   Conditional
 * | LeftHandSide w = w Assignment
 * | LeftHandSide w AssignmentOp w Assignment
 */
Expr Assignment =
     a1:LeftHandSide w equals w a2:Assignment
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeAssignOpApp(span, a1,
                                             NodeFactory.makeOp(span, "="),
                                             a2);
     }
   / a1:LeftHandSide w a2:AssignmentOp w a3:Assignment
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeAssignOpApp(span, a1, a2, a3);
     }
   / Conditional;

/*
 * Conditional ::=
 *   LogicalOR
 * | LogicalOR w ? w Assignment w : w Assignment
 */
private transient Expr Conditional =
     a1:LogicalOR w question w a2:Assignment w colon w a3:Assignment
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeCond(span, a1, a2, a3);
     }
   / LogicalOR ;

/*
 * LogicalOR ::=
 *   LogicalAND
 * | LogicalOR w || w LogicalAND
 */
private transient Expr LogicalOR =
     a1:LogicalAND a2s:(w bars w LogicalAND)*
     { Span span = NodeUtil.getSpan(a1);
       Op op = NodeFactory.makeOp(span, "||");
       yyValue = a1;
       for (Expr e: a2s.list())
           yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                                yyValue, op, e);
     };

/*
 * LogicalAND ::=
 *   BitwiseOR
 * | LogicalAND w && w BitwiseOR
 */
private transient Expr LogicalAND =
     a1:BitwiseOR a2s:(w ands w BitwiseOR)*
     { Span span = NodeUtil.getSpan(a1);
       Op op = NodeFactory.makeOp(span, "&&");
       yyValue = a1;
       for (Expr e: a2s.list())
           yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                                yyValue, op, e);
     };

/*
 * BitwiseOR ::=
 *   BitwiseXOR
 * | BitwiseOR w | w BitwiseXOR
 */
private transient Expr BitwiseOR =
     a1:BitwiseXOR a2s:(w bar w BitwiseXOR)*
     { Span span = NodeUtil.getSpan(a1);
       Op op = NodeFactory.makeOp(span, "|");
       yyValue = a1;
       for (Expr e: a2s.list())
           yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                                yyValue, op, e);
     };

/*
 * BitwiseXOR ::=
 *   BitwiseAND
 * | BitwiseXOR w ^ w BitwiseAND
 */
private transient Expr BitwiseXOR =
     a1:BitwiseAND a2s:(w caret w BitwiseAND)*
     { Span span = NodeUtil.getSpan(a1);
       Op op = NodeFactory.makeOp(span, "^");
       yyValue = a1;
       for (Expr e: a2s.list())
           yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                                yyValue, op, e);
     };

/*
 * BitwiseAND ::=
 *   Equality
 * | BitwiseAND w & w Equality
 */
private transient Expr BitwiseAND =
     a1:Equality a2s:(w and w Equality)*
     { Span span = NodeUtil.getSpan(a1);
       Op op = NodeFactory.makeOp(span, "&");
       yyValue = a1;
       for (Expr e: a2s.list())
           yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                                yyValue, op, e);
     };

/*
 * Equality ::=
 *   Relational
 * | Equality w == w Relational
 * | Equality w != w Relational
 * | Equality w === w Relational
 * | Equality w !== w Relational
 */
private transient Expr Equality =
     a1:Relational a2s:RelationalR*
     { Span span = NodeUtil.getSpan(a1);
       yyValue = a1;
       for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
           Op op = pair.getA();
           Expr right = pair.getB();
           yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
                                                yyValue, op, right);
       }
     };

private transient kr.ac.kaist.jsaf.useful.Pair<Op, Expr> RelationalR =
     w a1:EqualityOp w a2:Relational
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2); };

/*
private transient Expr Equality =
     a1s:RelationalL+ a2:Relational
     { List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
       Expr left = first.getA();
       Op op = first.getB();
System.out.println("left="+NodeUtil.getSpan(left)+" "+JSAstToConcrete.doit(left));
System.out.println("op="+NodeUtil.getSpan(op)+" "+JSAstToConcrete.doit(op)+"\n");
       Span span = NodeUtil.getSpan(left);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
           Expr e = pair.getA();
System.out.println("l="+NodeUtil.getSpan(left)+" "+JSAstToConcrete.doit(left));
System.out.println("r="+NodeUtil.getSpan(e)+" "+JSAstToConcrete.doit(e)+"\n");
           left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                             left, op, e);
           op = pair.getB();
       }
       yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);
     }
   / Relational ;

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> RelationalL =
     a1:Relational w a2:EqualityOp w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };
*/

/*
 * Relational ::=
 *   Shift
 * | Relational w < w Shift
 * | Relational w > w Shift
 * | Relational w <= w Shift
 * | Relational w >= w Shift
 * | Relational w instanceof w Shift
 * | Relational w in w Shift
 */
private transient Expr Relational =
     a1s:ShiftL+ a2:Shift
     { List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
       Expr left = first.getA();
       Op op = first.getB();
       Span span = NodeUtil.getSpan(left);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
           Expr e = pair.getA();
           left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                             left, op, e);
           op = pair.getB();
       }
       yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);
     }
   / Shift ;

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> ShiftL =
     a1:Shift w a2:RelationalOp w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };

/*
 * Shift ::=
 *   Additive
 * | Shift w << w Additive
 * | Shift w >> w Additive
 * | Shift w >>> w Additive
 */
transient Expr Shift =
     a1s:AdditiveL+ a2:Additive
     { List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
       Expr left = first.getA();
       Op op = first.getB();
       Span span = NodeUtil.getSpan(left);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
           Expr e = pair.getA();
           left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                             left, op, e);
           op = pair.getB();
       }
       yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);
     }
   / Additive ;

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> AdditiveL =
     a1:Additive w a2:ShiftOp w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };

/*
 * Additive ::=
 *   Multiplicative
 * | Additive w + w Multiplicative
 * | Additive w - w Multiplicative
 */
private transient Expr Additive =
     a1s:MultiplicativeL+ a2:Multiplicative
     { List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
       Expr left = first.getA();
       Op op = first.getB();
       Span span = NodeUtil.getSpan(left);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
           Expr e = pair.getA();
           left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                             left, op, e);
           op = pair.getB();
       }
       yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);
     }
   / Multiplicative ;

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> MultiplicativeL =
     a1:Multiplicative w a2:AdditiveOp w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };

/*
 * Multiplicative ::=
 *   Unary
 * | Multiplicative w * w Unary
 * | Multiplicative w / w Unary
 * | Multiplicative w % w Unary
 */
private transient Expr Multiplicative =
     a1s:UnaryL+ a2:Unary
     { List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
       kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
       Expr left = first.getA();
       Op op = first.getB();
       Span span = NodeUtil.getSpan(left);
       for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
           Expr e = pair.getA();
           left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
                                             left, op, e);
           op = pair.getB();
       }
       yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);
     }
   / Unary ;

private transient kr.ac.kaist.jsaf.useful.Pair<Expr, Op> UnaryL =
     a1:Unary w a2:MultiplicativeOp w
     { yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2); };

/*
 * Unary ::=
 *   Postfix
 * | delete Unary
 * | void Unary
 * | typeof Unary
 * | ++ Unary
 * | -­ Unary
 * | + Unary
 * | ­ Unary
 * | ~ Unary
 * | ! Unary
 */
private transient Expr Unary =
     delete w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "delete"), a1);
     }
   / void w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "void"), a1);
     }
   / typeof w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "typeof"), a1);
     }
   / doubleplus w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "++"), a1);
     }
   / doubleminus w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "--"), a1);
     }
   / plus w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "+"), a1);
     }
   / minus w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "-"), a1);
     }
   / tilde w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "~"), a1);
     }
   / bang w a1:Unary
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePrefixOpApp(span, NodeFactory.makeOp(span, "!"), a1);
     }
   / Postfix;

/*
 * Postfix ::=
 *   LeftHandSide
 * | LeftHandSide s ++
 * | LeftHandSide s --
 */
private transient Expr Postfix =
     a1:LeftHandSide s doubleplus
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeUnaryAssignOpApp(span, a1, NodeFactory.makeOp(span, "++"));
     }
   / a1:LeftHandSide s doubleminus
     { Span span = createSpan(yyStart,yyCount);
         yyValue = NodeFactory.makeUnaryAssignOpApp(span, a1, NodeFactory.makeOp(span, "--"));
     }
   / LeftHandSide;

/*
 * LeftHandSide ::=
 *   NewExpr
 * | CallExpr
 */
LHS LeftHandSide =
     CallExpr
   / NewExpr
   ;

/*
 * CallExpr ::=
 *   MemberExpr w Args
 * | CallExpr w Args
 * | CallExpr w [ w Expression w ]
 * | CallExpr w . w IdName
 */
LHS CallExpr =
    seed:CallExprFront list:CallExprTail*
    { yyValue = (LHS)apply(list, seed); };

LHS CallExprFront =
     a1:MemberExpr w a2:Args
     { Span span = createSpan(yyStart,yyCount+1);
       yyValue = NodeFactory.makeFunApp(span, a1, a2);
     };

constant transient Action<LHS> CallExprTail =
     FunApp
   / Bracket
   / Dot
   ;

constant inline Action<LHS> FunApp =
     w a1:Args
     { yyValue = new Action<LHS>() {
             public LHS run(LHS base) {
                 if (a1.isEmpty())
                     return NodeFactory.makeFunApp(NodeUtil.getSpan(base),
                                                   (LHS)base, a1);
                 else
                     return NodeFactory.makeFunApp(createSpan(yyStart,yyCount+1),
                                                   (LHS)base, a1);
             }};
     };

constant inline Action<LHS> Bracket =
     w opensquare w a1:Expression w closesquare
     { yyValue = new Action<LHS>() {
             public LHS run(LHS base) {
                 return NodeFactory.makeBracket(createSpan(yyStart,yyCount+1),
                                                (LHS)base, a1);
             }};
     };

constant inline Action<LHS> Dot =
     w dot w a1:IdName
     { yyValue = new Action<LHS>() {
             public LHS run(LHS base) {
                 return NodeFactory.makeDot(NodeFactory.makeSpan(NodeUtil.getSpan(base),
                                                                 NodeUtil.getSpan(a1)),
                                            (LHS)base, a1);
             }};
     };

/*
 * Args ::= ( (w ArgList)? w )
 */
private transient List<Expr> Args =
     openparen w closeparen
     { yyValue = Useful.list(); }
   / openparen w yyValue:ArgList w closeparen ;

/*
 * ArgList ::= Assignment (w , w Assignment)*
 */
private transient List<Expr> ArgList =
     a1:Assignment a2s:(w void:comma w Assignment)*
     { yyValue = Useful.cons(a1, a2s.list()); } ;

/*
 * NewExpr ::=
 *   MemberExpr
 * | new w NewExpr
 */
private transient LHS NewExpr =
     MemberExpr
   / new w a1:NewExpr
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeNew(span, a1);
     };

/*
 * MemberExpr ::=
 *   PrimaryExpr
 * | FunctionExpr
 * | MemberExpr w [ w Expression w ]
 * | MemberExpr w . w IdName
 * | new w MemberExpr w Args
 */
LHS MemberExpr =
    seed:MemberExprFront list:MemberExprTail*
    { yyValue = (LHS)apply(list, seed); };

LHS MemberExprFront =
     FunctionExpr
   / PrimaryExpr
   / new w a1:MemberExpr w a2:Args
     { Span span = createSpan(yyStart,yyCount+1);
       yyValue = NodeFactory.makeNew(span, NodeFactory.makeFunApp(span, a1, a2));
     };

constant transient Action<LHS> MemberExprTail =
     MemberBracket
   / MemberDot
   ;

constant inline Action<LHS> MemberBracket =
     w opensquare w a1:Expression w closesquare
     { yyValue = new Action<LHS>() {
             public LHS run(LHS base) {
                 return NodeFactory.makeBracket(createSpan(yyStart,yyCount+1),
                                                (LHS)base, a1);
             }};
     };

constant inline Action<LHS> MemberDot =
     w dot w a1:IdName
     { yyValue = new Action<LHS>() {
             public LHS run(LHS base) {
                 return NodeFactory.makeDot(NodeFactory.makeSpan(NodeUtil.getSpan(base),
                                                                 NodeUtil.getSpan(a1)),
                                            (LHS)base, a1);
             }};
     };

/*
 * PrimaryExpr ::=
 *   this
 * | Literal
 * | Id
 * | ArrayLiteral
 * | ObjectLiteral
 * | ( w Expression w )
 */
private transient LHS PrimaryExpr =
     this
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeThis(span);
     }
   / Literal
   / a1:Id
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeVarRef(span, a1);
     }
   / ArrayLiteral
   / ObjectLiteral
   / openparen w a1:Expression w closeparen
     { Span span = createSpan(yyStart,yyCount+1);
       yyValue = NodeFactory.makeParenthesized(span, a1);
     };

/*
 * ArrayLiteral ::=
 *   [ w (Elision w)? ]
 * | [ w ElementList w ]
 * | [ w ElementList w , w (Elision w)? ]
 */
private transient LHS ArrayLiteral =
     opensquare w a1:ElementList w comma w a2:(Elision w)? closesquare
     { Span span = createSpan(yyStart,yyCount+1);
       int elision;
       if (a2 == null) elision = 0; else elision = a2.intValue();
       List<Option<Expr>> result = new ArrayList<Option<Expr>>();
       result.addAll(a1);
       for (int i = 0; i < elision; i++)
           result.add(Option.<Expr>none());
       writer.close(); initParser();
       yyValue = NodeFactory.makeArrayExpr(span, result);
     }
   / opensquare w a1:ElementList w closesquare
     { Span span = createSpan(yyStart,yyCount+1);
       writer.close(); initParser();
       yyValue = NodeFactory.makeArrayExpr(span, a1);
     }
   / opensquare w a1:(Elision w)? closesquare
     { Span span = createSpan(yyStart,yyCount+1);
       int elision;
       if (a1 == null) elision = 0; else elision = a1.intValue();
       List<Option<Expr>> result = new ArrayList<Option<Expr>>(elision);
       for (int i = 0; i < elision; i++)
           result.add(Option.<Expr>none());
       writer.close(); initParser();
       yyValue = NodeFactory.makeArrayExpr(span, result);
     };

/*
 * ElementList ::=
 *   (Elision w)? Assignment
 * | ElementList w , w (Elision w)? Assignment
 */
private transient List<Option<Expr>> ElementList =
     seed:ElementListHead list:ElementListTail*
     { yyValue = (List<Option<Expr>>)apply(list, seed); };

private transient List<Option<Expr>> ElementListHead =
     a1:(Elision w)? a2:Assignment
     { int elision;
       if (a1 == null) elision = 0; else elision = a1.intValue();
       List<Option<Expr>> result = new ArrayList<Option<Expr>>(elision);
       for (int i = 0; i < elision; i++)
           result.add(Option.<Expr>none());
       yyValue = Useful.list(result, Option.some(a2));
     };

constant inline Action<List<Option<Expr>>> ElementListTail =
     w comma w a1:(Elision w)? a2:Assignment
     { yyValue = new Action<List<Option<Expr>>>() {
             public List<Option<Expr>> run(List<Option<Expr>> base) {
                 int elision;
                 if (a1 == null) elision = 0; else elision = a1.intValue();
                 List<Option<Expr>> result = new ArrayList<Option<Expr>>();
                 result.addAll(base);
                 for (int i = 0; i < elision; i++)
                     result.add(Option.<Expr>none());
                 return Useful.list(result, Option.some(a2));
             }};
     };

/*
 * Elision ::= (, w)+
 */
private transient Integer Elision =
     a1s:(w comma)+ { yyValue = a1s.size(); };

/*
 * ObjectLiteral ::= { (w PropAssignList)? (w ,)? w }
 */
private transient LHS ObjectLiteral =
     opencurly a1:(w PropAssignList)? (w comma)? w closecurly
     { Span span = createSpan(yyStart,yyCount+1);
       if (a1 == null) a1 = Useful.list();
       yyValue = NodeFactory.makeObjectExpr(span, a1);
     };

/*
 * PropAssignList ::= PropAssign (w , w PropAssign)*
 */
private transient List<Member> PropAssignList =
     a1:PropAssign a2s:(w void:comma w PropAssign)*
     { Span span = createSpan(yyStart,yyCount);
       yyValue = Useful.cons(a1, a2s.list());
     };

/*
 * PropAssign ::=
 *   PropName w : w Assignment
 * | get w PropName w ( w ) w FunctionBody
 * | set w PropName w ( w Id w ) w FunctionBody
 */
private transient Member PropAssign =
     get w a1:PropName w openparen w closeparen w a2:FunctionBody
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeGetProp(span, a1, a2);
     }
   / set w a1:PropName w openparen w a2:Id w closeparen w a3:FunctionBody
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeSetProp(span, a1, a2, a3);
     }
   / a1:PropName w colon w a2:Assignment
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makeField(span, a1, a2);
     };

/*
 * PropName ::=
 *   IdName
 * | StringLiteral
 * | NumericLiteral
 */
private transient Property PropName =
     a1:IdName
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePropId(span, a1);
     }
   / a1:StringLiteral
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePropStr(span, a1.getEscaped());
     }
   / a1:NumericLiteral
     { Span span = createSpan(yyStart,yyCount);
       yyValue = NodeFactory.makePropNum(span, a1);
     };
